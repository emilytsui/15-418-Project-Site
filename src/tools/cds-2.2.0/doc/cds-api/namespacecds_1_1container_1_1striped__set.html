<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cds: cds::container::striped_set Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacecds_1_1container_1_1striped__set.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::striped_set Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Striped hash set related definitions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1striped__set_1_1adapt.html">adapt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default adapter for hash set.  <a href="classcds_1_1container_1_1striped__set_1_1adapt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0a7761cda5122caa1ea5f22ac7182e65"><td class="memTemplParams" colspan="2">template&lt;size_t LoadFactor&gt; </td></tr>
<tr class="memitem:a0a7761cda5122caa1ea5f22ac7182e65"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecds_1_1container_1_1striped__set.html#a0a7761cda5122caa1ea5f22ac7182e65">load_factor_resizing</a> = <a class="el" href="structcds_1_1intrusive_1_1striped__set_1_1load__factor__resizing.html">cds::intrusive::striped_set::load_factor_resizing</a>&lt; LoadFactor &gt;</td></tr>
<tr class="memdesc:a0a7761cda5122caa1ea5f22ac7182e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load factor based resizing policy.  <a href="#a0a7761cda5122caa1ea5f22ac7182e65">More...</a><br /></td></tr>
<tr class="separator:a0a7761cda5122caa1ea5f22ac7182e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb66a63d8d57c10a0d6b88a7428d99c7"><td class="memTemplParams" colspan="2">template&lt;size_t Numerator, size_t Denominator = 1&gt; </td></tr>
<tr class="memitem:adb66a63d8d57c10a0d6b88a7428d99c7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecds_1_1container_1_1striped__set.html#adb66a63d8d57c10a0d6b88a7428d99c7">rational_load_factor_resizing</a> = <a class="el" href="structcds_1_1intrusive_1_1striped__set_1_1rational__load__factor__resizing.html">cds::intrusive::striped_set::rational_load_factor_resizing</a>&lt; Numerator, Denominator &gt;</td></tr>
<tr class="memdesc:adb66a63d8d57c10a0d6b88a7428d99c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rational load factor resizing policy.  <a href="#adb66a63d8d57c10a0d6b88a7428d99c7">More...</a><br /></td></tr>
<tr class="separator:adb66a63d8d57c10a0d6b88a7428d99c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a18c3ed19ff64e04680867f237e1e2"><td class="memTemplParams" colspan="2">template&lt;size_t Threshold&gt; </td></tr>
<tr class="memitem:a71a18c3ed19ff64e04680867f237e1e2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecds_1_1container_1_1striped__set.html#a71a18c3ed19ff64e04680867f237e1e2">single_bucket_size_threshold</a> = <a class="el" href="structcds_1_1intrusive_1_1striped__set_1_1single__bucket__size__threshold.html">cds::intrusive::striped_set::single_bucket_size_threshold</a>&lt; Threshold &gt;</td></tr>
<tr class="memdesc:a71a18c3ed19ff64e04680867f237e1e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single bucket threshold resizing policy.  <a href="#a71a18c3ed19ff64e04680867f237e1e2">More...</a><br /></td></tr>
<tr class="separator:a71a18c3ed19ff64e04680867f237e1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6926eacdbf9fb4fc264d6d85d353c2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structcds_1_1intrusive_1_1striped__set_1_1no__resizing.html">cds::intrusive::striped_set::no_resizing</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1container_1_1striped__set.html#a1a6926eacdbf9fb4fc264d6d85d353c2">no_resizing</a></td></tr>
<tr class="memdesc:a1a6926eacdbf9fb4fc264d6d85d353c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy resizing policy.  <a href="#a1a6926eacdbf9fb4fc264d6d85d353c2">More...</a><br /></td></tr>
<tr class="separator:a1a6926eacdbf9fb4fc264d6d85d353c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1883d4c26751fcc9d42afba2f00e3742"><td class="memTemplParams" colspan="2">template&lt;class Lock  = std::mutex, class Alloc  = CDS_DEFAULT_ALLOCATOR&gt; </td></tr>
<tr class="memitem:a1883d4c26751fcc9d42afba2f00e3742"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecds_1_1container_1_1striped__set.html#a1883d4c26751fcc9d42afba2f00e3742">striping</a> = <a class="el" href="classcds_1_1intrusive_1_1striped__set_1_1striping.html">cds::intrusive::striped_set::striping</a>&lt; Lock, Alloc &gt;</td></tr>
<tr class="memdesc:a1883d4c26751fcc9d42afba2f00e3742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock striping concurrent access policy.  <a href="#a1883d4c26751fcc9d42afba2f00e3742">More...</a><br /></td></tr>
<tr class="separator:a1883d4c26751fcc9d42afba2f00e3742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7addadcc56127b3e1cf5f25a64e9c821"><td class="memTemplParams" colspan="2">template&lt;class RecursiveLock  = std::recursive_mutex, typename BackOff  = cds::backoff::yield, class Alloc  = CDS_DEFAULT_ALLOCATOR&gt; </td></tr>
<tr class="memitem:a7addadcc56127b3e1cf5f25a64e9c821"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecds_1_1container_1_1striped__set.html#a7addadcc56127b3e1cf5f25a64e9c821">refinable</a> = <a class="el" href="classcds_1_1intrusive_1_1striped__set_1_1refinable.html">cds::intrusive::striped_set::refinable</a>&lt; RecursiveLock, BackOff, Alloc &gt;</td></tr>
<tr class="memdesc:a7addadcc56127b3e1cf5f25a64e9c821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refinable concurrent access policy.  <a href="#a7addadcc56127b3e1cf5f25a64e9c821">More...</a><br /></td></tr>
<tr class="separator:a7addadcc56127b3e1cf5f25a64e9c821"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Striped hash set related definitions. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a0a7761cda5122caa1ea5f22ac7182e65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7761cda5122caa1ea5f22ac7182e65">&sect;&nbsp;</a></span>load_factor_resizing</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t LoadFactor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecds_1_1container_1_1striped__set.html#a0a7761cda5122caa1ea5f22ac7182e65">cds::container::striped_set::load_factor_resizing</a> = typedef <a class="el" href="structcds_1_1intrusive_1_1striped__set_1_1load__factor__resizing.html">cds::intrusive::striped_set::load_factor_resizing</a>&lt;LoadFactor&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load factor based resizing policy. </p>
<p>When total item count in a container exceeds <code>container.bucket_count() * LoadFactor</code> then resizing is needed.</p>
<p>This policy is stateless.</p>
<p>The <code>reset()</code> function is called after the resizing is done. The function is intended for resetting internal state of the policy. </p>

</div>
</div>
<a id="a1a6926eacdbf9fb4fc264d6d85d353c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a6926eacdbf9fb4fc264d6d85d353c2">&sect;&nbsp;</a></span>no_resizing</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structcds_1_1intrusive_1_1striped__set_1_1no__resizing.html">cds::intrusive::striped_set::no_resizing</a> <a class="el" href="namespacecds_1_1container_1_1striped__set.html#a1a6926eacdbf9fb4fc264d6d85d353c2">cds::container::striped_set::no_resizing</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dummy resizing policy. </p>
<p>This policy is dummy and always returns <code>false</code> that means no resizing is needed.</p>
<p>This policy is stateless. </p>

</div>
</div>
<a id="adb66a63d8d57c10a0d6b88a7428d99c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb66a63d8d57c10a0d6b88a7428d99c7">&sect;&nbsp;</a></span>rational_load_factor_resizing</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Numerator, size_t Denominator = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecds_1_1container_1_1striped__set.html#adb66a63d8d57c10a0d6b88a7428d99c7">cds::container::striped_set::rational_load_factor_resizing</a> = typedef <a class="el" href="structcds_1_1intrusive_1_1striped__set_1_1rational__load__factor__resizing.html">cds::intrusive::striped_set::rational_load_factor_resizing</a>&lt;Numerator, Denominator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rational load factor resizing policy. </p>
<p>When total item count in a container exceeds <code>container.bucket_count() * Numerator / Denominator</code> then resizing is needed.</p>
<p>This policy is stateless: <code>Numerator</code> and <code>Denominator</code> specifies in compile time as template arguments </p>

</div>
</div>
<a id="a7addadcc56127b3e1cf5f25a64e9c821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7addadcc56127b3e1cf5f25a64e9c821">&sect;&nbsp;</a></span>refinable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RecursiveLock  = std::recursive_mutex, typename BackOff  = cds::backoff::yield, class Alloc  = CDS_DEFAULT_ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecds_1_1container_1_1striped__set.html#a7addadcc56127b3e1cf5f25a64e9c821">cds::container::striped_set::refinable</a> = typedef <a class="el" href="classcds_1_1intrusive_1_1striped__set_1_1refinable.html">cds::intrusive::striped_set::refinable</a>&lt;RecursiveLock, BackOff, Alloc &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refinable concurrent access policy. </p>
<p>This is one of available <a class="el" href="structcds_1_1opt_1_1mutex__policy.html" title="[type-option] Concurrent access policy ">opt::mutex_policy</a> option type for <a class="el" href="classcds_1_1container_1_1_striped_set.html" title="Striped hash set. ">StripedSet</a></p>
<p>Refining is like a striping technique (see <a class="el" href="namespacecds_1_1container_1_1striped__set.html#a1883d4c26751fcc9d42afba2f00e3742" title="Lock striping concurrent access policy. ">striped_set::striping</a>) but it allows growing the size of lock array when resizing the hash table. So, the sizes of hash table and lock array are equal.</p>
<p>Template arguments:</p><ul>
<li><code>RecursiveLock</code> - the type of mutex. Reentrant (recursive) mutex is required. The default is <code>std::recursive_mutex</code>. The mutex type should be default-constructible.</li>
<li><code>BackOff</code> - back-off strategy. Default is <a class="el" href="structcds_1_1backoff_1_1yield.html" title="Switch to another thread (yield). Good for thread preemption architecture. ">cds::backoff::yield</a></li>
<li><code>Alloc</code> - allocator type used for lock array memory allocation. Default is <code>CDS_DEFAULT_ALLOCATOR</code>. </li>
</ul>

</div>
</div>
<a id="a71a18c3ed19ff64e04680867f237e1e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71a18c3ed19ff64e04680867f237e1e2">&sect;&nbsp;</a></span>single_bucket_size_threshold</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Threshold&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecds_1_1container_1_1striped__set.html#a71a18c3ed19ff64e04680867f237e1e2">cds::container::striped_set::single_bucket_size_threshold</a> = typedef <a class="el" href="structcds_1_1intrusive_1_1striped__set_1_1single__bucket__size__threshold.html">cds::intrusive::striped_set::single_bucket_size_threshold</a>&lt;Threshold&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single bucket threshold resizing policy. </p>
<p>If any single bucket size exceeds the global <code>Threshold</code> then resizing is needed.</p>
<p>This policy is stateless. </p>

</div>
</div>
<a id="a1883d4c26751fcc9d42afba2f00e3742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1883d4c26751fcc9d42afba2f00e3742">&sect;&nbsp;</a></span>striping</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Lock  = std::mutex, class Alloc  = CDS_DEFAULT_ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecds_1_1container_1_1striped__set.html#a1883d4c26751fcc9d42afba2f00e3742">cds::container::striped_set::striping</a> = typedef <a class="el" href="classcds_1_1intrusive_1_1striped__set_1_1striping.html">cds::intrusive::striped_set::striping</a>&lt;Lock, Alloc&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock striping concurrent access policy. </p>
<p>This is one of available <a class="el" href="structcds_1_1opt_1_1mutex__policy.html" title="[type-option] Concurrent access policy ">opt::mutex_policy</a> option type for <a class="el" href="classcds_1_1container_1_1_striped_set.html" title="Striped hash set. ">StripedSet</a></p>
<p>Lock striping is very simple technique. The set consists of the bucket table and the array of locks. Initially, the capacity of lock array and bucket table is the same. When set is resized, bucket table capacity will be doubled but lock array will not. The lock <code>i</code> protects each bucket <code>j</code>, where <code> j = i mod L </code>, where <code>L</code> - the size of lock array.</p>
<p>The policy contains an internal array of <code>Lock</code> locks.</p>
<p>Template arguments:</p><ul>
<li><code>Lock</code> - the type of mutex. The default is <code>std::mutex</code>. The mutex type should be default-constructible. Note that a spin-lock is not so good suitable for lock striping for performance reason.</li>
<li><code>Alloc</code> - allocator type used for lock array memory allocation. Default is <code>CDS_DEFAULT_ALLOCATOR</code>. </li>
</ul>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.2.0</b> 
  Developed by <i>Maxim Khizhinsky aka khizmax</i> 2007 - 2017
  <br/>
  <i>Autogenerated Wed Jan 4 2017 08:49:48 by Doxygen 1.8.12</i>
</div>
</body>
</html>
