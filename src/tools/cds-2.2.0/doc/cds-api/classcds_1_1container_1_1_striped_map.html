<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cds: cds::container::StripedMap&lt; Container, Options &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcds_1_1container_1_1_striped_map.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::StripedMap&lt; Container, Options &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__nonintrusive__containers.html">Non-intrusive containers</a> &raquo; <a class="el" href="group__cds__nonintrusive__map.html">Map</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Striped hash map.  
 <a href="classcds_1_1container_1_1_striped_map.html#details">More...</a></p>

<p><code>#include &lt;cds/container/striped_map.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::container::StripedMap&lt; Container, Options &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1container_1_1_striped_map.png" usemap="#cds::container::StripedMap_3C_20Container_2C_20Options_20_3E_map" alt=""/>
  <map id="cds::container::StripedMap_3C_20Container_2C_20Options_20_3E_map" name="cds::container::StripedMap&lt; Container, Options &gt;_map">
<area href="classcds_1_1container_1_1_striped_set.html" alt="cds::container::StripedSet&lt; Container, Options... &gt;" shape="rect" coords="0,56,298,80"/>
<area href="classcds_1_1intrusive_1_1_striped_set.html" alt="cds::intrusive::StripedSet&lt; Container, Options... &gt;" shape="rect" coords="0,0,298,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2e8f54fde7d2f4330dbbd32e32da715a"><td class="memItemLeft" align="right" valign="top"><a id="a2e8f54fde7d2f4330dbbd32e32da715a"></a>
typedef Container&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a2e8f54fde7d2f4330dbbd32e32da715a">underlying_container_type</a></td></tr>
<tr class="memdesc:a2e8f54fde7d2f4330dbbd32e32da715a"><td class="mdescLeft">&#160;</td><td class="mdescRight">original intrusive container type for the bucket <br /></td></tr>
<tr class="separator:a2e8f54fde7d2f4330dbbd32e32da715a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41155b6b3ff185f4ee4a64bdf256c7d"><td class="memItemLeft" align="right" valign="top"><a id="af41155b6b3ff185f4ee4a64bdf256c7d"></a>
typedef base_class::bucket_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#af41155b6b3ff185f4ee4a64bdf256c7d">bucket_type</a></td></tr>
<tr class="memdesc:af41155b6b3ff185f4ee4a64bdf256c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">container type adapted for hash set <br /></td></tr>
<tr class="separator:af41155b6b3ff185f4ee4a64bdf256c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc37b83c74cd041b958aba25ff3ea079"><td class="memItemLeft" align="right" valign="top"><a id="abc37b83c74cd041b958aba25ff3ea079"></a>
typedef bucket_type::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#abc37b83c74cd041b958aba25ff3ea079">value_type</a></td></tr>
<tr class="memdesc:abc37b83c74cd041b958aba25ff3ea079"><td class="mdescLeft">&#160;</td><td class="mdescRight">pair type (<code> std::pair&lt;key_type const, mapped_type&gt; </code>) <br /></td></tr>
<tr class="separator:abc37b83c74cd041b958aba25ff3ea079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d2f85653d88cea2e02fc6c39a5d2b3"><td class="memItemLeft" align="right" valign="top"><a id="a95d2f85653d88cea2e02fc6c39a5d2b3"></a>
typedef value_type::first_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a95d2f85653d88cea2e02fc6c39a5d2b3">key_type</a></td></tr>
<tr class="memdesc:a95d2f85653d88cea2e02fc6c39a5d2b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">key type <br /></td></tr>
<tr class="separator:a95d2f85653d88cea2e02fc6c39a5d2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd34343ee928de44a8d121cfdbb11b9"><td class="memItemLeft" align="right" valign="top"><a id="abcd34343ee928de44a8d121cfdbb11b9"></a>
typedef value_type::second_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#abcd34343ee928de44a8d121cfdbb11b9">mapped_type</a></td></tr>
<tr class="memdesc:abcd34343ee928de44a8d121cfdbb11b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">mapped type <br /></td></tr>
<tr class="separator:abcd34343ee928de44a8d121cfdbb11b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1b0a9b45e942498737a5652b325e26"><td class="memItemLeft" align="right" valign="top"><a id="a6b1b0a9b45e942498737a5652b325e26"></a>
typedef base_class::hash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a6b1b0a9b45e942498737a5652b325e26">hash</a></td></tr>
<tr class="memdesc:a6b1b0a9b45e942498737a5652b325e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor. <br /></td></tr>
<tr class="separator:a6b1b0a9b45e942498737a5652b325e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4097c7d9306f06b3fb0ef3f351387040"><td class="memItemLeft" align="right" valign="top"><a id="a4097c7d9306f06b3fb0ef3f351387040"></a>
typedef base_class::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a4097c7d9306f06b3fb0ef3f351387040">item_counter</a></td></tr>
<tr class="memdesc:a4097c7d9306f06b3fb0ef3f351387040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter. <br /></td></tr>
<tr class="separator:a4097c7d9306f06b3fb0ef3f351387040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3155c54ac7cc35f2ab627ce6eb7333e3"><td class="memItemLeft" align="right" valign="top"><a id="a3155c54ac7cc35f2ab627ce6eb7333e3"></a>
typedef base_class::resizing_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a3155c54ac7cc35f2ab627ce6eb7333e3">resizing_policy</a></td></tr>
<tr class="memdesc:a3155c54ac7cc35f2ab627ce6eb7333e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizing policy. <br /></td></tr>
<tr class="separator:a3155c54ac7cc35f2ab627ce6eb7333e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6492d65eb7a28cb6a6714b0c04b826df"><td class="memItemLeft" align="right" valign="top"><a id="a6492d65eb7a28cb6a6714b0c04b826df"></a>
typedef base_class::allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a6492d65eb7a28cb6a6714b0c04b826df">allocator_type</a></td></tr>
<tr class="memdesc:a6492d65eb7a28cb6a6714b0c04b826df"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator type specified in options. <br /></td></tr>
<tr class="separator:a6492d65eb7a28cb6a6714b0c04b826df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c68a4f3ca5a79fcffac0cb2624e0441"><td class="memItemLeft" align="right" valign="top"><a id="a0c68a4f3ca5a79fcffac0cb2624e0441"></a>
typedef base_class::mutex_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a0c68a4f3ca5a79fcffac0cb2624e0441">mutex_policy</a></td></tr>
<tr class="memdesc:a0c68a4f3ca5a79fcffac0cb2624e0441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex policy. <br /></td></tr>
<tr class="separator:a0c68a4f3ca5a79fcffac0cb2624e0441"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2fb520f4aeda28167438e1f7ccd531df"><td class="memItemLeft" align="right" valign="top"><a id="a2fb520f4aeda28167438e1f7ccd531df"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a2fb520f4aeda28167438e1f7ccd531df">StripedMap</a> ()</td></tr>
<tr class="memdesc:a2fb520f4aeda28167438e1f7ccd531df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default ctor. The initial capacity is 16. <br /></td></tr>
<tr class="separator:a2fb520f4aeda28167438e1f7ccd531df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892bd935c22aad68b394f3faa67ce8ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a892bd935c22aad68b394f3faa67ce8ec">StripedMap</a> (size_t nCapacity)</td></tr>
<tr class="memdesc:a892bd935c22aad68b394f3faa67ce8ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with initial capacity specified.  <a href="#a892bd935c22aad68b394f3faa67ce8ec">More...</a><br /></td></tr>
<tr class="separator:a892bd935c22aad68b394f3faa67ce8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c828a31c862660ff8b6ae35e89e8d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#ab1c828a31c862660ff8b6ae35e89e8d0">StripedMap</a> (size_t nCapacity, <a class="el" href="classcds_1_1container_1_1_striped_map.html#a3155c54ac7cc35f2ab627ce6eb7333e3">resizing_policy</a> const &amp;resizingPolicy)</td></tr>
<tr class="memdesc:ab1c828a31c862660ff8b6ae35e89e8d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with resizing policy (copy semantics)  <a href="#ab1c828a31c862660ff8b6ae35e89e8d0">More...</a><br /></td></tr>
<tr class="separator:ab1c828a31c862660ff8b6ae35e89e8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad331b6324ae414f56df0324d3435a54f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#ad331b6324ae414f56df0324d3435a54f">StripedMap</a> (size_t nCapacity, <a class="el" href="classcds_1_1container_1_1_striped_map.html#a3155c54ac7cc35f2ab627ce6eb7333e3">resizing_policy</a> &amp;&amp;resizingPolicy)</td></tr>
<tr class="memdesc:ad331b6324ae414f56df0324d3435a54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with resizing policy (move semantics)  <a href="#ad331b6324ae414f56df0324d3435a54f">More...</a><br /></td></tr>
<tr class="separator:ad331b6324ae414f56df0324d3435a54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d5a55697a29b39d471dd71b580cbc3"><td class="memItemLeft" align="right" valign="top"><a id="a09d5a55697a29b39d471dd71b580cbc3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a09d5a55697a29b39d471dd71b580cbc3">~StripedMap</a> ()</td></tr>
<tr class="memdesc:a09d5a55697a29b39d471dd71b580cbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor destroys internal data. <br /></td></tr>
<tr class="separator:a09d5a55697a29b39d471dd71b580cbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8306ce18508455e5a4761f8a051f6c16"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a8306ce18508455e5a4761f8a051f6c16"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a8306ce18508455e5a4761f8a051f6c16">insert</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a8306ce18508455e5a4761f8a051f6c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node with key and default value.  <a href="#a8306ce18508455e5a4761f8a051f6c16">More...</a><br /></td></tr>
<tr class="separator:a8306ce18508455e5a4761f8a051f6c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5543dba6bc798cb924b41de9f98cfedf"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a5543dba6bc798cb924b41de9f98cfedf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a5543dba6bc798cb924b41de9f98cfedf">insert</a> (K const &amp;key, V const &amp;val)</td></tr>
<tr class="memdesc:a5543dba6bc798cb924b41de9f98cfedf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a5543dba6bc798cb924b41de9f98cfedf">More...</a><br /></td></tr>
<tr class="separator:a5543dba6bc798cb924b41de9f98cfedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd563bbd37f3b08f2763c3cff9abaf49"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:abd563bbd37f3b08f2763c3cff9abaf49"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#abd563bbd37f3b08f2763c3cff9abaf49">insert_with</a> (const K &amp;key, Func func)</td></tr>
<tr class="memdesc:abd563bbd37f3b08f2763c3cff9abaf49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node and initialize it by a functor.  <a href="#abd563bbd37f3b08f2763c3cff9abaf49">More...</a><br /></td></tr>
<tr class="separator:abd563bbd37f3b08f2763c3cff9abaf49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1377e67bb7bf2b40ace6d8bb9f3f3da"><td class="memTemplParams" colspan="2">template&lt;typename K , typename... Args&gt; </td></tr>
<tr class="memitem:ab1377e67bb7bf2b40ace6d8bb9f3f3da"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#ab1377e67bb7bf2b40ace6d8bb9f3f3da">emplace</a> (K &amp;&amp;key, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab1377e67bb7bf2b40ace6d8bb9f3f3da"><td class="mdescLeft">&#160;</td><td class="mdescRight">For key <code>key</code> inserts data of type <code>mapped_type</code> created in-place from <code>args</code>.  <a href="#ab1377e67bb7bf2b40ace6d8bb9f3f3da">More...</a><br /></td></tr>
<tr class="separator:ab1377e67bb7bf2b40ace6d8bb9f3f3da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b091820cf0277af86e4b214e7eb74a6"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a7b091820cf0277af86e4b214e7eb74a6"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a7b091820cf0277af86e4b214e7eb74a6">update</a> (K const &amp;key, Func func, bool bAllowInsert=true)</td></tr>
<tr class="memdesc:a7b091820cf0277af86e4b214e7eb74a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the node.  <a href="#a7b091820cf0277af86e4b214e7eb74a6">More...</a><br /></td></tr>
<tr class="separator:a7b091820cf0277af86e4b214e7eb74a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4f29d2c1f58e1f92759f3fad808bb3"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:abf4f29d2c1f58e1f92759f3fad808bb3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#abf4f29d2c1f58e1f92759f3fad808bb3">erase</a> (K const &amp;key)</td></tr>
<tr class="memdesc:abf4f29d2c1f58e1f92759f3fad808bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the map.  <a href="#abf4f29d2c1f58e1f92759f3fad808bb3">More...</a><br /></td></tr>
<tr class="separator:abf4f29d2c1f58e1f92759f3fad808bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f28cdf88f10e2fcc0910e00c9854f4e"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Bucket  = bucket_type, typename  = typename std::enable_if&lt; Bucket::has_erase_with &gt;::type&gt; </td></tr>
<tr class="memitem:a0f28cdf88f10e2fcc0910e00c9854f4e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a0f28cdf88f10e2fcc0910e00c9854f4e">erase_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a0f28cdf88f10e2fcc0910e00c9854f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the map using <code>pred</code> predicate for searching.  <a href="#a0f28cdf88f10e2fcc0910e00c9854f4e">More...</a><br /></td></tr>
<tr class="separator:a0f28cdf88f10e2fcc0910e00c9854f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213858e29c6865981935d07665804048"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a213858e29c6865981935d07665804048"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a213858e29c6865981935d07665804048">erase</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:a213858e29c6865981935d07665804048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the map.  <a href="#a213858e29c6865981935d07665804048">More...</a><br /></td></tr>
<tr class="separator:a213858e29c6865981935d07665804048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ebc1913a673717786c8f7598b9237b"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Func , typename Bucket  = bucket_type, typename  = typename std::enable_if&lt; Bucket::has_erase_with &gt;::type&gt; </td></tr>
<tr class="memitem:af7ebc1913a673717786c8f7598b9237b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#af7ebc1913a673717786c8f7598b9237b">erase_with</a> (K const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:af7ebc1913a673717786c8f7598b9237b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the map using <code>pred</code> predicate for searching.  <a href="#af7ebc1913a673717786c8f7598b9237b">More...</a><br /></td></tr>
<tr class="separator:af7ebc1913a673717786c8f7598b9237b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc91ff823125ec02014aab0911083f5"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a7cc91ff823125ec02014aab0911083f5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a7cc91ff823125ec02014aab0911083f5">find</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:a7cc91ff823125ec02014aab0911083f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>key</code>.  <a href="#a7cc91ff823125ec02014aab0911083f5">More...</a><br /></td></tr>
<tr class="separator:a7cc91ff823125ec02014aab0911083f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1353dfa60543a01fc0092733129a4fd"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Func , typename Bucket  = bucket_type, typename  = typename std::enable_if&lt; Bucket::has_find_with &gt;::type&gt; </td></tr>
<tr class="memitem:aa1353dfa60543a01fc0092733129a4fd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#aa1353dfa60543a01fc0092733129a4fd">find_with</a> (K const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:aa1353dfa60543a01fc0092733129a4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code> using <code>pred</code> predicate.  <a href="#aa1353dfa60543a01fc0092733129a4fd">More...</a><br /></td></tr>
<tr class="separator:aa1353dfa60543a01fc0092733129a4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b5e87952d9a31cb50707f71dfaef61"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a00b5e87952d9a31cb50707f71dfaef61"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a00b5e87952d9a31cb50707f71dfaef61">contains</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a00b5e87952d9a31cb50707f71dfaef61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the map contains <code>key</code>.  <a href="#a00b5e87952d9a31cb50707f71dfaef61">More...</a><br /></td></tr>
<tr class="separator:a00b5e87952d9a31cb50707f71dfaef61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d217945377cb14045e40c4ea862aafd"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Bucket  = bucket_type, typename  = typename std::enable_if&lt; Bucket::has_find_with &gt;::type&gt; </td></tr>
<tr class="memitem:a9d217945377cb14045e40c4ea862aafd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a9d217945377cb14045e40c4ea862aafd">contains</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a9d217945377cb14045e40c4ea862aafd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>key</code> using <code>pred</code> predicate for searching.  <a href="#a9d217945377cb14045e40c4ea862aafd">More...</a><br /></td></tr>
<tr class="separator:a9d217945377cb14045e40c4ea862aafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f13b4556ea60dfa9a77c9e44040812b"><td class="memItemLeft" align="right" valign="top"><a id="a0f13b4556ea60dfa9a77c9e44040812b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a0f13b4556ea60dfa9a77c9e44040812b">clear</a> ()</td></tr>
<tr class="memdesc:a0f13b4556ea60dfa9a77c9e44040812b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the map. <br /></td></tr>
<tr class="separator:a0f13b4556ea60dfa9a77c9e44040812b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e02f63d146c37c574d3432f84d1ba9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#ac1e02f63d146c37c574d3432f84d1ba9">empty</a> () const</td></tr>
<tr class="memdesc:ac1e02f63d146c37c574d3432f84d1ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the map is empty.  <a href="#ac1e02f63d146c37c574d3432f84d1ba9">More...</a><br /></td></tr>
<tr class="separator:ac1e02f63d146c37c574d3432f84d1ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289aecf9771b5c4602375f89871583a3"><td class="memItemLeft" align="right" valign="top"><a id="a289aecf9771b5c4602375f89871583a3"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a289aecf9771b5c4602375f89871583a3">size</a> () const</td></tr>
<tr class="memdesc:a289aecf9771b5c4602375f89871583a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the map. <br /></td></tr>
<tr class="separator:a289aecf9771b5c4602375f89871583a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856f6f7aa7bbeffd0e447c1fee9e3d4a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a856f6f7aa7bbeffd0e447c1fee9e3d4a">bucket_count</a> () const</td></tr>
<tr class="memdesc:a856f6f7aa7bbeffd0e447c1fee9e3d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of hash table.  <a href="#a856f6f7aa7bbeffd0e447c1fee9e3d4a">More...</a><br /></td></tr>
<tr class="separator:a856f6f7aa7bbeffd0e447c1fee9e3d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a5fb6f0e6a0723b22e70520147407c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a82a5fb6f0e6a0723b22e70520147407c">lock_count</a> () const</td></tr>
<tr class="memdesc:a82a5fb6f0e6a0723b22e70520147407c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns lock array size.  <a href="#a82a5fb6f0e6a0723b22e70520147407c">More...</a><br /></td></tr>
<tr class="separator:a82a5fb6f0e6a0723b22e70520147407c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583e325eae8997307d5c08d7d313cb46"><td class="memItemLeft" align="right" valign="top"><a id="a583e325eae8997307d5c08d7d313cb46"></a>
<a class="el" href="classcds_1_1container_1_1_striped_map.html#a3155c54ac7cc35f2ab627ce6eb7333e3">resizing_policy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a583e325eae8997307d5c08d7d313cb46">get_resizing_policy</a> ()</td></tr>
<tr class="memdesc:a583e325eae8997307d5c08d7d313cb46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns resizing policy object. <br /></td></tr>
<tr class="separator:a583e325eae8997307d5c08d7d313cb46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26bcbceeaa2d6fc905edc6b76cfd40c"><td class="memItemLeft" align="right" valign="top"><a id="ad26bcbceeaa2d6fc905edc6b76cfd40c"></a>
<a class="el" href="classcds_1_1container_1_1_striped_map.html#a3155c54ac7cc35f2ab627ce6eb7333e3">resizing_policy</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_map.html#ad26bcbceeaa2d6fc905edc6b76cfd40c">get_resizing_policy</a> () const</td></tr>
<tr class="memdesc:ad26bcbceeaa2d6fc905edc6b76cfd40c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns resizing policy (const version) <br /></td></tr>
<tr class="separator:ad26bcbceeaa2d6fc905edc6b76cfd40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_types_classcds_1_1container_1_1_striped_set"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classcds_1_1container_1_1_striped_set')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet&lt; Container, Options... &gt;</a></td></tr>
<tr class="memitem:ab78f765a66999a851520edd05688f688 inherit pro_types_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="ab78f765a66999a851520edd05688f688"></a>
typedef Container&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#ab78f765a66999a851520edd05688f688">underlying_container_type</a></td></tr>
<tr class="memdesc:ab78f765a66999a851520edd05688f688 inherit pro_types_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">original intrusive container type for the bucket <br /></td></tr>
<tr class="separator:ab78f765a66999a851520edd05688f688 inherit pro_types_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd05847a606289e2125e22c390836e2d inherit pro_types_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="acd05847a606289e2125e22c390836e2d"></a>
typedef base_class::bucket_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#acd05847a606289e2125e22c390836e2d">bucket_type</a></td></tr>
<tr class="memdesc:acd05847a606289e2125e22c390836e2d inherit pro_types_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">container type adapted for hash set <br /></td></tr>
<tr class="separator:acd05847a606289e2125e22c390836e2d inherit pro_types_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2497aaa946640a16825e61d14a6d6189 inherit pro_types_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="a2497aaa946640a16825e61d14a6d6189"></a>
typedef bucket_type::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a2497aaa946640a16825e61d14a6d6189">value_type</a></td></tr>
<tr class="memdesc:a2497aaa946640a16825e61d14a6d6189 inherit pro_types_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">value type stored in the set <br /></td></tr>
<tr class="separator:a2497aaa946640a16825e61d14a6d6189 inherit pro_types_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b1488d09e53e4fdadf2581db30b311 inherit pro_types_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="ab3b1488d09e53e4fdadf2581db30b311"></a>
typedef base_class::hash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#ab3b1488d09e53e4fdadf2581db30b311">hash</a></td></tr>
<tr class="memdesc:ab3b1488d09e53e4fdadf2581db30b311 inherit pro_types_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor. <br /></td></tr>
<tr class="separator:ab3b1488d09e53e4fdadf2581db30b311 inherit pro_types_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8e128e84f4a17ae60a837867556050 inherit pro_types_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="aff8e128e84f4a17ae60a837867556050"></a>
typedef base_class::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#aff8e128e84f4a17ae60a837867556050">item_counter</a></td></tr>
<tr class="memdesc:aff8e128e84f4a17ae60a837867556050 inherit pro_types_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter. <br /></td></tr>
<tr class="separator:aff8e128e84f4a17ae60a837867556050 inherit pro_types_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132347759ae9e7929c5dc75a53890687 inherit pro_types_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="a132347759ae9e7929c5dc75a53890687"></a>
typedef base_class::resizing_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a132347759ae9e7929c5dc75a53890687">resizing_policy</a></td></tr>
<tr class="memdesc:a132347759ae9e7929c5dc75a53890687 inherit pro_types_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizing policy. <br /></td></tr>
<tr class="separator:a132347759ae9e7929c5dc75a53890687 inherit pro_types_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae456575fca3f9634a4cbc25504d01a2a inherit pro_types_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="ae456575fca3f9634a4cbc25504d01a2a"></a>
typedef base_class::allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#ae456575fca3f9634a4cbc25504d01a2a">allocator_type</a></td></tr>
<tr class="memdesc:ae456575fca3f9634a4cbc25504d01a2a inherit pro_types_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator type specified in options. <br /></td></tr>
<tr class="separator:ae456575fca3f9634a4cbc25504d01a2a inherit pro_types_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52867de81f8ae19c2bc1d261694470ec inherit pro_types_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="a52867de81f8ae19c2bc1d261694470ec"></a>
typedef base_class::mutex_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a52867de81f8ae19c2bc1d261694470ec">mutex_policy</a></td></tr>
<tr class="memdesc:a52867de81f8ae19c2bc1d261694470ec inherit pro_types_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex policy. <br /></td></tr>
<tr class="separator:a52867de81f8ae19c2bc1d261694470ec inherit pro_types_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_classcds_1_1intrusive_1_1_striped_set"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classcds_1_1intrusive_1_1_striped_set')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet&lt; Container, Options... &gt;</a></td></tr>
<tr class="memitem:a30062f90ac31fe161c7cd4539fcaaf13 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="a30062f90ac31fe161c7cd4539fcaaf13"></a>
typedef Container&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a30062f90ac31fe161c7cd4539fcaaf13">underlying_container_type</a></td></tr>
<tr class="memdesc:a30062f90ac31fe161c7cd4539fcaaf13 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">original intrusive container type for the bucket <br /></td></tr>
<tr class="separator:a30062f90ac31fe161c7cd4539fcaaf13 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f7511b1b3c53680be6608678020bb5 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="ac0f7511b1b3c53680be6608678020bb5"></a>
typedef <a class="el" href="classcds_1_1intrusive_1_1striped__set_1_1adapt.html">cds::intrusive::striped_set::adapt</a>&lt; <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a30062f90ac31fe161c7cd4539fcaaf13">underlying_container_type</a>, Options... &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#ac0f7511b1b3c53680be6608678020bb5">bucket_type</a></td></tr>
<tr class="memdesc:ac0f7511b1b3c53680be6608678020bb5 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">container type adapted for hash set <br /></td></tr>
<tr class="separator:ac0f7511b1b3c53680be6608678020bb5 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999c16c7efc7a140c386cf8089d43f7b inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="a999c16c7efc7a140c386cf8089d43f7b"></a>
typedef bucket_type::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a></td></tr>
<tr class="memdesc:a999c16c7efc7a140c386cf8089d43f7b inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">value type stored in the set <br /></td></tr>
<tr class="separator:a999c16c7efc7a140c386cf8089d43f7b inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b11af7149d2edcdcf89875dd82f29c3 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="a3b11af7149d2edcdcf89875dd82f29c3"></a>
typedef options::hash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a3b11af7149d2edcdcf89875dd82f29c3">hash</a></td></tr>
<tr class="memdesc:a3b11af7149d2edcdcf89875dd82f29c3 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor. <br /></td></tr>
<tr class="separator:a3b11af7149d2edcdcf89875dd82f29c3 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc27916ad8566742257adde4f5b0d36c inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="abc27916ad8566742257adde4f5b0d36c"></a>
typedef options::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#abc27916ad8566742257adde4f5b0d36c">item_counter</a></td></tr>
<tr class="memdesc:abc27916ad8566742257adde4f5b0d36c inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter. <br /></td></tr>
<tr class="separator:abc27916ad8566742257adde4f5b0d36c inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e9218d8f7724ddc07c1b41c8d91e7f inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="a73e9218d8f7724ddc07c1b41c8d91e7f"></a>
typedef <a class="el" href="structcds_1_1opt_1_1select__default.html">cds::opt::select_default</a>&lt; typename options::resizing_policy, typename bucket_type::default_resizing_policy &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a73e9218d8f7724ddc07c1b41c8d91e7f">resizing_policy</a></td></tr>
<tr class="memdesc:a73e9218d8f7724ddc07c1b41c8d91e7f inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizing policy. <br /></td></tr>
<tr class="separator:a73e9218d8f7724ddc07c1b41c8d91e7f inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47cdc2d40853a651780c1a2afe7309ed inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="a47cdc2d40853a651780c1a2afe7309ed"></a>
typedef options::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a47cdc2d40853a651780c1a2afe7309ed">allocator_type</a></td></tr>
<tr class="memdesc:a47cdc2d40853a651780c1a2afe7309ed inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator type specified in options. <br /></td></tr>
<tr class="separator:a47cdc2d40853a651780c1a2afe7309ed inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af672d590a91e09833aa27621f7e35c26 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="af672d590a91e09833aa27621f7e35c26"></a>
typedef options::mutex_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#af672d590a91e09833aa27621f7e35c26">mutex_policy</a></td></tr>
<tr class="memdesc:af672d590a91e09833aa27621f7e35c26 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex policy. <br /></td></tr>
<tr class="separator:af672d590a91e09833aa27621f7e35c26 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7217f5fc38b03f908957969c227dc28 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="ad7217f5fc38b03f908957969c227dc28"></a>
typedef <a class="el" href="classcds_1_1details_1_1_allocator.html">cds::details::Allocator</a>&lt; <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#ac0f7511b1b3c53680be6608678020bb5">bucket_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a47cdc2d40853a651780c1a2afe7309ed">allocator_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#ad7217f5fc38b03f908957969c227dc28">bucket_allocator</a></td></tr>
<tr class="memdesc:ad7217f5fc38b03f908957969c227dc28 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">bucket allocator type based on allocator_type <br /></td></tr>
<tr class="separator:ad7217f5fc38b03f908957969c227dc28 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classcds_1_1container_1_1_striped_set"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classcds_1_1container_1_1_striped_set')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet&lt; Container, Options... &gt;</a></td></tr>
<tr class="memitem:a5b62b8c4af0730a78837e3c8a29994c2 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="a5b62b8c4af0730a78837e3c8a29994c2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a5b62b8c4af0730a78837e3c8a29994c2">StripedSet</a> ()</td></tr>
<tr class="memdesc:a5b62b8c4af0730a78837e3c8a29994c2 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default ctor. The initial capacity is 16. <br /></td></tr>
<tr class="separator:a5b62b8c4af0730a78837e3c8a29994c2 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319c779ca7127d5fc03ade9a521a0338 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a319c779ca7127d5fc03ade9a521a0338">StripedSet</a> (size_t nCapacity)</td></tr>
<tr class="memdesc:a319c779ca7127d5fc03ade9a521a0338 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with initial capacity specified.  <a href="classcds_1_1container_1_1_striped_set.html#a319c779ca7127d5fc03ade9a521a0338">More...</a><br /></td></tr>
<tr class="separator:a319c779ca7127d5fc03ade9a521a0338 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481f34c5eb75bfb09aa7eca7f91c6e13 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a481f34c5eb75bfb09aa7eca7f91c6e13">StripedSet</a> (size_t nCapacity, <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a73e9218d8f7724ddc07c1b41c8d91e7f">resizing_policy</a> const &amp;resizingPolicy)</td></tr>
<tr class="memdesc:a481f34c5eb75bfb09aa7eca7f91c6e13 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with resizing policy (copy semantics)  <a href="classcds_1_1container_1_1_striped_set.html#a481f34c5eb75bfb09aa7eca7f91c6e13">More...</a><br /></td></tr>
<tr class="separator:a481f34c5eb75bfb09aa7eca7f91c6e13 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2289fff041c278598a6fe5e447ceb7 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a0a2289fff041c278598a6fe5e447ceb7">StripedSet</a> (size_t nCapacity, <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a73e9218d8f7724ddc07c1b41c8d91e7f">resizing_policy</a> &amp;&amp;resizingPolicy)</td></tr>
<tr class="memdesc:a0a2289fff041c278598a6fe5e447ceb7 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with resizing policy (move semantics)  <a href="classcds_1_1container_1_1_striped_set.html#a0a2289fff041c278598a6fe5e447ceb7">More...</a><br /></td></tr>
<tr class="separator:a0a2289fff041c278598a6fe5e447ceb7 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eee4ba35c6a33a03d12ad436cefc832 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="a0eee4ba35c6a33a03d12ad436cefc832"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a0eee4ba35c6a33a03d12ad436cefc832">~StripedSet</a> ()</td></tr>
<tr class="memdesc:a0eee4ba35c6a33a03d12ad436cefc832 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor destroys internal data. <br /></td></tr>
<tr class="separator:a0eee4ba35c6a33a03d12ad436cefc832 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8843b99b6f85ad37e9b4e4d920f523 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#aff8843b99b6f85ad37e9b4e4d920f523">insert</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:aff8843b99b6f85ad37e9b4e4d920f523 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="classcds_1_1container_1_1_striped_set.html#aff8843b99b6f85ad37e9b4e4d920f523">More...</a><br /></td></tr>
<tr class="separator:aff8843b99b6f85ad37e9b4e4d920f523 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6516d09d6a558712c1827bf57bd65b53 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a6516d09d6a558712c1827bf57bd65b53">insert</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:a6516d09d6a558712c1827bf57bd65b53 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="classcds_1_1container_1_1_striped_set.html#a6516d09d6a558712c1827bf57bd65b53">More...</a><br /></td></tr>
<tr class="separator:a6516d09d6a558712c1827bf57bd65b53 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad9d39e24e0e1104be28f212e22fedc inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a7ad9d39e24e0e1104be28f212e22fedc">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a7ad9d39e24e0e1104be28f212e22fedc inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts data of type <code>value_type</code> constructed with <code>std::forward&lt;Args&gt;(args)...</code>  <a href="classcds_1_1container_1_1_striped_set.html#a7ad9d39e24e0e1104be28f212e22fedc">More...</a><br /></td></tr>
<tr class="separator:a7ad9d39e24e0e1104be28f212e22fedc inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0bc8935f7925e4b446c6b1c1e37d247 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#af0bc8935f7925e4b446c6b1c1e37d247">update</a> (Q const &amp;val, Func func, bool bAllowInsert=true)</td></tr>
<tr class="memdesc:af0bc8935f7925e4b446c6b1c1e37d247 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the node.  <a href="classcds_1_1container_1_1_striped_set.html#af0bc8935f7925e4b446c6b1c1e37d247">More...</a><br /></td></tr>
<tr class="separator:af0bc8935f7925e4b446c6b1c1e37d247 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89f2115ab187e2105c91dd933cb82d7 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#ad89f2115ab187e2105c91dd933cb82d7">erase</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:ad89f2115ab187e2105c91dd933cb82d7 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the set.  <a href="classcds_1_1container_1_1_striped_set.html#ad89f2115ab187e2105c91dd933cb82d7">More...</a><br /></td></tr>
<tr class="separator:ad89f2115ab187e2105c91dd933cb82d7 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3e75924c53c72d92082b484975af7a inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a0c3e75924c53c72d92082b484975af7a">erase</a> (Q const &amp;key, Func f)</td></tr>
<tr class="memdesc:a0c3e75924c53c72d92082b484975af7a inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the set.  <a href="classcds_1_1container_1_1_striped_set.html#a0c3e75924c53c72d92082b484975af7a">More...</a><br /></td></tr>
<tr class="separator:a0c3e75924c53c72d92082b484975af7a inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93bbd4712424855500108292e10935f7 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a93bbd4712424855500108292e10935f7">erase_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a93bbd4712424855500108292e10935f7 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="classcds_1_1container_1_1_striped_set.html#a93bbd4712424855500108292e10935f7">More...</a><br /></td></tr>
<tr class="separator:a93bbd4712424855500108292e10935f7 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af161c84a97d8357664c37720bdf77879 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#af161c84a97d8357664c37720bdf77879">erase_with</a> (Q const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:af161c84a97d8357664c37720bdf77879 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="classcds_1_1container_1_1_striped_set.html#af161c84a97d8357664c37720bdf77879">More...</a><br /></td></tr>
<tr class="separator:af161c84a97d8357664c37720bdf77879 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203525441d38698012f814d8408f6d36 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a203525441d38698012f814d8408f6d36">find</a> (Q &amp;val, Func f)</td></tr>
<tr class="memdesc:a203525441d38698012f814d8408f6d36 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="classcds_1_1container_1_1_striped_set.html#a203525441d38698012f814d8408f6d36">More...</a><br /></td></tr>
<tr class="separator:a203525441d38698012f814d8408f6d36 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9099506c1034b3a5f437db5e73c1d0 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#acb9099506c1034b3a5f437db5e73c1d0">find</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:acb9099506c1034b3a5f437db5e73c1d0 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="classcds_1_1container_1_1_striped_set.html#acb9099506c1034b3a5f437db5e73c1d0">More...</a><br /></td></tr>
<tr class="separator:acb9099506c1034b3a5f437db5e73c1d0 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aaecb8e05cd335c57507c1a69ea3078 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a7aaecb8e05cd335c57507c1a69ea3078">find_with</a> (Q &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:a7aaecb8e05cd335c57507c1a69ea3078 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code> using <code>pred</code> predicate.  <a href="classcds_1_1container_1_1_striped_set.html#a7aaecb8e05cd335c57507c1a69ea3078">More...</a><br /></td></tr>
<tr class="separator:a7aaecb8e05cd335c57507c1a69ea3078 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a062a1d56946e140c120856be09b04a inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a6a062a1d56946e140c120856be09b04a">find_with</a> (Q const &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:a6a062a1d56946e140c120856be09b04a inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code> using <code>pred</code> predicate.  <a href="classcds_1_1container_1_1_striped_set.html#a6a062a1d56946e140c120856be09b04a">More...</a><br /></td></tr>
<tr class="separator:a6a062a1d56946e140c120856be09b04a inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0dfbf9bd83bc92c1d7611532811c523 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#aa0dfbf9bd83bc92c1d7611532811c523">contains</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:aa0dfbf9bd83bc92c1d7611532811c523 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>key</code>.  <a href="classcds_1_1container_1_1_striped_set.html#aa0dfbf9bd83bc92c1d7611532811c523">More...</a><br /></td></tr>
<tr class="separator:aa0dfbf9bd83bc92c1d7611532811c523 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4581ada4d40d30156be2138d96209008 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a4581ada4d40d30156be2138d96209008">contains</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a4581ada4d40d30156be2138d96209008 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the map contains <code>key</code> using <code>pred</code> predicate for searching.  <a href="classcds_1_1container_1_1_striped_set.html#a4581ada4d40d30156be2138d96209008">More...</a><br /></td></tr>
<tr class="separator:a4581ada4d40d30156be2138d96209008 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bdfcbca5e48b3d517b9e450a06e9be1 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a4bdfcbca5e48b3d517b9e450a06e9be1">clear</a> ()</td></tr>
<tr class="memdesc:a4bdfcbca5e48b3d517b9e450a06e9be1 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set.  <a href="classcds_1_1container_1_1_striped_set.html#a4bdfcbca5e48b3d517b9e450a06e9be1">More...</a><br /></td></tr>
<tr class="separator:a4bdfcbca5e48b3d517b9e450a06e9be1 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e30b916dabbf37f56dd07915e5102f2 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a1e30b916dabbf37f56dd07915e5102f2">empty</a> () const</td></tr>
<tr class="memdesc:a1e30b916dabbf37f56dd07915e5102f2 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty.  <a href="classcds_1_1container_1_1_striped_set.html#a1e30b916dabbf37f56dd07915e5102f2">More...</a><br /></td></tr>
<tr class="separator:a1e30b916dabbf37f56dd07915e5102f2 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57316947488c56167c0a0b39907e90ec inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="a57316947488c56167c0a0b39907e90ec"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a57316947488c56167c0a0b39907e90ec">size</a> () const</td></tr>
<tr class="memdesc:a57316947488c56167c0a0b39907e90ec inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set. <br /></td></tr>
<tr class="separator:a57316947488c56167c0a0b39907e90ec inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e88c75874196bc4a034da5a5ac2806c inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a4e88c75874196bc4a034da5a5ac2806c">bucket_count</a> () const</td></tr>
<tr class="memdesc:a4e88c75874196bc4a034da5a5ac2806c inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of hash table.  <a href="classcds_1_1container_1_1_striped_set.html#a4e88c75874196bc4a034da5a5ac2806c">More...</a><br /></td></tr>
<tr class="separator:a4e88c75874196bc4a034da5a5ac2806c inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40ae86014cc00810a3999531bd90f82 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="ac40ae86014cc00810a3999531bd90f82"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#ac40ae86014cc00810a3999531bd90f82">lock_count</a> () const</td></tr>
<tr class="memdesc:ac40ae86014cc00810a3999531bd90f82 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns lock array size. <br /></td></tr>
<tr class="separator:ac40ae86014cc00810a3999531bd90f82 inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28cf5f431dbb6c75f92ebad633c89c3d inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="a28cf5f431dbb6c75f92ebad633c89c3d"></a>
<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a73e9218d8f7724ddc07c1b41c8d91e7f">resizing_policy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a28cf5f431dbb6c75f92ebad633c89c3d">get_resizing_policy</a> ()</td></tr>
<tr class="memdesc:a28cf5f431dbb6c75f92ebad633c89c3d inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns resizing policy object. <br /></td></tr>
<tr class="separator:a28cf5f431dbb6c75f92ebad633c89c3d inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8b2b351eebfa684f4a039a1aff6dcd inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="a6e8b2b351eebfa684f4a039a1aff6dcd"></a>
<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a73e9218d8f7724ddc07c1b41c8d91e7f">resizing_policy</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a6e8b2b351eebfa684f4a039a1aff6dcd">get_resizing_policy</a> () const</td></tr>
<tr class="memdesc:a6e8b2b351eebfa684f4a039a1aff6dcd inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns resizing policy (const version) <br /></td></tr>
<tr class="separator:a6e8b2b351eebfa684f4a039a1aff6dcd inherit pro_methods_classcds_1_1container_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classcds_1_1intrusive_1_1_striped_set"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classcds_1_1intrusive_1_1_striped_set')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet&lt; Container, Options... &gt;</a></td></tr>
<tr class="memitem:a8c4b97b427950b0b119e6314337611a6 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="a8c4b97b427950b0b119e6314337611a6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a8c4b97b427950b0b119e6314337611a6">StripedSet</a> ()</td></tr>
<tr class="memdesc:a8c4b97b427950b0b119e6314337611a6 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default ctor. The initial capacity is 16. <br /></td></tr>
<tr class="separator:a8c4b97b427950b0b119e6314337611a6 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8ca33aa2ce383440759a0cf0a177e1 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a1a8ca33aa2ce383440759a0cf0a177e1">StripedSet</a> (size_t nCapacity)</td></tr>
<tr class="memdesc:a1a8ca33aa2ce383440759a0cf0a177e1 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with initial capacity specified.  <a href="classcds_1_1intrusive_1_1_striped_set.html#a1a8ca33aa2ce383440759a0cf0a177e1">More...</a><br /></td></tr>
<tr class="separator:a1a8ca33aa2ce383440759a0cf0a177e1 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335e83b344ba93844182d4e1ff1708dc inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a335e83b344ba93844182d4e1ff1708dc">StripedSet</a> (size_t nCapacity, <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a73e9218d8f7724ddc07c1b41c8d91e7f">resizing_policy</a> const &amp;resizingPolicy)</td></tr>
<tr class="memdesc:a335e83b344ba93844182d4e1ff1708dc inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with resizing policy (copy semantics)  <a href="classcds_1_1intrusive_1_1_striped_set.html#a335e83b344ba93844182d4e1ff1708dc">More...</a><br /></td></tr>
<tr class="separator:a335e83b344ba93844182d4e1ff1708dc inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1c130844fc77ceda65e8822f20b478 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a3e1c130844fc77ceda65e8822f20b478">StripedSet</a> (size_t nCapacity, <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a73e9218d8f7724ddc07c1b41c8d91e7f">resizing_policy</a> &amp;&amp;resizingPolicy)</td></tr>
<tr class="memdesc:a3e1c130844fc77ceda65e8822f20b478 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with resizing policy (move semantics)  <a href="classcds_1_1intrusive_1_1_striped_set.html#a3e1c130844fc77ceda65e8822f20b478">More...</a><br /></td></tr>
<tr class="separator:a3e1c130844fc77ceda65e8822f20b478 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723409ba0e656ba3bbd54d41356ec710 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="a723409ba0e656ba3bbd54d41356ec710"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a723409ba0e656ba3bbd54d41356ec710">~StripedSet</a> ()</td></tr>
<tr class="memdesc:a723409ba0e656ba3bbd54d41356ec710 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor destroys internal data. <br /></td></tr>
<tr class="separator:a723409ba0e656ba3bbd54d41356ec710 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9596e3aea5464a77437d6d8cdfc288f5 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a9596e3aea5464a77437d6d8cdfc288f5">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a9596e3aea5464a77437d6d8cdfc288f5 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="classcds_1_1intrusive_1_1_striped_set.html#a9596e3aea5464a77437d6d8cdfc288f5">More...</a><br /></td></tr>
<tr class="separator:a9596e3aea5464a77437d6d8cdfc288f5 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8e96d52afa3d2c265c269af1a1ba3c inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a4e8e96d52afa3d2c265c269af1a1ba3c">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> &amp;val, Func f)</td></tr>
<tr class="memdesc:a4e8e96d52afa3d2c265c269af1a1ba3c inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="classcds_1_1intrusive_1_1_striped_set.html#a4e8e96d52afa3d2c265c269af1a1ba3c">More...</a><br /></td></tr>
<tr class="separator:a4e8e96d52afa3d2c265c269af1a1ba3c inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432eb9fc2f0cf92fcf3a3b22ef6d8510 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a432eb9fc2f0cf92fcf3a3b22ef6d8510">update</a> (<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> &amp;val, Func func, bool bAllowInsert=true)</td></tr>
<tr class="memdesc:a432eb9fc2f0cf92fcf3a3b22ef6d8510 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the node.  <a href="classcds_1_1intrusive_1_1_striped_set.html#a432eb9fc2f0cf92fcf3a3b22ef6d8510">More...</a><br /></td></tr>
<tr class="separator:a432eb9fc2f0cf92fcf3a3b22ef6d8510 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc4dd64160d03646b1f7c163f95369e inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#adbc4dd64160d03646b1f7c163f95369e">unlink</a> (<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:adbc4dd64160d03646b1f7c163f95369e inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink the item <code>val</code> from the set.  <a href="classcds_1_1intrusive_1_1_striped_set.html#adbc4dd64160d03646b1f7c163f95369e">More...</a><br /></td></tr>
<tr class="separator:adbc4dd64160d03646b1f7c163f95369e inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f0b317f12dd1db7b57ac7f9c4c68b2 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a93f0b317f12dd1db7b57ac7f9c4c68b2">erase</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:a93f0b317f12dd1db7b57ac7f9c4c68b2 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="classcds_1_1intrusive_1_1_striped_set.html#a93f0b317f12dd1db7b57ac7f9c4c68b2">More...</a><br /></td></tr>
<tr class="separator:a93f0b317f12dd1db7b57ac7f9c4c68b2 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0800c569994d8548264435b032b1e6 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a4d0800c569994d8548264435b032b1e6">erase</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:a4d0800c569994d8548264435b032b1e6 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="classcds_1_1intrusive_1_1_striped_set.html#a4d0800c569994d8548264435b032b1e6">More...</a><br /></td></tr>
<tr class="separator:a4d0800c569994d8548264435b032b1e6 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f556ecd285484def76ab232f515e2af inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a2f556ecd285484def76ab232f515e2af">erase_with</a> (Q const &amp;val, Less pred)</td></tr>
<tr class="memdesc:a2f556ecd285484def76ab232f515e2af inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="classcds_1_1intrusive_1_1_striped_set.html#a2f556ecd285484def76ab232f515e2af">More...</a><br /></td></tr>
<tr class="separator:a2f556ecd285484def76ab232f515e2af inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae449671e2a1b7bfda93312d17b2a85cd inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#ae449671e2a1b7bfda93312d17b2a85cd">erase_with</a> (Q const &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:ae449671e2a1b7bfda93312d17b2a85cd inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="classcds_1_1intrusive_1_1_striped_set.html#ae449671e2a1b7bfda93312d17b2a85cd">More...</a><br /></td></tr>
<tr class="separator:ae449671e2a1b7bfda93312d17b2a85cd inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54fb6ea73d499f07611f75973244685 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#af54fb6ea73d499f07611f75973244685">find</a> (Q &amp;val, Func f)</td></tr>
<tr class="memdesc:af54fb6ea73d499f07611f75973244685 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="classcds_1_1intrusive_1_1_striped_set.html#af54fb6ea73d499f07611f75973244685">More...</a><br /></td></tr>
<tr class="separator:af54fb6ea73d499f07611f75973244685 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1c82507b338a1f5e835117652f48d2 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a1d1c82507b338a1f5e835117652f48d2">find</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:a1d1c82507b338a1f5e835117652f48d2 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="classcds_1_1intrusive_1_1_striped_set.html#a1d1c82507b338a1f5e835117652f48d2">More...</a><br /></td></tr>
<tr class="separator:a1d1c82507b338a1f5e835117652f48d2 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47d38de7746c0701b794c02d7cc79bd inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#af47d38de7746c0701b794c02d7cc79bd">find_with</a> (Q &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:af47d38de7746c0701b794c02d7cc79bd inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code> using <code>pred</code> predicate.  <a href="classcds_1_1intrusive_1_1_striped_set.html#af47d38de7746c0701b794c02d7cc79bd">More...</a><br /></td></tr>
<tr class="separator:af47d38de7746c0701b794c02d7cc79bd inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4947957c41d99bd6d75ce5b04a975bf5 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a4947957c41d99bd6d75ce5b04a975bf5">find_with</a> (Q const &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:a4947957c41d99bd6d75ce5b04a975bf5 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code> using <code>pred</code> predicate.  <a href="classcds_1_1intrusive_1_1_striped_set.html#a4947957c41d99bd6d75ce5b04a975bf5">More...</a><br /></td></tr>
<tr class="separator:a4947957c41d99bd6d75ce5b04a975bf5 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e681eacb6163d341cacf39607e1471c inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a5e681eacb6163d341cacf39607e1471c">contains</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a5e681eacb6163d341cacf39607e1471c inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>key</code>.  <a href="classcds_1_1intrusive_1_1_striped_set.html#a5e681eacb6163d341cacf39607e1471c">More...</a><br /></td></tr>
<tr class="separator:a5e681eacb6163d341cacf39607e1471c inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec51f0495dce5375e33dbdad5129488 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#aeec51f0495dce5375e33dbdad5129488">contains</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:aeec51f0495dce5375e33dbdad5129488 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>key</code> using <code>pred</code> predicate for searching.  <a href="classcds_1_1intrusive_1_1_striped_set.html#aeec51f0495dce5375e33dbdad5129488">More...</a><br /></td></tr>
<tr class="separator:aeec51f0495dce5375e33dbdad5129488 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5b7ec995eb6c9ab0de511b4848c356 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a8c5b7ec995eb6c9ab0de511b4848c356">clear</a> ()</td></tr>
<tr class="memdesc:a8c5b7ec995eb6c9ab0de511b4848c356 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set.  <a href="classcds_1_1intrusive_1_1_striped_set.html#a8c5b7ec995eb6c9ab0de511b4848c356">More...</a><br /></td></tr>
<tr class="separator:a8c5b7ec995eb6c9ab0de511b4848c356 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922615dc212b034f6946253747c92567 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a922615dc212b034f6946253747c92567">clear_and_dispose</a> (Disposer disposer)</td></tr>
<tr class="memdesc:a922615dc212b034f6946253747c92567 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set and calls <code>disposer</code> for each item.  <a href="classcds_1_1intrusive_1_1_striped_set.html#a922615dc212b034f6946253747c92567">More...</a><br /></td></tr>
<tr class="separator:a922615dc212b034f6946253747c92567 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8b6d36e50fd1acd07479381a33742c inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#aed8b6d36e50fd1acd07479381a33742c">empty</a> () const</td></tr>
<tr class="memdesc:aed8b6d36e50fd1acd07479381a33742c inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty.  <a href="classcds_1_1intrusive_1_1_striped_set.html#aed8b6d36e50fd1acd07479381a33742c">More...</a><br /></td></tr>
<tr class="separator:aed8b6d36e50fd1acd07479381a33742c inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c092c8ee3f7068d59f5f1aed4321a9 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="a49c092c8ee3f7068d59f5f1aed4321a9"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a49c092c8ee3f7068d59f5f1aed4321a9">size</a> () const</td></tr>
<tr class="memdesc:a49c092c8ee3f7068d59f5f1aed4321a9 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set. <br /></td></tr>
<tr class="separator:a49c092c8ee3f7068d59f5f1aed4321a9 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98e2fa3c84dc5f9b370970ce16ba3fe inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#ab98e2fa3c84dc5f9b370970ce16ba3fe">bucket_count</a> () const</td></tr>
<tr class="memdesc:ab98e2fa3c84dc5f9b370970ce16ba3fe inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of hash table.  <a href="classcds_1_1intrusive_1_1_striped_set.html#ab98e2fa3c84dc5f9b370970ce16ba3fe">More...</a><br /></td></tr>
<tr class="separator:ab98e2fa3c84dc5f9b370970ce16ba3fe inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bc8a0b0ff0c96f164d83dcf2e9bbe0 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="a60bc8a0b0ff0c96f164d83dcf2e9bbe0"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a60bc8a0b0ff0c96f164d83dcf2e9bbe0">lock_count</a> () const</td></tr>
<tr class="memdesc:a60bc8a0b0ff0c96f164d83dcf2e9bbe0 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns lock array size. <br /></td></tr>
<tr class="separator:a60bc8a0b0ff0c96f164d83dcf2e9bbe0 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecf47c14957c54d2286e1780ac05191 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="aeecf47c14957c54d2286e1780ac05191"></a>
<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a73e9218d8f7724ddc07c1b41c8d91e7f">resizing_policy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#aeecf47c14957c54d2286e1780ac05191">get_resizing_policy</a> ()</td></tr>
<tr class="memdesc:aeecf47c14957c54d2286e1780ac05191 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns resizing policy object. <br /></td></tr>
<tr class="separator:aeecf47c14957c54d2286e1780ac05191 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a92b73e14341bcf2a68f4f9c3332056 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="a9a92b73e14341bcf2a68f4f9c3332056"></a>
<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a73e9218d8f7724ddc07c1b41c8d91e7f">resizing_policy</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a9a92b73e14341bcf2a68f4f9c3332056">get_resizing_policy</a> () const</td></tr>
<tr class="memdesc:a9a92b73e14341bcf2a68f4f9c3332056 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns resizing policy (const version) <br /></td></tr>
<tr class="separator:a9a92b73e14341bcf2a68f4f9c3332056 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classcds_1_1intrusive_1_1_striped_set')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet&lt; Container, Options... &gt;</a></td></tr>
<tr class="memitem:aa37baad9eed29bf24f0ddf890e0d01e8 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="aa37baad9eed29bf24f0ddf890e0d01e8"></a>
<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#ac0f7511b1b3c53680be6608678020bb5">bucket_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#aa37baad9eed29bf24f0ddf890e0d01e8">m_Buckets</a></td></tr>
<tr class="memdesc:aa37baad9eed29bf24f0ddf890e0d01e8 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bucket table. <br /></td></tr>
<tr class="separator:aa37baad9eed29bf24f0ddf890e0d01e8 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce4bd75c1b37fc12b1d5ea2ae0da65e inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="a1ce4bd75c1b37fc12b1d5ea2ae0da65e"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a1ce4bd75c1b37fc12b1d5ea2ae0da65e">m_nBucketMask</a></td></tr>
<tr class="memdesc:a1ce4bd75c1b37fc12b1d5ea2ae0da65e inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bucket table size - 1. m_nBucketMask + 1 should be power of two. <br /></td></tr>
<tr class="separator:a1ce4bd75c1b37fc12b1d5ea2ae0da65e inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1657b63e8f07fd22c313304f2d3ca0c5 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="a1657b63e8f07fd22c313304f2d3ca0c5"></a>
<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#abc27916ad8566742257adde4f5b0d36c">item_counter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a1657b63e8f07fd22c313304f2d3ca0c5">m_ItemCounter</a></td></tr>
<tr class="memdesc:a1657b63e8f07fd22c313304f2d3ca0c5 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter. <br /></td></tr>
<tr class="separator:a1657b63e8f07fd22c313304f2d3ca0c5 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b44bfb69b63d39d2a966b416736716 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="a13b44bfb69b63d39d2a966b416736716"></a>
<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a3b11af7149d2edcdcf89875dd82f29c3">hash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a13b44bfb69b63d39d2a966b416736716">m_Hash</a></td></tr>
<tr class="memdesc:a13b44bfb69b63d39d2a966b416736716 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor. <br /></td></tr>
<tr class="separator:a13b44bfb69b63d39d2a966b416736716 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104ff1225ca65268f90dd235698e6f36 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="a104ff1225ca65268f90dd235698e6f36"></a>
<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#af672d590a91e09833aa27621f7e35c26">mutex_policy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a104ff1225ca65268f90dd235698e6f36">m_MutexPolicy</a></td></tr>
<tr class="memdesc:a104ff1225ca65268f90dd235698e6f36 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex policy. <br /></td></tr>
<tr class="separator:a104ff1225ca65268f90dd235698e6f36 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a40adaba75040b3646fab1ad4bc133 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="ab6a40adaba75040b3646fab1ad4bc133"></a>
<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a73e9218d8f7724ddc07c1b41c8d91e7f">resizing_policy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#ab6a40adaba75040b3646fab1ad4bc133">m_ResizingPolicy</a></td></tr>
<tr class="memdesc:ab6a40adaba75040b3646fab1ad4bc133 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizing policy. <br /></td></tr>
<tr class="separator:ab6a40adaba75040b3646fab1ad4bc133 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classcds_1_1intrusive_1_1_striped_set"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classcds_1_1intrusive_1_1_striped_set')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet&lt; Container, Options... &gt;</a></td></tr>
<tr class="memitem:acd3aab8a3065331de1f6ad410fa94d7f inherit pro_static_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a id="acd3aab8a3065331de1f6ad410fa94d7f"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#acd3aab8a3065331de1f6ad410fa94d7f">c_nMinimalCapacity</a></td></tr>
<tr class="memdesc:acd3aab8a3065331de1f6ad410fa94d7f inherit pro_static_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimal capacity. <br /></td></tr>
<tr class="separator:acd3aab8a3065331de1f6ad410fa94d7f inherit pro_static_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Container, typename... Options&gt;<br />
class cds::container::StripedMap&lt; Container, Options &gt;</h3>

<p>Striped hash map. </p>
<p>Source</p><ul>
<li>[2008] Maurice Herlihy, Nir Shavit "The Art of Multiprocessor Programming"</li>
</ul>
<p>Lock striping is very simple technique. The map consists of the bucket table and the array of locks. Initially, the capacity of lock array and bucket table is the same. When the map is resized, bucket table capacity will be doubled but lock array will not. The lock <code>i</code> protects each bucket <code>j</code>, where <code> j = i mod L </code>, where <code>L</code> - the size of lock array.</p>
<p>Template arguments:</p><ul>
<li><code>Container</code> - the container class that is used as bucket entry. The <code>Container</code> class should support an uniform interface described below.</li>
<li><code>Options</code> - options</li>
</ul>
<p>The <code>StripedMap</code> class does not exactly specify the type of container that should be used as a <code>Container</code> bucket. Instead, the class supports different container type for the bucket, for exampe, <code>std::list</code>, <code>std::map</code> and others.</p>
<p>Remember that <code>StripedMap</code> class algorithm ensures sequential blocking access to its bucket through the mutex type you specify among <code>Options</code> template arguments.</p>
<p>The <code>Options</code> are:</p><ul>
<li><code><a class="el" href="structcds_1_1opt_1_1mutex__policy.html" title="[type-option] Concurrent access policy ">cds::opt::mutex_policy</a></code> - concurrent access policy. Available policies: <code><a class="el" href="namespacecds_1_1container_1_1striped__set.html#a1883d4c26751fcc9d42afba2f00e3742" title="Lock striping concurrent access policy. ">striped_set::striping</a></code>, <code><a class="el" href="namespacecds_1_1container_1_1striped__set.html#a7addadcc56127b3e1cf5f25a64e9c821" title="Refinable concurrent access policy. ">striped_set::refinable</a></code>. Default is <code>striped_set::striping</code>.</li>
<li><code><a class="el" href="structcds_1_1opt_1_1hash.html" title="[type-option] Option setter for a hash function ">cds::opt::hash</a></code> - hash functor. Default option value see <code>opt::v::hash_selector&lt;opt::none&gt; </code> which selects default hash functor for your compiler.</li>
<li><code><a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">cds::opt::compare</a></code> - key comparison functor. No default functor is provided. If the option is not specified, the <code>opt::less</code> is used.</li>
<li><code><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">cds::opt::less</a></code> - specifies binary predicate used for key comparison. Default is <code>std::less&lt;T&gt;</code>.</li>
<li><code><a class="el" href="structcds_1_1opt_1_1item__counter.html" title="[type-option] Option setter for item counting ">cds::opt::item_counter</a></code> - item counter type. Default is <code><a class="el" href="classcds_1_1atomicity_1_1item__counter.html" title="Atomic item counter. ">atomicity::item_counter</a></code> since some operation on the counter is performed without locks. Note that item counting is an essential part of the map algorithm, so dummy counter like as <code><a class="el" href="classcds_1_1atomicity_1_1empty__item__counter.html" title="Empty item counter. ">atomicity::empty_item_counter</a></code> is not suitable.</li>
<li><code><a class="el" href="structcds_1_1opt_1_1allocator.html" title="[type-option] Option setter for an allocator ">cds::opt::allocator</a></code> - the allocator type using for memory allocation of bucket table and lock array. Default is <a class="el" href="user__setup_2allocator_8h.html#ad5fb7e3cbe8cf24295f0ea3c165a2d82">CDS_DEFAULT_ALLOCATOR</a>.</li>
<li><code><a class="el" href="structcds_1_1opt_1_1resizing__policy.html" title="Resizing policy option. ">cds::opt::resizing_policy</a></code> - the resizing policy that is a functor that decides when to resize the hash map. Default option value depends on bucket container type: for sequential containers like <code>std::list</code>, <code>std::vector</code> the resizing policy is <code><a class="el" href="namespacecds_1_1container_1_1striped__set.html#a0a7761cda5122caa1ea5f22ac7182e65" title="Load factor based resizing policy. ">striped_set::load_factor_resizing&lt;4&gt;</a> </code>; for other type of containers like <code>std::map</code>, <code>std::unordered_map</code> the resizing policy is <code><a class="el" href="namespacecds_1_1container_1_1striped__set.html#a1a6926eacdbf9fb4fc264d6d85d353c2" title="Dummy resizing policy. ">striped_set::no_resizing</a></code>. See <a class="el" href="group__cds__striped__resizing__policy.html">available resizing policy</a>. Note that the choose of resizing policy depends of <code>Container</code> type: for sequential containers like <code>std::list</code>, <code>std::vector</code> and so on, right choosing of the policy can significantly improve performance. For other, non-sequential types of <code>Container</code> (like a <code>std::map</code>) the resizing policy is not so important.</li>
<li><code><a class="el" href="structcds_1_1opt_1_1copy__policy.html" title="Copy policy option. ">cds::opt::copy_policy</a></code> - the copy policy which is used to copy items from the old map to the new one when resizing. The policy can be optionally used in adapted bucket container for performance reasons of resizing. The detail of copy algorithm depends on type of bucket container and explains below.</li>
</ul>
<p><code>opt::compare</code> or <code>opt::less</code> options are used only in some <code>Container</code> class for searching an item. <code>opt::compare</code> option has the highest priority: if <code>opt::compare</code> is specified, <code>opt::less</code> is not used.</p>
<p>You can pass other option that would be passed to <code>adapt</code> metafunction, see below.</p>
<p><b>Internal details</b></p>
<p>The <code>StripedMap</code> class cannot utilize the <code>Container</code> container specified directly, but only its adapted variant which supports an unified interface. Internally, the adaptation is made via <code><a class="el" href="classcds_1_1container_1_1striped__set_1_1adapt.html" title="Default adapter for hash set. ">striped_set::adapt</a></code> metafunction that wraps bucket container and provides the unified bucket interface suitable for <code>StripedMap</code>. Such adaptation is completely transparent for you - you don't need to call <code>adapt</code> metafunction directly, <code>StripedMap</code> class's internal machinery itself invokes appropriate <code>adapt</code> metafunction to adjust your <code>Container</code> container class to <code>StripedMap</code> bucket's internal interface. All you need is to include a right header before <code>striped_hash_map.h</code>.</p>
<p>By default, <code>striped_set::adapt&lt;AnyContainer, Options...&gt; </code> metafunction does not make any wrapping to <code>AnyContainer</code>, so, the result <code><a class="el" href="classcds_1_1container_1_1striped__set_1_1adapt.html#a23593acb49868d12286d076f61cd45cf" title="adapted container type ">striped_set::adapt&lt;AnyContainer, Options...&gt;::type</a> </code> is the same as <code>AnyContainer</code>. However, there are a lot of specializations of <code>adapt</code> for well-known containers, see table below. Any of this specialization wraps corresponding container making it suitable for the map's bucket. Remember, you should include the proper header file for <code>adapt</code> <b>before</b> <code>striped_map.h</code>. </p><table class="doxtable">
<tr>
<th>Container </th><th>.h-file for <code>adapt</code>  </th><th>Example </th><th>Notes  </th></tr>
<tr>
<td><code>std::list</code>  </td><td><code>&lt;cds/container/striped_map/std_list.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_map/std_list.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_hash_map.h&gt;</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt;</div><div class="line">    std::list&lt; std::pair&lt; const Key, V &gt; &gt;,</div><div class="line">    <a class="code" href="structcds_1_1opt_1_1less.html">cds::opt::less&lt; std::less&lt;Key&gt;</a> &gt;</div><div class="line">&gt; striped_map;</div></div><!-- fragment -->  </td><td>The type of values stored in the <code>std::list</code> must be <code> std::pair&lt; const Key, V &gt; </code>, where <code>Key</code> - key type, and <code>V</code> - value type The list is ordered by key <code>Key</code>. Template argument pack <code>Options</code> <b>must</b> contain <code><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">cds::opt::less</a></code> or <code><a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">cds::opt::compare</a></code> for type <code>Key</code> stored in the list.   </td></tr>
<tr>
<td><code>std::map</code>  </td><td><code>&lt;cds/container/striped_map/std_map.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_map/std_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_hash_map.h&gt;</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt;</div><div class="line">    std::map&lt; Key, T, std::less&lt;Key&gt; &gt;</div><div class="line">&gt; striped_map;</div></div><!-- fragment -->  </td><td></td></tr>
<tr>
<td><code>std::unordered_map</code>  </td><td><code>&lt;cds/container/striped_map/std_hash_map.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_map/std_hash_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_hash_map.h&gt;</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt;</div><div class="line">    std::unordered_map&lt;</div><div class="line">        Key, T,</div><div class="line">        std::hash&lt;Key&gt;,</div><div class="line">        std::equal_to&lt;Key&gt;</div><div class="line">    &gt;</div><div class="line">&gt; striped_map;</div></div><!-- fragment -->  </td><td>You should provide two different hash function <code>h1</code> and <code>h2</code> - one for std::unordered_map and other for <code>StripedMap</code>. For the best result, <code>h1</code> and <code>h2</code> must be orthogonal i.e. <code> h1(X) != h2(X) </code> for any value <code>X</code> of type <code>Key</code>.   </td></tr>
<tr>
<td><code>boost::container::slist</code>  </td><td><code>&lt;cds/container/striped_map/boost_slist.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/hash_smap/boost_slist.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_hash_map.h&gt;</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt;</div><div class="line">    boost::container::slist&lt; std::pair&lt; const Key, T &gt; &gt;</div><div class="line">&gt; striped_map;</div></div><!-- fragment -->  </td><td>The type of values stored in the <code>boost::container::slist</code> must be <code> std::pair&lt; const Key, T &gt; </code>, where <code>Key</code> - key type, and <code>T</code> - value type. The list is ordered. <code>Options</code> <b>must</b> contain <code><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">cds::opt::less</a></code> or <code><a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">cds::opt::compare</a></code>.   </td></tr>
<tr>
<td><code>boost::container::list</code>  </td><td><code>&lt;cds/container/striped_map/boost_list.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_map/boost_list.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_hash_map.h&gt;</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt;</div><div class="line">    boost::container::list&lt; std::pair&lt; const Key, T &gt; &gt;</div><div class="line">&gt; striped_map;</div></div><!-- fragment -->  </td><td>The type of values stored in the <code>boost::container::list</code> must be <code> std::pair&lt; const Key, T &gt; </code>, where <code>Key</code> - key type, and <code>T</code> - value type. The list is ordered. <code>Options</code> <b>must</b> contain <code><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">cds::opt::less</a></code> or <code><a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">cds::opt::compare</a></code>.   </td></tr>
<tr>
<td><code>boost::container::map</code>  </td><td><code>&lt;cds/container/striped_map/boost_map.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_map/boost_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_hash_map.h&gt;</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt;</div><div class="line">    boost::container::map&lt; Key, T, std::less&lt;Key&gt; &gt;</div><div class="line">&gt; striped_map;</div></div><!-- fragment -->  </td><td></td></tr>
<tr>
<td><code>boost::container::flat_map</code>  </td><td><code>&lt;cds/container/striped_map/boost_flat_map.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_map/boost_flat_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_hash_map.h&gt;</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt;</div><div class="line">    boost::container::flat_map&lt; Key, T,</div><div class="line">        std::less&lt; std::less&lt;Key&gt; &gt;</div><div class="line">    &gt;</div><div class="line">&gt; striped_map;</div></div><!-- fragment -->  </td><td></td></tr>
<tr>
<td><code>boost::unordered_map</code>  </td><td><code>&lt;cds/container/striped_map/boost_unordered_map.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_map/boost_unordered_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cds/container/refinable_hash_map.h&gt;</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt;</div><div class="line">    boost::unordered_map&lt; Key, T, boost::hash&lt;Key&gt;, std::equal_to&lt;Key&gt; &gt;</div><div class="line">&gt; refinable_map;</div></div><!-- fragment -->  </td><td></td></tr>
</table>
<p>You can use another container type as map's bucket. Suppose, you have a container class <code>MyBestContainer</code> and you want to integrate it with <code>StripedMap</code> as bucket type. There are two possibility:</p><ul>
<li>either your <code>MyBestContainer</code> class has native support of bucket's interface; in this case, you can use default <code><a class="el" href="classcds_1_1container_1_1striped__set_1_1adapt.html" title="Default adapter for hash set. ">striped_set::adapt</a></code> metafunction;</li>
<li>or your <code>MyBestContainer</code> class does not support bucket's interface; it means you should develop a specialization <code>cds::container::striped_set::adapt&lt;MyBestContainer&gt; </code> metafunction providing necessary interface.</li>
</ul>
<p>The <code>striped_set::adapt&lt; Container, Options... &gt;</code> metafunction has two template argument:</p><ul>
<li><code>Container</code> is the class that should be used as the bucket, for example, <code>std::list&lt; std::pair&lt; Key, T &gt; &gt;</code>.</li>
<li><code>Options</code> pack is the options from <code>StripedMap</code> declaration. The <code>adapt</code> metafunction can use any option from <code>Options</code> for its internal use. For example, a <code>compare</code> option can be passed to <code>adapt</code> metafunction via <code>Options</code> argument of <code>StripedMap</code> declaration.</li>
</ul>
<p>See <code><a class="el" href="classcds_1_1container_1_1striped__set_1_1adapt.html" title="Default adapter for hash set. ">striped_set::adapt</a></code> metafunction for the description of interface that the bucket container must provide to be <code>StripedMap</code> compatible.</p>
<p><b>Copy policy</b> There are three predefined copy policy:</p><ul>
<li><code>cds::container::striped_set::copy_item</code> - copy item from old bucket to new one when resizing using copy ctor. It is default policy for any compiler that do not support move semantics</li>
<li><code>cds::container::striped_set::move_item</code> - move item from old bucket to new one when resizing using move semantics. It is default policy for any compiler that support move semantics. If compiler does not support move semantics, the move policy is the same as <code>copy_item</code> </li>
<li><code>cds::container::striped_set::swap_item</code> - copy item from old bucket to new one when resizing using <code>std::swap</code>. Not all containers support this copy policy, see details in table below.</li>
</ul>
<p>You can define your own copy policy specifically for your case. Note, right copy policy can significantly improve the performance of resizing.</p>
<table class="doxtable">
<tr>
<th>Container </th><th>Policies  </th></tr>
<tr>
<td><ul>
<li><code>std::list</code> </li>
<li><code>boost::list</code>  </li>
</ul>
</td><td><div class="fragment"><div class="line"><span class="keyword">struct </span>copy_item {</div><div class="line">    <span class="keywordtype">void</span> operator()(</div><div class="line">        std::list&lt; std::pair&lt;const Key, T&gt; &gt;&amp; list,</div><div class="line">        std::list&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itInsert,</div><div class="line">        std::list&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itWhat )</div><div class="line">    {</div><div class="line">        list.insert( itInsert, *itWhat );</div><div class="line">    }</div><div class="line">} </div></div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// The type T stored in the list must be swappable</span></div><div class="line"><span class="keyword">struct </span>swap_item {</div><div class="line">    <span class="keywordtype">void</span> operator()(</div><div class="line">        std::list&lt; std::pair&lt;const Key, T&gt; &gt;&amp; list,</div><div class="line">        std::list&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itInsert,</div><div class="line">        std::list&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itWhat )</div><div class="line">    {</div><div class="line">        std::pair&lt;Key, T&gt; newVal( itWhat-&gt;first, T());</div><div class="line">        std::swap( list.insert( itInsert, newVal )-&gt;second, itWhat-&gt;second );</div><div class="line">    }</div><div class="line">} </div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">struct </span>move_item {</div><div class="line">    <span class="keywordtype">void</span> operator()(</div><div class="line">        std::list&lt; std::pair&lt;const Key, T&gt; &gt;&amp; list,</div><div class="line">        std::list&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itInsert,</div><div class="line">        std::list&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itWhat )</div><div class="line">    {</div><div class="line">        list.insert( itInsert, std::move( *itWhat ));</div><div class="line">    }</div><div class="line">} </div></div><!-- fragment -->   </td></tr>
<tr>
<td><ul>
<li><code>std::map</code> </li>
<li><code>std::unordered_map</code> </li>
<li><code>boost::container::map</code> </li>
<li><code>boost::container::flat_map</code> </li>
<li><code>boost::unordered_map</code>  </li>
</ul>
</td><td><div class="fragment"><div class="line"><span class="keyword">struct </span>copy_item {</div><div class="line">    <span class="keywordtype">void</span> operator()( std::map&lt; Key, T&gt;&amp; map, std::map&lt;Key, T&gt;::iterator itWhat )</div><div class="line">    {</div><div class="line">        map.insert( *itWhat );</div><div class="line">    }</div><div class="line">} </div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">struct </span>swap_item {</div><div class="line">    <span class="keywordtype">void</span> operator()( std::map&lt; Key, T&gt;&amp; map, std::map&lt;Key, T&gt;::iterator itWhat )</div><div class="line">    {</div><div class="line">        std::swap(</div><div class="line">            map.insert(</div><div class="line">                std::map::value_type( itWhat-&gt;first, T())).first-&gt;second</div><div class="line">                , itWhat-&gt;second</div><div class="line">        ));</div><div class="line">    }</div><div class="line">} </div></div><!-- fragment --><p> <code>T</code> type must be swappable.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>move_item {</div><div class="line">    <span class="keywordtype">void</span> operator()( std::map&lt; Key, T&gt;&amp; map, std::map&lt;Key, T&gt;::iterator itWhat )</div><div class="line">    {</div><div class="line">        map.insert( std::move( *itWhat ));</div><div class="line">    }</div><div class="line">} </div></div><!-- fragment -->  </td></tr>
<tr>
<td><code>boost::container::slist</code>  </td><td><div class="fragment"><div class="line"><span class="keyword">struct </span>copy_item {</div><div class="line">    <span class="keywordtype">void</span> operator()(</div><div class="line">        bc::slist&lt; std::pair&lt;const Key, T&gt; &gt;&amp; list,</div><div class="line">        bc::slist&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itInsert,</div><div class="line">        bc::slist&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itWhat )</div><div class="line">    {</div><div class="line">        list.insert_after( itInsert, *itWhat );</div><div class="line">    }</div><div class="line">} </div></div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// The type T stored in the list must be swappable</span></div><div class="line"><span class="keyword">struct </span>swap_item {</div><div class="line">    <span class="keywordtype">void</span> operator()(</div><div class="line">        bc::slist&lt; std::pair&lt;const Key, T&gt; &gt;&amp; list,</div><div class="line">        bc::slist&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itInsert,</div><div class="line">        bc::slist&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itWhat )</div><div class="line">    {</div><div class="line">        std::pair&lt;Key, T&gt; newVal( itWhat-&gt;first, T());</div><div class="line">        std::swap( list.insert( itInsert, newVal )-&gt;second, itWhat-&gt;second );</div><div class="line">    }</div><div class="line">} </div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">struct </span>move_item {</div><div class="line">    <span class="keywordtype">void</span> operator()(</div><div class="line">        bc::slist&lt; std::pair&lt;const Key, T&gt; &gt;&amp; list,</div><div class="line">        bc::slist&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itInsert,</div><div class="line">        bc::slist&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itWhat )</div><div class="line">    {</div><div class="line">        list.insert_after( itInsert, std::move( *itWhat ));</div><div class="line">    }</div><div class="line">} </div></div><!-- fragment -->   </td></tr>
</table>
<p><b>Advanced functions</b></p>
<p>The library provides some advanced functions like <code><a class="el" href="classcds_1_1container_1_1_striped_map.html#a0f28cdf88f10e2fcc0910e00c9854f4e" title="Deletes the item from the map using pred predicate for searching. ">erase_with()</a></code>, <code><a class="el" href="classcds_1_1container_1_1_striped_map.html#aa1353dfa60543a01fc0092733129a4fd" title="Find the key val using pred predicate. ">find_with()</a></code>, that cannot be supported by all underlying containers. The table below shows whether underlying container supports those functions (the sign "+" means "container supports the function"):</p>
<table class="doxtable">
<tr>
<th>Container </th><th><code>find_with</code>  </th><th><code>erse_with</code>   </th></tr>
<tr>
<td><code>std::list</code>  </td><td>+ </td><td>+  </td></tr>
<tr>
<td><code>std::map</code>  </td><td>- </td><td>-  </td></tr>
<tr>
<td><code>std::unordered_map</code>  </td><td>- </td><td>-  </td></tr>
<tr>
<td><code>boost::container::slist</code>  </td><td>+ </td><td>+  </td></tr>
<tr>
<td><code>boost::container::list</code>  </td><td>+ </td><td>+  </td></tr>
<tr>
<td><code>boost::container::map</code>  </td><td>- </td><td>-  </td></tr>
<tr>
<td><code>boost::container::flat_map</code>  </td><td>- </td><td>-  </td></tr>
<tr>
<td><code>boost::unordered_map</code>  </td><td>- </td><td>-  </td></tr>
</table>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a892bd935c22aad68b394f3faa67ce8ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892bd935c22aad68b394f3faa67ce8ec">&sect;&nbsp;</a></span>StripedMap() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::<a class="el" href="classcds_1_1container_1_1_striped_map.html">StripedMap</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nCapacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ctor with initial capacity specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nCapacity</td><td>Initial size of bucket table and lock array. Must be power of two, the minimum is 16. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1c828a31c862660ff8b6ae35e89e8d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c828a31c862660ff8b6ae35e89e8d0">&sect;&nbsp;</a></span>StripedMap() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::<a class="el" href="classcds_1_1container_1_1_striped_map.html">StripedMap</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a3155c54ac7cc35f2ab627ce6eb7333e3">resizing_policy</a> const &amp;&#160;</td>
          <td class="paramname"><em>resizingPolicy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ctor with resizing policy (copy semantics) </p>
<p>This constructor initializes m_ResizingPolicy member with copy of <code>resizingPolicy</code> parameter </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nCapacity</td><td>Initial size of bucket table and lock array. Must be power of two, the minimum is 16. </td></tr>
    <tr><td class="paramname">resizingPolicy</td><td>Resizing policy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad331b6324ae414f56df0324d3435a54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad331b6324ae414f56df0324d3435a54f">&sect;&nbsp;</a></span>StripedMap() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::<a class="el" href="classcds_1_1container_1_1_striped_map.html">StripedMap</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_striped_map.html#a3155c54ac7cc35f2ab627ce6eb7333e3">resizing_policy</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>resizingPolicy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ctor with resizing policy (move semantics) </p>
<p>This constructor initializes m_ResizingPolicy member moving <code>resizingPolicy</code> parameter Move semantics is used. Available only for the compilers that supports C++11 rvalue reference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nCapacity</td><td>Initial size of bucket table and lock array. Must be power of two, the minimum is 16. </td></tr>
    <tr><td class="paramname">resizingPolicy</td><td>Resizing policy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a856f6f7aa7bbeffd0e447c1fee9e3d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856f6f7aa7bbeffd0e447c1fee9e3d4a">&sect;&nbsp;</a></span>bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of hash table. </p>
<p>The hash table size is non-constant and can be increased via resizing. </p>

</div>
</div>
<a id="a00b5e87952d9a31cb50707f71dfaef61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b5e87952d9a31cb50707f71dfaef61">&sect;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the map contains <code>key</code>. </p>
<p>The function searches the item with key equal to <code>key</code> and returns <code>true</code> if it is found, and <code>false</code> otherwise. </p>

</div>
</div>
<a id="a9d217945377cb14045e40c4ea862aafd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d217945377cb14045e40c4ea862aafd">&sect;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less , typename Bucket  = bucket_type, typename  = typename std::enable_if&lt; Bucket::has_find_with &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the set contains <code>key</code> using <code>pred</code> predicate for searching. </p>
<p>The function is similar to <code>contains( key )</code> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set.</p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled if the compiler supports C++11 default template arguments for function template <b>and</b> the underlying container supports <code>contains</code>() feature. </dd></dl>

</div>
</div>
<a id="ab1377e67bb7bf2b40ace6d8bb9f3f3da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1377e67bb7bf2b40ace6d8bb9f3f3da">&sect;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For key <code>key</code> inserts data of type <code>mapped_type</code> created in-place from <code>args</code>. </p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise. </p>

</div>
</div>
<a id="ac1e02f63d146c37c574d3432f84d1ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e02f63d146c37c574d3432f84d1ba9">&sect;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the map is empty. </p>
<p>Emptiness is checked by item counting: if item count is zero then the map is empty. </p>

</div>
</div>
<a id="abf4f29d2c1f58e1f92759f3fad808bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4f29d2c1f58e1f92759f3fad808bb3">&sect;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the map. </p>
<p><a class="anchor" id="cds_nonintrusive_StripedMap_erase"></a> Return <code>true</code> if <code>key</code> is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a id="a213858e29c6865981935d07665804048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213858e29c6865981935d07665804048">&sect;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the map. </p>
<p><a class="anchor" id="cds_nonintrusive_StripedMap_erase_func"></a> The function searches an item with key <code>key</code>, calls <code>f</code> functor and deletes the item. If <code>key</code> is not found, the functor is not called.</p>
<p>The functor <code>Func</code> interface: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>extractor {</div><div class="line">    <span class="keywordtype">void</span> operator()(<a class="code" href="classcds_1_1container_1_1_striped_map.html#abc37b83c74cd041b958aba25ff3ea079">value_type</a>&amp; item) { ... }</div><div class="line">};</div></div><!-- fragment --><p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a id="a0f28cdf88f10e2fcc0910e00c9854f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f28cdf88f10e2fcc0910e00c9854f4e">&sect;&nbsp;</a></span>erase_with() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less , typename Bucket  = bucket_type, typename  = typename std::enable_if&lt; Bucket::has_erase_with &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the map using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_striped_map.html#cds_nonintrusive_StripedMap_erase">erase(K const&amp;)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the map.</p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled if the compiler supports C++11 default template arguments for function template <b>and</b> the underlying container supports <code>erase_with</code> feature. </dd></dl>

</div>
</div>
<a id="af7ebc1913a673717786c8f7598b9237b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ebc1913a673717786c8f7598b9237b">&sect;&nbsp;</a></span>erase_with() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less , typename Func , typename Bucket  = bucket_type, typename  = typename std::enable_if&lt; Bucket::has_erase_with &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the map using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_striped_map.html#cds_nonintrusive_StripedMap_erase_func">erase(K const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the map.</p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled if the compiler supports C++11 default template arguments for function template <b>and</b> the underlying container supports <code>erase_with</code> feature. </dd></dl>

</div>
</div>
<a id="a7cc91ff823125ec02014aab0911083f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc91ff823125ec02014aab0911083f5">&sect;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::find </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>key</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_StripedMap_find_func"></a> The function searches the item with key equal to <code>key</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div><div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_striped_map.html#abc37b83c74cd041b958aba25ff3ea079">value_type</a>&amp; item );</div><div class="line">};</div></div><!-- fragment --><p> where <code>item</code> is the item found.</p>
<p>The functor may change <code>item.second</code>.</p>
<p>The function returns <code>true</code> if <code>key</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a id="aa1353dfa60543a01fc0092733129a4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1353dfa60543a01fc0092733129a4fd">&sect;&nbsp;</a></span>find_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less , typename Func , typename Bucket  = bucket_type, typename  = typename std::enable_if&lt; Bucket::has_find_with &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code> using <code>pred</code> predicate. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_striped_map.html#cds_nonintrusive_StripedMap_find_func">find(K const&amp;, Func)</a> but <code>pred</code> is used for key comparing <code>Less</code> has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the set.</p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled if the compiler supports C++11 default template arguments for function template <b>and</b> the underlying container supports <code>find_with</code> feature. </dd></dl>

</div>
</div>
<a id="a8306ce18508455e5a4761f8a051f6c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8306ce18508455e5a4761f8a051f6c16">&sect;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node with key and default value. </p>
<p>The function creates a node with <code>key</code> and default value, and then inserts the node created into the map.</p>
<p>Preconditions:</p><ul>
<li>The <code>key_type</code> should be constructible from a value of type <code>K</code>. In trivial case, <code>K</code> is equal to <code>key_type</code>.</li>
<li>The <code>mapped_type</code> should be default-constructible.</li>
</ul>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise. </p>

</div>
</div>
<a id="a5543dba6bc798cb924b41de9f98cfedf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5543dba6bc798cb924b41de9f98cfedf">&sect;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function creates a node with copy of <code>val</code> value and then inserts the node created into the map.</p>
<p>Preconditions:</p><ul>
<li>The <code>key_type</code> should be constructible from <code>key</code> of type <code>K</code>.</li>
<li>The <code>mapped_type</code> should be constructible from <code>val</code> of type <code>V</code>.</li>
</ul>
<p>Returns <code>true</code> if <code>val</code> is inserted into the set, <code>false</code> otherwise. </p>

</div>
</div>
<a id="abd563bbd37f3b08f2763c3cff9abaf49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd563bbd37f3b08f2763c3cff9abaf49">&sect;&nbsp;</a></span>insert_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::insert_with </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node and initialize it by a functor. </p>
<p>This function inserts new node with key <code>key</code> and if inserting is successful then it calls <code>func</code> functor with signature </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div><div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_striped_map.html#abc37b83c74cd041b958aba25ff3ea079">value_type</a>&amp; item );</div><div class="line">};</div></div><!-- fragment --><p>The argument <code>item</code> of user-defined functor <code>func</code> is the reference to the map's item inserted:</p><ul>
<li><code>item.first</code> is a const reference to item's key that cannot be changed.</li>
<li><code>item.second</code> is a reference to item's value that may be changed.</li>
</ul>
<p>The key_type should be constructible from value of type <code>K</code>.</p>
<p>The function allows to split creating of new item into two part:</p><ul>
<li>create item from <code>key</code>;</li>
<li>insert new item into the map;</li>
<li>if inserting is successful, initialize the value of item by calling <code>func</code> functor</li>
</ul>
<p>This can be useful if complete initialization of object of <code>mapped_type</code> is heavyweight and it is preferable that the initialization should be completed only if inserting is successful. </p>

</div>
</div>
<a id="a82a5fb6f0e6a0723b22e70520147407c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a5fb6f0e6a0723b22e70520147407c">&sect;&nbsp;</a></span>lock_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::lock_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns lock array size. </p>
<p>The lock array size is constant. </p>

</div>
</div>
<a id="a7b091820cf0277af86e4b214e7eb74a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b091820cf0277af86e4b214e7eb74a6">&sect;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::update </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowInsert</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the node. </p>
<p>The operation performs inserting or changing data with lock-free manner.</p>
<p>If <code>key</code> is not found in the map, then <code>key</code> is inserted iff <code>bAllowInsert</code> is <code>true</code>. Otherwise, the functor <code>func</code> is called with item found.</p>
<p>The functor signature is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>my_functor {</div><div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_striped_map.html#abc37b83c74cd041b958aba25ff3ea079">value_type</a>&amp; item );</div><div class="line">};</div></div><!-- fragment --><p> with arguments:</p><ul>
<li><code>bNew</code> - <code>true</code> if the item has been inserted, <code>false</code> otherwise</li>
<li><code>item</code> - item of the map</li>
</ul>
<p>Returns <code> std::pair&lt;bool, bool&gt; </code> where <code>first</code> is true if operation is successful, <code>second</code> is true if new item has been added or <code>false</code> if the item with <code>key</code> already is in the map. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/container/striped_map.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.2.0</b> 
  Developed by <i>Maxim Khizhinsky aka khizmax</i> 2007 - 2017
  <br/>
  <i>Autogenerated Wed Jan 4 2017 08:49:43 by Doxygen 1.8.12</i>
</div>
</body>
</html>
