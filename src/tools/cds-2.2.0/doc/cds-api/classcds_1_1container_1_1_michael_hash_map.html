<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cds: cds::container::MichaelHashMap&lt; GC, OrderedList, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcds_1_1container_1_1_michael_hash_map.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::MichaelHashMap&lt; GC, OrderedList, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__nonintrusive__containers.html">Non-intrusive containers</a> &raquo; <a class="el" href="group__cds__nonintrusive__map.html">Map</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Michael's hash map.  
 <a href="classcds_1_1container_1_1_michael_hash_map.html#details">More...</a></p>

<p><code>#include &lt;cds/container/michael_map.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa372ab7a6e082dd3bb697a126402dc3b"><td class="memItemLeft" align="right" valign="top"><a id="aa372ab7a6e082dd3bb697a126402dc3b"></a>
typedef GC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#aa372ab7a6e082dd3bb697a126402dc3b">gc</a></td></tr>
<tr class="memdesc:aa372ab7a6e082dd3bb697a126402dc3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br /></td></tr>
<tr class="separator:aa372ab7a6e082dd3bb697a126402dc3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1603b0adcbe59222700c4715a8e53500"><td class="memItemLeft" align="right" valign="top"><a id="a1603b0adcbe59222700c4715a8e53500"></a>
typedef OrderedList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a1603b0adcbe59222700c4715a8e53500">ordered_list</a></td></tr>
<tr class="memdesc:a1603b0adcbe59222700c4715a8e53500"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of ordered list to be used as a bucket <br /></td></tr>
<tr class="separator:a1603b0adcbe59222700c4715a8e53500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad49a20467f0e216bc0bcc20113e490"><td class="memItemLeft" align="right" valign="top"><a id="a9ad49a20467f0e216bc0bcc20113e490"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a9ad49a20467f0e216bc0bcc20113e490">traits</a></td></tr>
<tr class="memdesc:a9ad49a20467f0e216bc0bcc20113e490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map traits. <br /></td></tr>
<tr class="separator:a9ad49a20467f0e216bc0bcc20113e490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ecea3df71f9893b4d9d1615e7863f2"><td class="memItemLeft" align="right" valign="top"><a id="a61ecea3df71f9893b4d9d1615e7863f2"></a>
typedef ordered_list::key_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a61ecea3df71f9893b4d9d1615e7863f2">key_type</a></td></tr>
<tr class="memdesc:a61ecea3df71f9893b4d9d1615e7863f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">key type <br /></td></tr>
<tr class="separator:a61ecea3df71f9893b4d9d1615e7863f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f166f15c6bc0fd4f856ffd9a7f9176"><td class="memItemLeft" align="right" valign="top"><a id="a23f166f15c6bc0fd4f856ffd9a7f9176"></a>
typedef ordered_list::mapped_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a23f166f15c6bc0fd4f856ffd9a7f9176">mapped_type</a></td></tr>
<tr class="memdesc:a23f166f15c6bc0fd4f856ffd9a7f9176"><td class="mdescLeft">&#160;</td><td class="mdescRight">value type <br /></td></tr>
<tr class="separator:a23f166f15c6bc0fd4f856ffd9a7f9176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3d9027b2e6c87b01c3b65e3b1aed5a"><td class="memItemLeft" align="right" valign="top"><a id="a1b3d9027b2e6c87b01c3b65e3b1aed5a"></a>
typedef ordered_list::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a1b3d9027b2e6c87b01c3b65e3b1aed5a">value_type</a></td></tr>
<tr class="memdesc:a1b3d9027b2e6c87b01c3b65e3b1aed5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">key/value pair stored in the map <br /></td></tr>
<tr class="separator:a1b3d9027b2e6c87b01c3b65e3b1aed5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2c831b6897bdc2bc128cf884b9d670"><td class="memItemLeft" align="right" valign="top"><a id="aeb2c831b6897bdc2bc128cf884b9d670"></a>
typedef traits::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#aeb2c831b6897bdc2bc128cf884b9d670">allocator</a></td></tr>
<tr class="memdesc:aeb2c831b6897bdc2bc128cf884b9d670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bucket table allocator. <br /></td></tr>
<tr class="separator:aeb2c831b6897bdc2bc128cf884b9d670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9776870e2b31f8d32bc7282d6105d3d4"><td class="memItemLeft" align="right" valign="top"><a id="a9776870e2b31f8d32bc7282d6105d3d4"></a>
typedef ordered_list::key_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a9776870e2b31f8d32bc7282d6105d3d4">key_comparator</a></td></tr>
<tr class="memdesc:a9776870e2b31f8d32bc7282d6105d3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">key compare functor <br /></td></tr>
<tr class="separator:a9776870e2b31f8d32bc7282d6105d3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2b436d765ea38162114e4abc5ef61c"><td class="memItemLeft" align="right" valign="top">typedef ordered_list::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a0f2b436d765ea38162114e4abc5ef61c">stat</a></td></tr>
<tr class="separator:a0f2b436d765ea38162114e4abc5ef61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901dec3c3cb8a629f3f6230845fd4721"><td class="memItemLeft" align="right" valign="top"><a id="a901dec3c3cb8a629f3f6230845fd4721"></a>
typedef ordered_list::guarded_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a901dec3c3cb8a629f3f6230845fd4721">guarded_ptr</a></td></tr>
<tr class="memdesc:a901dec3c3cb8a629f3f6230845fd4721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded pointer - a result of <code><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#ae88464eafb958bd8df621ecf783e73c5" title="Finds key and return the item found. ">get()</a></code> and <code><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a294aef3736ea5e317175e0696a1e0b00" title="Extracts the item with specified key. ">extract()</a></code> functions. <br /></td></tr>
<tr class="separator:a901dec3c3cb8a629f3f6230845fd4721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e514d02a3a23e4fd7844795f908d3bb"><td class="memItemLeft" align="right" valign="top"><a id="a2e514d02a3a23e4fd7844795f908d3bb"></a>
typedef cds::opt::v::hash_selector&lt; typename traits::hash &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a2e514d02a3a23e4fd7844795f908d3bb">hash</a></td></tr>
<tr class="memdesc:a2e514d02a3a23e4fd7844795f908d3bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor for <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a61ecea3df71f9893b4d9d1615e7863f2">key_type</a> and all its derivatives that you use. <br /></td></tr>
<tr class="separator:a2e514d02a3a23e4fd7844795f908d3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300fcfbf6fedec1eaf803d0a314f6ad6"><td class="memItemLeft" align="right" valign="top"><a id="a300fcfbf6fedec1eaf803d0a314f6ad6"></a>
typedef traits::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a300fcfbf6fedec1eaf803d0a314f6ad6">item_counter</a></td></tr>
<tr class="memdesc:a300fcfbf6fedec1eaf803d0a314f6ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter type. <br /></td></tr>
<tr class="separator:a300fcfbf6fedec1eaf803d0a314f6ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5b4756d55e75b439fe75adb6aebc5b19"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a5b4756d55e75b439fe75adb6aebc5b19">MichaelHashMap</a> (size_t nMaxItemCount, size_t nLoadFactor)</td></tr>
<tr class="memdesc:a5b4756d55e75b439fe75adb6aebc5b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the map.  <a href="#a5b4756d55e75b439fe75adb6aebc5b19">More...</a><br /></td></tr>
<tr class="separator:a5b4756d55e75b439fe75adb6aebc5b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e452259d93feef1e414ad2a997fc504"><td class="memItemLeft" align="right" valign="top"><a id="a6e452259d93feef1e414ad2a997fc504"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a6e452259d93feef1e414ad2a997fc504">~MichaelHashMap</a> ()</td></tr>
<tr class="memdesc:a6e452259d93feef1e414ad2a997fc504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears hash map and destroys it. <br /></td></tr>
<tr class="separator:a6e452259d93feef1e414ad2a997fc504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89c19c4402799692b234d0c0958c78c"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:ab89c19c4402799692b234d0c0958c78c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#ab89c19c4402799692b234d0c0958c78c">insert</a> (K &amp;&amp;key)</td></tr>
<tr class="memdesc:ab89c19c4402799692b234d0c0958c78c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node with key and default value.  <a href="#ab89c19c4402799692b234d0c0958c78c">More...</a><br /></td></tr>
<tr class="separator:ab89c19c4402799692b234d0c0958c78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4764ab4d26d2d5fdbcf881e27becddb7"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a4764ab4d26d2d5fdbcf881e27becddb7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a4764ab4d26d2d5fdbcf881e27becddb7">insert</a> (K &amp;&amp;key, V &amp;&amp;val)</td></tr>
<tr class="memdesc:a4764ab4d26d2d5fdbcf881e27becddb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a4764ab4d26d2d5fdbcf881e27becddb7">More...</a><br /></td></tr>
<tr class="separator:a4764ab4d26d2d5fdbcf881e27becddb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512d4f96f648f355c9341138747ac588"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a512d4f96f648f355c9341138747ac588"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a512d4f96f648f355c9341138747ac588">insert_with</a> (K &amp;&amp;key, Func func)</td></tr>
<tr class="memdesc:a512d4f96f648f355c9341138747ac588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node and initialize it by a functor.  <a href="#a512d4f96f648f355c9341138747ac588">More...</a><br /></td></tr>
<tr class="separator:a512d4f96f648f355c9341138747ac588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344bcc9b0cb057433f35f1b7633c25b7"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a344bcc9b0cb057433f35f1b7633c25b7"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a344bcc9b0cb057433f35f1b7633c25b7">update</a> (K &amp;&amp;key, Func func, bool bAllowInsert=true)</td></tr>
<tr class="memdesc:a344bcc9b0cb057433f35f1b7633c25b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates data by <code>key</code>.  <a href="#a344bcc9b0cb057433f35f1b7633c25b7">More...</a><br /></td></tr>
<tr class="separator:a344bcc9b0cb057433f35f1b7633c25b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27bc2c87dcb86836450f5f329508af8"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename V &gt; </td></tr>
<tr class="memitem:ad27bc2c87dcb86836450f5f329508af8"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#ad27bc2c87dcb86836450f5f329508af8">upsert</a> (Q &amp;&amp;key, V &amp;&amp;val, bool bAllowInsert=true)</td></tr>
<tr class="memdesc:ad27bc2c87dcb86836450f5f329508af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts or updates the node (only for <code><a class="el" href="classcds_1_1container_1_1_iterable_k_v_list.html" title="Iterable ordered list for key-value pair. ">IterableKVList</a></code>)  <a href="#ad27bc2c87dcb86836450f5f329508af8">More...</a><br /></td></tr>
<tr class="separator:ad27bc2c87dcb86836450f5f329508af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1b153e7b924e78c593573c5cfffe89"><td class="memTemplParams" colspan="2">template&lt;typename K , typename... Args&gt; </td></tr>
<tr class="memitem:a8f1b153e7b924e78c593573c5cfffe89"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a8f1b153e7b924e78c593573c5cfffe89">emplace</a> (K &amp;&amp;key, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a8f1b153e7b924e78c593573c5cfffe89"><td class="mdescLeft">&#160;</td><td class="mdescRight">For key <code>key</code> inserts data of type <code>mapped_type</code> created from <code>args</code>.  <a href="#a8f1b153e7b924e78c593573c5cfffe89">More...</a><br /></td></tr>
<tr class="separator:a8f1b153e7b924e78c593573c5cfffe89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e87d786b614fe694467bbd91daecbc"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:ab3e87d786b614fe694467bbd91daecbc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#ab3e87d786b614fe694467bbd91daecbc">erase</a> (K const &amp;key)</td></tr>
<tr class="memdesc:ab3e87d786b614fe694467bbd91daecbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes <code>key</code> from the map.  <a href="#ab3e87d786b614fe694467bbd91daecbc">More...</a><br /></td></tr>
<tr class="separator:ab3e87d786b614fe694467bbd91daecbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9dbb7e4991a31b78237f2ef3671307"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a5e9dbb7e4991a31b78237f2ef3671307"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a5e9dbb7e4991a31b78237f2ef3671307">erase_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a5e9dbb7e4991a31b78237f2ef3671307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the map using <code>pred</code> predicate for searching.  <a href="#a5e9dbb7e4991a31b78237f2ef3671307">More...</a><br /></td></tr>
<tr class="separator:a5e9dbb7e4991a31b78237f2ef3671307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab078ecdb8dde43dd992e9f63fc96c7a3"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:ab078ecdb8dde43dd992e9f63fc96c7a3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#ab078ecdb8dde43dd992e9f63fc96c7a3">erase</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:ab078ecdb8dde43dd992e9f63fc96c7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes <code>key</code> from the map.  <a href="#ab078ecdb8dde43dd992e9f63fc96c7a3">More...</a><br /></td></tr>
<tr class="separator:ab078ecdb8dde43dd992e9f63fc96c7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382ac299a8ccda2272ec27296361da8c"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a382ac299a8ccda2272ec27296361da8c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a382ac299a8ccda2272ec27296361da8c">erase_with</a> (K const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:a382ac299a8ccda2272ec27296361da8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the map using <code>pred</code> predicate for searching.  <a href="#a382ac299a8ccda2272ec27296361da8c">More...</a><br /></td></tr>
<tr class="separator:a382ac299a8ccda2272ec27296361da8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294aef3736ea5e317175e0696a1e0b00"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a294aef3736ea5e317175e0696a1e0b00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a901dec3c3cb8a629f3f6230845fd4721">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a294aef3736ea5e317175e0696a1e0b00">extract</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a294aef3736ea5e317175e0696a1e0b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item with specified <code>key</code>.  <a href="#a294aef3736ea5e317175e0696a1e0b00">More...</a><br /></td></tr>
<tr class="separator:a294aef3736ea5e317175e0696a1e0b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f075a257e000fff5c0b8aa7cc38500"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a35f075a257e000fff5c0b8aa7cc38500"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a901dec3c3cb8a629f3f6230845fd4721">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a35f075a257e000fff5c0b8aa7cc38500">extract_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a35f075a257e000fff5c0b8aa7cc38500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item using compare functor <code>pred</code>.  <a href="#a35f075a257e000fff5c0b8aa7cc38500">More...</a><br /></td></tr>
<tr class="separator:a35f075a257e000fff5c0b8aa7cc38500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463d8d7851dedae6fcc0d9b0d82c2e6d"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a463d8d7851dedae6fcc0d9b0d82c2e6d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a463d8d7851dedae6fcc0d9b0d82c2e6d">find</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:a463d8d7851dedae6fcc0d9b0d82c2e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code>.  <a href="#a463d8d7851dedae6fcc0d9b0d82c2e6d">More...</a><br /></td></tr>
<tr class="separator:a463d8d7851dedae6fcc0d9b0d82c2e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23d5652b1df274b63485b5c2e0da620"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:ae23d5652b1df274b63485b5c2e0da620"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#ae23d5652b1df274b63485b5c2e0da620">find</a> (K const &amp;key)</td></tr>
<tr class="memdesc:ae23d5652b1df274b63485b5c2e0da620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> and returns iterator pointed to the item found (only for <code><a class="el" href="classcds_1_1container_1_1_iterable_list.html" title="Iterable ordered list. ">IterableList</a></code>)  <a href="#ae23d5652b1df274b63485b5c2e0da620">More...</a><br /></td></tr>
<tr class="separator:ae23d5652b1df274b63485b5c2e0da620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcdb0d94caf721d23c8d867f9e26336"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:acfcdb0d94caf721d23c8d867f9e26336"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#acfcdb0d94caf721d23c8d867f9e26336">find_with</a> (K const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:acfcdb0d94caf721d23c8d867f9e26336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for searching.  <a href="#acfcdb0d94caf721d23c8d867f9e26336">More...</a><br /></td></tr>
<tr class="separator:acfcdb0d94caf721d23c8d867f9e26336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5feab88822e30b8b253334843f3abf2d"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a5feab88822e30b8b253334843f3abf2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a5feab88822e30b8b253334843f3abf2d">find_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a5feab88822e30b8b253334843f3abf2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> using <code>pred</code> predicate and returns iterator pointed to the item found (only for <code><a class="el" href="classcds_1_1container_1_1_iterable_list.html" title="Iterable ordered list. ">IterableList</a></code>)  <a href="#a5feab88822e30b8b253334843f3abf2d">More...</a><br /></td></tr>
<tr class="separator:a5feab88822e30b8b253334843f3abf2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f0c8b93a02e4e3524fabc22ef51984f"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a1f0c8b93a02e4e3524fabc22ef51984f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a1f0c8b93a02e4e3524fabc22ef51984f">contains</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a1f0c8b93a02e4e3524fabc22ef51984f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the map contains <code>key</code>.  <a href="#a1f0c8b93a02e4e3524fabc22ef51984f">More...</a><br /></td></tr>
<tr class="separator:a1f0c8b93a02e4e3524fabc22ef51984f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738b53a472a211ecc94e5207cfdc3df0"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a738b53a472a211ecc94e5207cfdc3df0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a738b53a472a211ecc94e5207cfdc3df0">contains</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a738b53a472a211ecc94e5207cfdc3df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the map contains <code>key</code> using <code>pred</code> predicate for searching.  <a href="#a738b53a472a211ecc94e5207cfdc3df0">More...</a><br /></td></tr>
<tr class="separator:a738b53a472a211ecc94e5207cfdc3df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88464eafb958bd8df621ecf783e73c5"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:ae88464eafb958bd8df621ecf783e73c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a901dec3c3cb8a629f3f6230845fd4721">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#ae88464eafb958bd8df621ecf783e73c5">get</a> (K const &amp;key)</td></tr>
<tr class="memdesc:ae88464eafb958bd8df621ecf783e73c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> and return the item found.  <a href="#ae88464eafb958bd8df621ecf783e73c5">More...</a><br /></td></tr>
<tr class="separator:ae88464eafb958bd8df621ecf783e73c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e2ae292ef69778acbf191c38b5c34c"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a41e2ae292ef69778acbf191c38b5c34c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a901dec3c3cb8a629f3f6230845fd4721">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a41e2ae292ef69778acbf191c38b5c34c">get_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a41e2ae292ef69778acbf191c38b5c34c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> and return the item found.  <a href="#a41e2ae292ef69778acbf191c38b5c34c">More...</a><br /></td></tr>
<tr class="separator:a41e2ae292ef69778acbf191c38b5c34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929894210bf7b045d646f82ab175aa6b"><td class="memItemLeft" align="right" valign="top"><a id="a929894210bf7b045d646f82ab175aa6b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a929894210bf7b045d646f82ab175aa6b">clear</a> ()</td></tr>
<tr class="memdesc:a929894210bf7b045d646f82ab175aa6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the map (not atomic) <br /></td></tr>
<tr class="separator:a929894210bf7b045d646f82ab175aa6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462c49f4ec1183b9c4dae1c192414005"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a462c49f4ec1183b9c4dae1c192414005">empty</a> () const</td></tr>
<tr class="memdesc:a462c49f4ec1183b9c4dae1c192414005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the map is empty.  <a href="#a462c49f4ec1183b9c4dae1c192414005">More...</a><br /></td></tr>
<tr class="separator:a462c49f4ec1183b9c4dae1c192414005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4646275f8fd0459498bf456b0266b829"><td class="memItemLeft" align="right" valign="top"><a id="a4646275f8fd0459498bf456b0266b829"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a4646275f8fd0459498bf456b0266b829">size</a> () const</td></tr>
<tr class="memdesc:a4646275f8fd0459498bf456b0266b829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the map. <br /></td></tr>
<tr class="separator:a4646275f8fd0459498bf456b0266b829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f68b08fea369b06efc74dfc6c35acf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a55f68b08fea369b06efc74dfc6c35acf">bucket_count</a> () const</td></tr>
<tr class="memdesc:a55f68b08fea369b06efc74dfc6c35acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of hash table.  <a href="#a55f68b08fea369b06efc74dfc6c35acf">More...</a><br /></td></tr>
<tr class="separator:a55f68b08fea369b06efc74dfc6c35acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f651202e000e12b2b3fe68b24f80dfb"><td class="memItemLeft" align="right" valign="top"><a id="a7f651202e000e12b2b3fe68b24f80dfb"></a>
<a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a0f2b436d765ea38162114e4abc5ef61c">stat</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a7f651202e000e12b2b3fe68b24f80dfb">statistics</a> () const</td></tr>
<tr class="memdesc:a7f651202e000e12b2b3fe68b24f80dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br /></td></tr>
<tr class="separator:a7f651202e000e12b2b3fe68b24f80dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a30ffdb219820e9f51d9a617740217bcd"><td class="memItemLeft" align="right" valign="top"><a id="a30ffdb219820e9f51d9a617740217bcd"></a>
static constexpr const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a30ffdb219820e9f51d9a617740217bcd">c_nHazardPtrCount</a> = ordered_list::c_nHazardPtrCount</td></tr>
<tr class="memdesc:a30ffdb219820e9f51d9a617740217bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of hazard pointer required. <br /></td></tr>
<tr class="separator:a30ffdb219820e9f51d9a617740217bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Forward iterators (only for debugging purpose)</h2></td></tr>
<tr class="memitem:afcebb900b3a0a09eadb916a458e9b6a3"><td class="memItemLeft" align="right" valign="top">typedef iterator_type&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a></td></tr>
<tr class="memdesc:afcebb900b3a0a09eadb916a458e9b6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward iterator.  <a href="#afcebb900b3a0a09eadb916a458e9b6a3">More...</a><br /></td></tr>
<tr class="separator:afcebb900b3a0a09eadb916a458e9b6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5b04694f85fd34390928dd1744bdbb"><td class="memItemLeft" align="right" valign="top"><a id="adf5b04694f85fd34390928dd1744bdbb"></a>
typedef iterator_type&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#adf5b04694f85fd34390928dd1744bdbb">const_iterator</a></td></tr>
<tr class="memdesc:adf5b04694f85fd34390928dd1744bdbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const forward iterator. <br /></td></tr>
<tr class="separator:adf5b04694f85fd34390928dd1744bdbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae837465b5c985e4856f4c368f638a097"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#ae837465b5c985e4856f4c368f638a097">begin</a> ()</td></tr>
<tr class="memdesc:ae837465b5c985e4856f4c368f638a097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator addressing the first element in a map.  <a href="#ae837465b5c985e4856f4c368f638a097">More...</a><br /></td></tr>
<tr class="separator:ae837465b5c985e4856f4c368f638a097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2ff57ccf188ead667fdf511f89adf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a6d2ff57ccf188ead667fdf511f89adf5">end</a> ()</td></tr>
<tr class="memdesc:a6d2ff57ccf188ead667fdf511f89adf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator that addresses the location succeeding the last element in a map.  <a href="#a6d2ff57ccf188ead667fdf511f89adf5">More...</a><br /></td></tr>
<tr class="separator:a6d2ff57ccf188ead667fdf511f89adf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd46506444fdd437bb585ff22965a9c"><td class="memItemLeft" align="right" valign="top"><a id="a2bd46506444fdd437bb585ff22965a9c"></a>
<a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#adf5b04694f85fd34390928dd1744bdbb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a2bd46506444fdd437bb585ff22965a9c">begin</a> () const</td></tr>
<tr class="memdesc:a2bd46506444fdd437bb585ff22965a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a map. <br /></td></tr>
<tr class="separator:a2bd46506444fdd437bb585ff22965a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17c21daab3cf054c0b97d92d312b510"><td class="memItemLeft" align="right" valign="top"><a id="ad17c21daab3cf054c0b97d92d312b510"></a>
<a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#adf5b04694f85fd34390928dd1744bdbb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#ad17c21daab3cf054c0b97d92d312b510">cbegin</a> () const</td></tr>
<tr class="memdesc:ad17c21daab3cf054c0b97d92d312b510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a map. <br /></td></tr>
<tr class="separator:ad17c21daab3cf054c0b97d92d312b510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03b5a99bcb3ac8c3b0d5c6e4d66dfc3"><td class="memItemLeft" align="right" valign="top"><a id="aa03b5a99bcb3ac8c3b0d5c6e4d66dfc3"></a>
<a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#adf5b04694f85fd34390928dd1744bdbb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#aa03b5a99bcb3ac8c3b0d5c6e4d66dfc3">end</a> () const</td></tr>
<tr class="memdesc:aa03b5a99bcb3ac8c3b0d5c6e4d66dfc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator that addresses the location succeeding the last element in a map. <br /></td></tr>
<tr class="separator:aa03b5a99bcb3ac8c3b0d5c6e4d66dfc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4baa5b99c556939775ab0d10da6db131"><td class="memItemLeft" align="right" valign="top"><a id="a4baa5b99c556939775ab0d10da6db131"></a>
<a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#adf5b04694f85fd34390928dd1744bdbb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a4baa5b99c556939775ab0d10da6db131">cend</a> () const</td></tr>
<tr class="memdesc:a4baa5b99c556939775ab0d10da6db131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator that addresses the location succeeding the last element in a map. <br /></td></tr>
<tr class="separator:a4baa5b99c556939775ab0d10da6db131"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class GC, class OrderedList, class Traits = michael_map::traits&gt;<br />
class cds::container::MichaelHashMap&lt; GC, OrderedList, Traits &gt;</h3>

<p>Michael's hash map. </p>
<p><a class="anchor" id="cds_nonintrusive_MichaelHashMap_hp"></a> Source:</p><ul>
<li>[2002] Maged Michael "High performance dynamic lock-free hash tables and list-based sets"</li>
</ul>
<p>Michael's hash table algorithm is based on lock-free ordered list and it is very simple. The main structure is an array <code>T</code> of size <code>M</code>. Each element in <code>T</code> is basically a pointer to a hash bucket, implemented as a singly linked list. The array of buckets cannot be dynamically expanded. However, each bucket may contain unbounded number of items.</p>
<p>Template parameters are:</p><ul>
<li><code>GC</code> - Garbage collector used. You may use any <a class="el" href="group__cds__garbage__collector.html">Garbage collector</a> from the <code>libcds</code> library. Note the <code>GC</code> must be the same as the GC used for <code>OrderedList</code> </li>
<li><code>OrderedList</code> - ordered key-value list implementation used as bucket for hash map, for example, <code><a class="el" href="classcds_1_1container_1_1_michael_k_v_list.html" title="Michael&#39;s ordered list for key-value pair. ">MichaelKVList</a></code>, <code><a class="el" href="classcds_1_1container_1_1_lazy_k_v_list.html" title="Lazy ordered list (key-value pair) ">LazyKVList</a></code>, <code><a class="el" href="classcds_1_1container_1_1_iterable_k_v_list.html" title="Iterable ordered list for key-value pair. ">IterableKVList</a></code>. The ordered list implementation specifies the <code>Key</code> and <code>Value</code> types stored in the hash-map, the reclamation schema <code>GC</code> used by hash-map, the comparison functor for the type <code>Key</code> and other features specific for the ordered list.</li>
<li><code>Traits</code> - map traits, default is <code><a class="el" href="namespacecds_1_1container_1_1michael__map.html#ab5f19c5329fdd2d525e9c82b5c741539" title="MichaelHashMap traits ">michael_map::traits</a></code>. Instead of defining <code>Traits</code> struct you may use option-based syntax with <code><a class="el" href="namespacecds_1_1container_1_1michael__map.html#ac488b413199f6b36468ab61f5e4637cf" title="Metafunction converting option list to michael_map::traits. ">michael_map::make_traits</a></code> metafunction.</li>
</ul>
<p>Many of the class function take a key argument of type <code>K</code> that in general is not <code>key_type</code>. <code>key_type</code> and an argument of template type <code>K</code> must meet the following requirements:</p><ul>
<li><code>key_type</code> should be constructible from value of type <code>K</code>;</li>
<li>the hash functor should be able to calculate correct hash value from argument <code>key</code> of type <code>K:</code> <code> hash( key_type(key)) == hash( key ) </code></li>
<li>values of type <code>key_type</code> and <code>K</code> should be comparable</li>
</ul>
<p>There are the specializations:</p><ul>
<li>for <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_desc">RCU</a> - declared in <code>cds/container/michael_map_rcu.h</code>, see <a class="el" href="classcds_1_1container_1_1_michael_hash_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_ordered_list_00_01_traits_01_4.html#cds_nonintrusive_MichaelHashMap_rcu">MichaelHashMap&lt;RCU&gt;</a>.</li>
<li>for <code><a class="el" href="classcds_1_1gc_1_1nogc.html" title="No garbage collecting. ">cds::gc::nogc</a></code> declared in <code>cds/container/michael_map_nogc.h</code>, see <a class="el" href="classcds_1_1container_1_1_michael_hash_map_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#cds_nonintrusive_MichaelHashMap_nogc">MichaelHashMap&lt;gc::nogc&gt;</a>.</li>
</ul>
<p><a class="anchor" id="cds_nonintrusive_MichaelHashMap_how_touse"></a><b>How to use</b></p>
<p>Suppose, you want to make <code>int</code> to <code>int</code> map for Hazard Pointer garbage collector. You should choose suitable ordered list class that will be used as a bucket for the map; it may be <code><a class="el" href="classcds_1_1container_1_1_michael_k_v_list.html" title="Michael&#39;s ordered list for key-value pair. ">MichaelKVList</a></code>. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/michael_kvlist_hp.h&gt;</span>    <span class="comment">// MichaelKVList for gc::HP</span></div><div class="line"><span class="preprocessor">#include &lt;cds/container/michael_map.h&gt;</span>          <span class="comment">// MichaelHashMap</span></div><div class="line"></div><div class="line"><span class="comment">// List traits based on std::less predicate</span></div><div class="line"><span class="keyword">struct </span>list_traits: <span class="keyword">public</span> cds::container::michael_list::traits</div><div class="line">{</div><div class="line">    <span class="keyword">typedef</span> std::less&lt;int&gt;      less;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Ordered list</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_michael_k_v_list.html">cds::container::MichaelKVList&lt; cds::gc::HP, int, int, list_traits&gt;</a> int2int_list;</div><div class="line"></div><div class="line"><span class="comment">// Map traits</span></div><div class="line"><span class="keyword">struct </span>map_traits: <span class="keyword">public</span> <a class="code" href="structcds_1_1intrusive_1_1michael__set_1_1traits.html">cds::container::michael_map::traits</a></div><div class="line">{</div><div class="line">    <span class="keyword">struct </span><a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#a2e514d02a3a23e4fd7844795f908d3bb">hash</a> {</div><div class="line">        <span class="keywordtype">size_t</span> operator()( <span class="keywordtype">int</span> i )<span class="keyword"> const</span></div><div class="line"><span class="keyword">        </span>{</div><div class="line">            <span class="keywordflow">return</span> cds::opt::v::hash&lt;int&gt;()( i );</div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Your map</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap&lt; cds::gc::HP, int2int_list, map_traits &gt;</a> int2int_map;</div><div class="line"></div><div class="line"><span class="comment">// Now you can use int2int_map class</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    int2int_map theMap;</div><div class="line"></div><div class="line">    theMap.<a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#ab89c19c4402799692b234d0c0958c78c">insert</a>( 100 );</div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><p>You may use option-based declaration: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/michael_kvlist_hp.h&gt;</span>    <span class="comment">// MichaelKVList for gc::HP</span></div><div class="line"><span class="preprocessor">#include &lt;cds/container/michael_map.h&gt;</span>          <span class="comment">// MichaelHashMap</span></div><div class="line"></div><div class="line"><span class="comment">// Ordered list</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_michael_k_v_list.html">cds::container::MichaelKVList</a>&lt; cds::gc::HP, int, int,</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="structcds_1_1container_1_1michael__list_1_1make__traits.html">cds::container::michael_list::make_traits</a>&lt;</div><div class="line">        <a class="code" href="structcds_1_1opt_1_1less.html">cds::container::opt::less&lt; std::less&lt;int&gt;</a> &gt;     <span class="comment">// item comparator option</span></div><div class="line">    &gt;::type</div><div class="line">&gt;  int2int_list;</div><div class="line"></div><div class="line"><span class="comment">// Map</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; cds::gc::HP, int2int_list,</div><div class="line">    <a class="code" href="structcds_1_1intrusive_1_1michael__set_1_1make__traits.html">cds::container::michael_map::make_traits</a>&lt;</div><div class="line">        cc::opt::hash&lt; cds::opt::v::hash&lt;int&gt; &gt;</div><div class="line">    &gt;</div><div class="line">&gt; int2int_map;</div></div><!-- fragment --> </div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="afcebb900b3a0a09eadb916a458e9b6a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcebb900b3a0a09eadb916a458e9b6a3">&sect;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef iterator_type&lt; false &gt; <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forward iterator. </p>
<p>The forward iterator for Michael's map has some features:</p><ul>
<li>it has no post-increment operator</li>
<li>to protect the value, the iterator contains a GC-specific guard + another guard is required locally for increment operator. For some GC (like as <code><a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector. ">gc::HP</a></code>), a guard is a limited resource per thread, so an exception (or assertion) "no free guard" may be thrown if the limit of guard count per thread is exceeded.</li>
<li>The iterator cannot be moved across thread boundary because it contains thread-private GC's guard.</li>
</ul>
<p>Iterator thread safety depends on type of <code>OrderedList:</code> </p><ul>
<li>for <code><a class="el" href="classcds_1_1container_1_1_michael_k_v_list.html" title="Michael&#39;s ordered list for key-value pair. ">MichaelKVList</a></code> and <code><a class="el" href="classcds_1_1container_1_1_lazy_k_v_list.html" title="Lazy ordered list (key-value pair) ">LazyKVList</a>:</code> iterator guarantees safety even if you delete the item that iterator points to because that item is guarded by hazard pointer. However, in case of concurrent deleting operations it is no guarantee that you iterate all item in the map. Moreover, a crash is possible when you try to iterate the next element that has been deleted by concurrent thread. Use this iterator on the concurrent container for debugging purpose only.</li>
<li>for <code><a class="el" href="classcds_1_1container_1_1_iterable_list.html" title="Iterable ordered list. ">IterableList</a>:</code> iterator is thread-safe. You may use it freely in concurrent environment.</li>
</ul>
<p>The iterator interface: </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a> {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Default constructor</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Copy construtor</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a>( <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a> <span class="keyword">const</span>&amp; src );</div><div class="line"></div><div class="line">    <span class="comment">// Dereference operator</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#a1b3d9027b2e6c87b01c3b65e3b1aed5a">value_type</a> * operator -&gt;() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Dereference operator</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#a1b3d9027b2e6c87b01c3b65e3b1aed5a">value_type</a>&amp; operator *() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Preincrement operator</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a>&amp; operator ++();</div><div class="line"></div><div class="line">    <span class="comment">// Assignment operator</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a>&amp; operator = (<a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a> <span class="keyword">const</span>&amp; src);</div><div class="line"></div><div class="line">    <span class="comment">// Equality operators</span></div><div class="line">    <span class="keywordtype">bool</span> operator ==(<a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a> <span class="keyword">const</span>&amp; i ) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">bool</span> operator !=(<a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a> <span class="keyword">const</span>&amp; i ) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The iterator object returned by <code><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a6d2ff57ccf188ead667fdf511f89adf5" title="Returns an iterator that addresses the location succeeding the last element in a map. ">end()</a></code>, <code><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a4baa5b99c556939775ab0d10da6db131" title="Returns an const iterator that addresses the location succeeding the last element in a map...">cend()</a></code> member functions points to <code>nullptr</code> and should not be dereferenced. </dd></dl>

</div>
</div>
<a id="a0f2b436d765ea38162114e4abc5ef61c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f2b436d765ea38162114e4abc5ef61c">&sect;&nbsp;</a></span>stat</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ordered_list::stat <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a0f2b436d765ea38162114e4abc5ef61c">stat</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Internal statistics </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5b4756d55e75b439fe75adb6aebc5b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b4756d55e75b439fe75adb6aebc5b19">&sect;&nbsp;</a></span>MichaelHashMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">MichaelHashMap</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nMaxItemCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nLoadFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the map. </p>
<p><a class="anchor" id="cds_nonintrusive_MichaelHashMap_hp_ctor"></a>The Michael's hash map is non-expandable container. You should point the average count of items <code>nMaxItemCount</code> when you create an object. <code>nLoadFactor</code> parameter defines average count of items per bucket and it should be small number between 1 and 10. Remember, since the bucket implementation is an ordered list, searching in the bucket is linear [<code>O(nLoadFactor)</code>]. Note, that many popular STL hash map implementation uses load factor 1.</p>
<p>The ctor defines hash table size as rounding <code>nMacItemCount / nLoadFactor</code> up to nearest power of two. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nMaxItemCount</td><td>estimation of max item count in the hash map </td></tr>
    <tr><td class="paramname">nLoadFactor</td><td>load factor: estimation of max number of items in the bucket </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae837465b5c985e4856f4c368f638a097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae837465b5c985e4856f4c368f638a097">&sect;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a> <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a forward iterator addressing the first element in a map. </p>
<p>For empty map</p><div class="fragment"><div class="line"><a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#ae837465b5c985e4856f4c368f638a097">begin</a>() == <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#a6d2ff57ccf188ead667fdf511f89adf5">end</a>() </div></div><!-- fragment --> 
</div>
</div>
<a id="a55f68b08fea369b06efc74dfc6c35acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55f68b08fea369b06efc74dfc6c35acf">&sect;&nbsp;</a></span>bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of hash table. </p>
<p>Since <code>MichaelHashMap</code> cannot dynamically extend the hash table size, the value returned is an constant depending on object initialization parameters; see <code><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a5b4756d55e75b439fe75adb6aebc5b19" title="Initializes the map. ">MichaelHashMap::MichaelHashMap</a></code> for explanation. </p>

</div>
</div>
<a id="a1f0c8b93a02e4e3524fabc22ef51984f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f0c8b93a02e4e3524fabc22ef51984f">&sect;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the map contains <code>key</code>. </p>
<p>The function searches the item with key equal to <code>key</code> and returns <code>true</code> if it is found, and <code>false</code> otherwise. </p>

</div>
</div>
<a id="a738b53a472a211ecc94e5207cfdc3df0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a738b53a472a211ecc94e5207cfdc3df0">&sect;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the map contains <code>key</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <code>contains( key )</code> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a id="a8f1b153e7b924e78c593573c5cfffe89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f1b153e7b924e78c593573c5cfffe89">&sect;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For key <code>key</code> inserts data of type <code>mapped_type</code> created from <code>args</code>. </p>
<p><code>key_type</code> should be constructible from type <code>K</code> </p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise. </p>

</div>
</div>
<a id="a462c49f4ec1183b9c4dae1c192414005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462c49f4ec1183b9c4dae1c192414005">&sect;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the map is empty. </p>
<p>Emptiness is checked by item counting: if item count is zero then the map is empty. Thus, the correct item counting is an important part of the map implementation. </p>

</div>
</div>
<a id="a6d2ff57ccf188ead667fdf511f89adf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d2ff57ccf188ead667fdf511f89adf5">&sect;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a> <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator that addresses the location succeeding the last element in a map. </p>
<p>Do not use the value returned by <code>end</code> function to access any item. The returned value can be used only to control reaching the end of the map. For empty map</p><div class="fragment"><div class="line"><a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#ae837465b5c985e4856f4c368f638a097">begin</a>() == <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#a6d2ff57ccf188ead667fdf511f89adf5">end</a>() </div></div><!-- fragment --> 
</div>
</div>
<a id="ab3e87d786b614fe694467bbd91daecbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e87d786b614fe694467bbd91daecbc">&sect;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes <code>key</code> from the map. </p>
<p><a class="anchor" id="cds_nonintrusive_MichaelMap_erase_val"></a> Return <code>true</code> if <code>key</code> is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a id="ab078ecdb8dde43dd992e9f63fc96c7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab078ecdb8dde43dd992e9f63fc96c7a3">&sect;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes <code>key</code> from the map. </p>
<p><a class="anchor" id="cds_nonintrusive_MichaelMap_erase_func"></a> The function searches an item with key <code>key</code>, calls <code>f</code> functor and deletes the item. If <code>key</code> is not found, the functor is not called.</p>
<p>The functor <code>Func</code> interface: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>extractor {</div><div class="line">    <span class="keywordtype">void</span> operator()(<a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#a1b3d9027b2e6c87b01c3b65e3b1aed5a">value_type</a>&amp; item) { ... }</div><div class="line">};</div></div><!-- fragment --><p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a id="a5e9dbb7e4991a31b78237f2ef3671307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9dbb7e4991a31b78237f2ef3671307">&sect;&nbsp;</a></span>erase_with() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the map using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#cds_nonintrusive_MichaelMap_erase_val">erase(K const&amp;)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a id="a382ac299a8ccda2272ec27296361da8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382ac299a8ccda2272ec27296361da8c">&sect;&nbsp;</a></span>erase_with() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the map using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#cds_nonintrusive_MichaelMap_erase_func">erase(K const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a id="a294aef3736ea5e317175e0696a1e0b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a294aef3736ea5e317175e0696a1e0b00">&sect;&nbsp;</a></span>extract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a901dec3c3cb8a629f3f6230845fd4721">guarded_ptr</a> <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::extract </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the item with specified <code>key</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_MichaelHashMap_hp_extract"></a>The function searches an item with key equal to <code>key</code>, unlinks it from the map, and returns it as <code>guarded_ptr</code>. If <code>key</code> is not found the function returns an empty guarded pointer.</p>
<p>Note the compare functor should accept a parameter of type <code>K</code> that may be not the same as <code>key_type</code>.</p>
<p>The extracted item is freed automatically when returned <code>guarded_ptr</code> object will be destroyed or released. </p><dl class="section note"><dt>Note</dt><dd>Each <code>guarded_ptr</code> object uses the GC's guard that can be limited resource.</dd></dl>
<p>Usage: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap&lt; your_template_args &gt;</a> michael_map;</div><div class="line">michael_map theMap;</div><div class="line"><span class="comment">// ...</span></div><div class="line">{</div><div class="line">    michael_map::guarded_ptr gp( theMap.extract( 5 ));</div><div class="line">    <span class="keywordflow">if</span> ( gp ) {</div><div class="line">        <span class="comment">// Deal with gp</span></div><div class="line">        <span class="comment">// ...</span></div><div class="line">    }</div><div class="line">    <span class="comment">// Destructor of gp releases internal HP guard</span></div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="a35f075a257e000fff5c0b8aa7cc38500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f075a257e000fff5c0b8aa7cc38500">&sect;&nbsp;</a></span>extract_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a901dec3c3cb8a629f3f6230845fd4721">guarded_ptr</a> <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::extract_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the item using compare functor <code>pred</code>. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#cds_nonintrusive_MichaelHashMap_hp_extract">extract(K const&amp;)</a> but <code>pred</code> predicate is used for key comparing.</p>
<p><code>Less</code> functor has the semantics like <code>std::less</code> but should take arguments of type <code>key_type</code> and <code>K</code> in any order. <code>pred</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a id="a463d8d7851dedae6fcc0d9b0d82c2e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463d8d7851dedae6fcc0d9b0d82c2e6d">&sect;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>key</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_MichaelMap_find_cfunc"></a> The function searches the item with key equal to <code>key</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div><div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#a1b3d9027b2e6c87b01c3b65e3b1aed5a">value_type</a>&amp; item );</div><div class="line">};</div></div><!-- fragment --><p> where <code>item</code> is the item found.</p>
<p>The functor may change <code>item.second</code>. Note that the functor is only guarantee that <code>item</code> cannot be disposed during functor is executing. The functor does not serialize simultaneous access to the map's <code>item</code>. If such access is possible you must provide your own synchronization schema on item level to exclude unsafe item modifications.</p>
<p>The function returns <code>true</code> if <code>key</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a id="ae23d5652b1df274b63485b5c2e0da620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae23d5652b1df274b63485b5c2e0da620">&sect;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a> <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds <code>key</code> and returns iterator pointed to the item found (only for <code><a class="el" href="classcds_1_1container_1_1_iterable_list.html" title="Iterable ordered list. ">IterableList</a></code>) </p>
<p>If <code>key</code> is not found the function returns <code><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a6d2ff57ccf188ead667fdf511f89adf5" title="Returns an iterator that addresses the location succeeding the last element in a map. ">end()</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>This function is supported only for map based on <code><a class="el" href="classcds_1_1container_1_1_iterable_list.html" title="Iterable ordered list. ">IterableList</a></code> </dd></dl>

</div>
</div>
<a id="acfcdb0d94caf721d23c8d867f9e26336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfcdb0d94caf721d23c8d867f9e26336">&sect;&nbsp;</a></span>find_with() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#cds_nonintrusive_MichaelMap_find_cfunc">find(K const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a id="a5feab88822e30b8b253334843f3abf2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5feab88822e30b8b253334843f3abf2d">&sect;&nbsp;</a></span>find_with() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a> <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds <code>key</code> using <code>pred</code> predicate and returns iterator pointed to the item found (only for <code><a class="el" href="classcds_1_1container_1_1_iterable_list.html" title="Iterable ordered list. ">IterableList</a></code>) </p>
<p>The function is an analog of <code>find(K&amp;)</code> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the set.</p>
<p>If <code>key</code> is not found the function returns <code><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a6d2ff57ccf188ead667fdf511f89adf5" title="Returns an iterator that addresses the location succeeding the last element in a map. ">end()</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>This function is supported only for map based on <code><a class="el" href="classcds_1_1container_1_1_iterable_list.html" title="Iterable ordered list. ">IterableList</a></code> </dd></dl>

</div>
</div>
<a id="ae88464eafb958bd8df621ecf783e73c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88464eafb958bd8df621ecf783e73c5">&sect;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a901dec3c3cb8a629f3f6230845fd4721">guarded_ptr</a> <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::get </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds <code>key</code> and return the item found. </p>
<p><a class="anchor" id="cds_nonintrusive_MichaelHashMap_hp_get"></a>The function searches the item with key equal to <code>key</code> and returns the guarded pointer to the item found. If <code>key</code> is not found the function returns an empty guarded pointer,</p>
<dl class="section note"><dt>Note</dt><dd>Each <code>guarded_ptr</code> object uses one GC's guard which can be limited resource.</dd></dl>
<p>Usage: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> cds::container::MichaeHashMap&lt; your_template_params &gt;  michael_map;</div><div class="line">michael_map theMap;</div><div class="line"><span class="comment">// ...</span></div><div class="line">{</div><div class="line">    michael_map::guarded_ptr gp( theMap.get( 5 ));</div><div class="line">    <span class="keywordflow">if</span> ( gp ) {</div><div class="line">        <span class="comment">// Deal with gp</span></div><div class="line">        <span class="comment">//...</span></div><div class="line">    }</div><div class="line">    <span class="comment">// Destructor of guarded_ptr releases internal HP guard</span></div><div class="line">}</div></div><!-- fragment --><p>Note the compare functor specified for <code>OrderedList</code> template parameter should accept a parameter of type <code>K</code> that can be not the same as <code>key_type</code>. </p>

</div>
</div>
<a id="a41e2ae292ef69778acbf191c38b5c34c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41e2ae292ef69778acbf191c38b5c34c">&sect;&nbsp;</a></span>get_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a901dec3c3cb8a629f3f6230845fd4721">guarded_ptr</a> <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::get_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds <code>key</code> and return the item found. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#cds_nonintrusive_MichaelHashMap_hp_get">get( K const&amp;)</a> but <code>pred</code> is used for comparing the keys.</p>
<p><code>Less</code> functor has the semantics like <code>std::less</code> but should take arguments of type <code>key_type</code> and <code>K</code> in any order. <code>pred</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a id="ab89c19c4402799692b234d0c0958c78c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89c19c4402799692b234d0c0958c78c">&sect;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node with key and default value. </p>
<p>The function creates a node with <code>key</code> and default value, and then inserts the node created into the map.</p>
<p>Preconditions:</p><ul>
<li>The <code>key_type</code> should be constructible from value of type <code>K</code>. In trivial case, <code>K</code> is equal to <code>key_type</code>.</li>
<li>The <code>mapped_type</code> should be default-constructible.</li>
</ul>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise. </p>

</div>
</div>
<a id="a4764ab4d26d2d5fdbcf881e27becddb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4764ab4d26d2d5fdbcf881e27becddb7">&sect;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function creates a node with copy of <code>val</code> value and then inserts the node created into the map.</p>
<p>Preconditions:</p><ul>
<li>The <code>key_type</code> should be constructible from <code>key</code> of type <code>K</code>.</li>
<li>The <code>mapped_type</code> should be constructible from <code>val</code> of type <code>V</code>.</li>
</ul>
<p>Returns <code>true</code> if <code>val</code> is inserted into the map, <code>false</code> otherwise. </p>

</div>
</div>
<a id="a512d4f96f648f355c9341138747ac588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512d4f96f648f355c9341138747ac588">&sect;&nbsp;</a></span>insert_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::insert_with </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node and initialize it by a functor. </p>
<p>This function inserts new node with key <code>key</code> and if inserting is successful then it calls <code>func</code> functor with signature </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div><div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#a1b3d9027b2e6c87b01c3b65e3b1aed5a">value_type</a>&amp; item );</div><div class="line">};</div></div><!-- fragment --><p>The argument <code>item</code> of user-defined functor <code>func</code> is the reference to the map's item inserted:</p><ul>
<li><code>item.first</code> is a const reference to item's key that cannot be changed.</li>
<li><code>item.second</code> is a reference to item's value that may be changed.</li>
</ul>
<p>The user-defined functor is called only if inserting is successful.</p>
<p>The <code>key_type</code> should be constructible from value of type <code>K</code>.</p>
<p>The function allows to split creating of new item into two part:</p><ul>
<li>create item from <code>key</code>;</li>
<li>insert new item into the map;</li>
<li>if inserting is successful, initialize the value of item by calling <code>func</code> functor</li>
</ul>
<p>This can be useful if complete initialization of object of <code>mapped_type</code> is heavyweight and it is preferable that the initialization should be completed only if inserting is successful.</p>
<dl class="section warning"><dt>Warning</dt><dd>For <a class="el" href="classcds_1_1container_1_1_michael_k_v_list.html#cds_nonintrusive_MichaelKVList_gc">MichaelKVList</a> as the bucket see <a class="el" href="namespacecds_1_1intrusive.html#cds_intrusive_item_creating">insert item troubleshooting</a>. <a class="el" href="classcds_1_1container_1_1_lazy_k_v_list.html#cds_nonintrusive_LazyKVList_gc">LazyKVList</a> provides exclusive access to inserted item and does not require any node-level synchronization. </dd></dl>

</div>
</div>
<a id="a344bcc9b0cb057433f35f1b7633c25b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a344bcc9b0cb057433f35f1b7633c25b7">&sect;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::update </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowInsert</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates data by <code>key</code>. </p>
<p>The operation performs inserting or replacing the element with lock-free manner.</p>
<p>If the <code>key</code> not found in the map, then the new item created from <code>key</code> will be inserted into the map iff <code>bAllowInsert</code> is <code>true</code>. (note that in this case the <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a61ecea3df71f9893b4d9d1615e7863f2">key_type</a> should be constructible from type <code>K</code>). Otherwise, if <code>key</code> is found, the functor <code>func</code> is called with item found.</p>
<p>The functor <code>func</code> signature depends on <code>OrderedList:</code> </p>
<p><b>for <code><a class="el" href="classcds_1_1container_1_1_michael_k_v_list.html" title="Michael&#39;s ordered list for key-value pair. ">MichaelKVList</a></code>, <code><a class="el" href="classcds_1_1container_1_1_lazy_k_v_list.html" title="Lazy ordered list (key-value pair) ">LazyKVList</a></b></code> </p><div class="fragment"><div class="line"><span class="keyword">struct </span>my_functor {</div><div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#a1b3d9027b2e6c87b01c3b65e3b1aed5a">value_type</a>&amp; item );</div><div class="line">};</div></div><!-- fragment --><p> with arguments:</p><ul>
<li><code>bNew</code> - <code>true</code> if the item has been inserted, <code>false</code> otherwise</li>
<li><code>item</code> - the item found or inserted</li>
</ul>
<p>The functor may change any fields of the <code>item.second</code> that is <code>mapped_type</code>.</p>
<p><b>for <code><a class="el" href="classcds_1_1container_1_1_iterable_k_v_list.html" title="Iterable ordered list for key-value pair. ">IterableKVList</a></b></code> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#a1b3d9027b2e6c87b01c3b65e3b1aed5a">value_type</a>&amp; val, <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#a1b3d9027b2e6c87b01c3b65e3b1aed5a">value_type</a> * old );</div></div><!-- fragment --><p> where</p><ul>
<li><code>val</code> - a new data constructed from <code>key</code> </li>
<li><code>old</code> - old value that will be retired. If new item has been inserted then <code>old</code> is <code>nullptr</code>.</li>
</ul>
<p>The functor may change non-key fields of <code>val</code>; however, <code>func</code> must guarantee that during changing no any other modifications could be made on this item by concurrent threads.</p>
<dl class="section return"><dt>Returns</dt><dd><code> std::pair&lt;bool, bool&gt; </code> where <code>first</code> is true if operation is successful, <code>second</code> is true if new item has been added or <code>false</code> if the item with <code>key</code> already exists.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>For <a class="el" href="classcds_1_1container_1_1_michael_k_v_list.html#cds_nonintrusive_MichaelKVList_gc">MichaelKVList</a> and <a class="el" href="classcds_1_1container_1_1_iterable_k_v_list.html#cds_nonintrusive_IterableKVList_gc">IterableKVList</a> as the bucket see <a class="el" href="namespacecds_1_1intrusive.html#cds_intrusive_item_creating">insert item troubleshooting</a>. <a class="el" href="classcds_1_1container_1_1_lazy_k_v_list.html#cds_nonintrusive_LazyKVList_gc">LazyKVList</a> provides exclusive access to inserted item and does not require any node-level synchronization. </dd></dl>

</div>
</div>
<a id="ad27bc2c87dcb86836450f5f329508af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27bc2c87dcb86836450f5f329508af8">&sect;&nbsp;</a></span>upsert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::upsert </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowInsert</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts or updates the node (only for <code><a class="el" href="classcds_1_1container_1_1_iterable_k_v_list.html" title="Iterable ordered list for key-value pair. ">IterableKVList</a></code>) </p>
<p>The operation performs inserting or changing data with lock-free manner.</p>
<p>If <code>key</code> is not found in the map, then <code>key</code> is inserted iff <code>bAllowInsert</code> is <code>true</code>. Otherwise, the current element is changed to <code>val</code>, the old element will be retired later.</p>
<p>Returns std::pair&lt;bool, bool&gt; where <code>first</code> is <code>true</code> if operation is successful, <code>second</code> is <code>true</code> if <code>val</code> has been added or <code>false</code> if the item with that key already in the map. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/container/michael_map.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.2.0</b> 
  Developed by <i>Maxim Khizhinsky aka khizmax</i> 2007 - 2017
  <br/>
  <i>Autogenerated Wed Jan 4 2017 08:49:38 by Doxygen 1.8.12</i>
</div>
</body>
</html>
