<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cds: cds::container::SplitListMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::SplitListMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__nonintrusive__containers.html">Non-intrusive containers</a> &raquo; <a class="el" href="group__cds__nonintrusive__map.html">Map</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Split-ordered list map (template specialization for <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_desc">RCU</a>)  
 <a href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#details">More...</a></p>

<p><code>#include &lt;cds/container/split_list_map_rcu.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::container::SplitListMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.png" usemap="#cds::container::SplitListMap_3C_20cds::urcu::gc_3C_20RCU_20_3E_2C_20Key_2C_20Value_2C_20Traits_20_3E_map" alt=""/>
  <map id="cds::container::SplitListMap_3C_20cds::urcu::gc_3C_20RCU_20_3E_2C_20Key_2C_20Value_2C_20Traits_20_3E_map" name="cds::container::SplitListMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;_map">
<area href="classcds_1_1container_1_1_split_list_set.html" alt="cds::container::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, std::pair&lt; Key const, Value &gt;, split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt; &gt;" shape="rect" coords="0,56,1018,80"/>
<area href="classcds_1_1intrusive_1_1_split_list_set.html" alt="cds::intrusive::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt; ::ordered_list, split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt; &gt;" shape="rect" coords="0,0,1018,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aab17bead6a5a976f13d19ed61b239266"><td class="memItemLeft" align="right" valign="top"><a id="aab17bead6a5a976f13d19ed61b239266"></a>
typedef cds::urcu::gc&lt; RCU &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aab17bead6a5a976f13d19ed61b239266">gc</a></td></tr>
<tr class="memdesc:aab17bead6a5a976f13d19ed61b239266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br /></td></tr>
<tr class="separator:aab17bead6a5a976f13d19ed61b239266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e25dd8f881eb1af7bf624a64330ab18"><td class="memItemLeft" align="right" valign="top"><a id="a9e25dd8f881eb1af7bf624a64330ab18"></a>
typedef Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9e25dd8f881eb1af7bf624a64330ab18">key_type</a></td></tr>
<tr class="memdesc:a9e25dd8f881eb1af7bf624a64330ab18"><td class="mdescLeft">&#160;</td><td class="mdescRight">key type <br /></td></tr>
<tr class="separator:a9e25dd8f881eb1af7bf624a64330ab18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d1fdbb6c05b121221d300031c7ac19"><td class="memItemLeft" align="right" valign="top"><a id="a99d1fdbb6c05b121221d300031c7ac19"></a>
typedef Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a99d1fdbb6c05b121221d300031c7ac19">mapped_type</a></td></tr>
<tr class="memdesc:a99d1fdbb6c05b121221d300031c7ac19"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value to be stored in the map <br /></td></tr>
<tr class="separator:a99d1fdbb6c05b121221d300031c7ac19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d23be354cf94a60bf34b9c4b94a22a5"><td class="memItemLeft" align="right" valign="top"><a id="a8d23be354cf94a60bf34b9c4b94a22a5"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a8d23be354cf94a60bf34b9c4b94a22a5">traits</a></td></tr>
<tr class="memdesc:a8d23be354cf94a60bf34b9c4b94a22a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map traits. <br /></td></tr>
<tr class="separator:a8d23be354cf94a60bf34b9c4b94a22a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682405bbab11f0cd0287f763ac14f5a5"><td class="memItemLeft" align="right" valign="top"><a id="a682405bbab11f0cd0287f763ac14f5a5"></a>
typedef std::pair&lt; <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9e25dd8f881eb1af7bf624a64330ab18">key_type</a> const, <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a99d1fdbb6c05b121221d300031c7ac19">mapped_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a682405bbab11f0cd0287f763ac14f5a5">value_type</a></td></tr>
<tr class="memdesc:a682405bbab11f0cd0287f763ac14f5a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">key-value pair type <br /></td></tr>
<tr class="separator:a682405bbab11f0cd0287f763ac14f5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e33ceb9acfeec3ae22f3e54075bf40"><td class="memItemLeft" align="right" valign="top"><a id="ad4e33ceb9acfeec3ae22f3e54075bf40"></a>
typedef base_class::ordered_list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#ad4e33ceb9acfeec3ae22f3e54075bf40">ordered_list</a></td></tr>
<tr class="memdesc:ad4e33ceb9acfeec3ae22f3e54075bf40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying ordered list class. <br /></td></tr>
<tr class="separator:ad4e33ceb9acfeec3ae22f3e54075bf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bbdea9db64a3c1b833c13e8507dc2ee"><td class="memItemLeft" align="right" valign="top"><a id="a7bbdea9db64a3c1b833c13e8507dc2ee"></a>
typedef base_class::key_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a7bbdea9db64a3c1b833c13e8507dc2ee">key_comparator</a></td></tr>
<tr class="memdesc:a7bbdea9db64a3c1b833c13e8507dc2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparison functor <br /></td></tr>
<tr class="separator:a7bbdea9db64a3c1b833c13e8507dc2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f287833bda6211df83817d566d526d"><td class="memItemLeft" align="right" valign="top"><a id="ad3f287833bda6211df83817d566d526d"></a>
typedef base_class::hash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#ad3f287833bda6211df83817d566d526d">hash</a></td></tr>
<tr class="memdesc:ad3f287833bda6211df83817d566d526d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor for <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9e25dd8f881eb1af7bf624a64330ab18">key_type</a>. <br /></td></tr>
<tr class="separator:ad3f287833bda6211df83817d566d526d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6170d9bb565f6fb4441bd76131d61130"><td class="memItemLeft" align="right" valign="top"><a id="a6170d9bb565f6fb4441bd76131d61130"></a>
typedef base_class::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a6170d9bb565f6fb4441bd76131d61130">item_counter</a></td></tr>
<tr class="memdesc:a6170d9bb565f6fb4441bd76131d61130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter type. <br /></td></tr>
<tr class="separator:a6170d9bb565f6fb4441bd76131d61130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10f892fa310e8bfa8b72794f4584d5b"><td class="memItemLeft" align="right" valign="top"><a id="ae10f892fa310e8bfa8b72794f4584d5b"></a>
typedef base_class::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#ae10f892fa310e8bfa8b72794f4584d5b">stat</a></td></tr>
<tr class="memdesc:ae10f892fa310e8bfa8b72794f4584d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics. <br /></td></tr>
<tr class="separator:ae10f892fa310e8bfa8b72794f4584d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d21dad6f6df3f9fa8b2471c1664a8d"><td class="memItemLeft" align="right" valign="top"><a id="aa3d21dad6f6df3f9fa8b2471c1664a8d"></a>
typedef base_class::rcu_lock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa3d21dad6f6df3f9fa8b2471c1664a8d">rcu_lock</a></td></tr>
<tr class="memdesc:aa3d21dad6f6df3f9fa8b2471c1664a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">RCU scoped lock. <br /></td></tr>
<tr class="separator:aa3d21dad6f6df3f9fa8b2471c1664a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b237bfaeb025412114274e5ca57b14"><td class="memItemLeft" align="right" valign="top">typedef base_class::exempt_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#af2b237bfaeb025412114274e5ca57b14">exempt_ptr</a></td></tr>
<tr class="separator:af2b237bfaeb025412114274e5ca57b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa307bb5de70335cf963bb9195017f62"><td class="memItemLeft" align="right" valign="top"><a id="afa307bb5de70335cf963bb9195017f62"></a>
typedef base_class::raw_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#afa307bb5de70335cf963bb9195017f62">raw_ptr</a></td></tr>
<tr class="memdesc:afa307bb5de70335cf963bb9195017f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of <code><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aeee9a675a958ee274c2de200432a00ca" title="Finds key and return the item found. ">get()</a></code> return value <br /></td></tr>
<tr class="separator:afa307bb5de70335cf963bb9195017f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91b81aead03e9460711e566824a2713"><td class="memItemLeft" align="right" valign="top"><a id="aa91b81aead03e9460711e566824a2713"></a>
typedef base_class::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a></td></tr>
<tr class="memdesc:aa91b81aead03e9460711e566824a2713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward iterator. <br /></td></tr>
<tr class="separator:aa91b81aead03e9460711e566824a2713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9039192cd438d5b60e8583d510f79e9f"><td class="memItemLeft" align="right" valign="top"><a id="a9039192cd438d5b60e8583d510f79e9f"></a>
typedef base_class::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9039192cd438d5b60e8583d510f79e9f">const_iterator</a></td></tr>
<tr class="memdesc:a9039192cd438d5b60e8583d510f79e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const forward iterator. <br /></td></tr>
<tr class="separator:a9039192cd438d5b60e8583d510f79e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2e9a7ffed701fe108e98e27790782042"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a2e9a7ffed701fe108e98e27790782042">begin</a> ()</td></tr>
<tr class="memdesc:a2e9a7ffed701fe108e98e27790782042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator addressing the first element in a map.  <a href="#a2e9a7ffed701fe108e98e27790782042">More...</a><br /></td></tr>
<tr class="separator:a2e9a7ffed701fe108e98e27790782042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9411b38419a5dc5ce92ba48f48339e52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9411b38419a5dc5ce92ba48f48339e52">end</a> ()</td></tr>
<tr class="memdesc:a9411b38419a5dc5ce92ba48f48339e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator that addresses the location succeeding the last element in a map.  <a href="#a9411b38419a5dc5ce92ba48f48339e52">More...</a><br /></td></tr>
<tr class="separator:a9411b38419a5dc5ce92ba48f48339e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0392614ddcd0ada7bb78136dc97bbc85"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a0392614ddcd0ada7bb78136dc97bbc85">SplitListMap</a> ()</td></tr>
<tr class="memdesc:a0392614ddcd0ada7bb78136dc97bbc85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes split-ordered map of default capacity.  <a href="#a0392614ddcd0ada7bb78136dc97bbc85">More...</a><br /></td></tr>
<tr class="separator:a0392614ddcd0ada7bb78136dc97bbc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bcf30da24623b50f97a1f5e49e2bc55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a4bcf30da24623b50f97a1f5e49e2bc55">SplitListMap</a> (size_t nItemCount, size_t nLoadFactor=1)</td></tr>
<tr class="memdesc:a4bcf30da24623b50f97a1f5e49e2bc55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes split-ordered map.  <a href="#a4bcf30da24623b50f97a1f5e49e2bc55">More...</a><br /></td></tr>
<tr class="separator:a4bcf30da24623b50f97a1f5e49e2bc55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9732e42943b07d8e216d25c42def7f01"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a9732e42943b07d8e216d25c42def7f01"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9732e42943b07d8e216d25c42def7f01">insert</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a9732e42943b07d8e216d25c42def7f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node with key and default value.  <a href="#a9732e42943b07d8e216d25c42def7f01">More...</a><br /></td></tr>
<tr class="separator:a9732e42943b07d8e216d25c42def7f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e1da831a875c8ef38964f7a63d68fb"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a37e1da831a875c8ef38964f7a63d68fb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a37e1da831a875c8ef38964f7a63d68fb">insert</a> (K const &amp;key, V const &amp;val)</td></tr>
<tr class="memdesc:a37e1da831a875c8ef38964f7a63d68fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a37e1da831a875c8ef38964f7a63d68fb">More...</a><br /></td></tr>
<tr class="separator:a37e1da831a875c8ef38964f7a63d68fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977a9f295cffc445355b5ac4c23bdf39"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a977a9f295cffc445355b5ac4c23bdf39"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a977a9f295cffc445355b5ac4c23bdf39">insert_with</a> (K const &amp;key, Func func)</td></tr>
<tr class="memdesc:a977a9f295cffc445355b5ac4c23bdf39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node and initialize it by a functor.  <a href="#a977a9f295cffc445355b5ac4c23bdf39">More...</a><br /></td></tr>
<tr class="separator:a977a9f295cffc445355b5ac4c23bdf39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3748adb0dfa0fb4c905cf923951762d1"><td class="memTemplParams" colspan="2">template&lt;typename K , typename... Args&gt; </td></tr>
<tr class="memitem:a3748adb0dfa0fb4c905cf923951762d1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a3748adb0dfa0fb4c905cf923951762d1">emplace</a> (K &amp;&amp;key, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3748adb0dfa0fb4c905cf923951762d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">For key <code>key</code> inserts data of type <code>mapped_type</code> created in-place from <code>args</code>.  <a href="#a3748adb0dfa0fb4c905cf923951762d1">More...</a><br /></td></tr>
<tr class="separator:a3748adb0dfa0fb4c905cf923951762d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04090173571564ec3983bd37b19699bb"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a04090173571564ec3983bd37b19699bb"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a04090173571564ec3983bd37b19699bb">update</a> (K const &amp;key, Func func, bool bAllowInsert=true)</td></tr>
<tr class="memdesc:a04090173571564ec3983bd37b19699bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates data by <code>key</code>.  <a href="#a04090173571564ec3983bd37b19699bb">More...</a><br /></td></tr>
<tr class="separator:a04090173571564ec3983bd37b19699bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb1f2b166d2b12f9f2a84344e264003"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:aebb1f2b166d2b12f9f2a84344e264003"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aebb1f2b166d2b12f9f2a84344e264003">erase</a> (K const &amp;key)</td></tr>
<tr class="memdesc:aebb1f2b166d2b12f9f2a84344e264003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes <code>key</code> from the map.  <a href="#aebb1f2b166d2b12f9f2a84344e264003">More...</a><br /></td></tr>
<tr class="separator:aebb1f2b166d2b12f9f2a84344e264003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6674c5f0b6b4f0f523fcd4cba878c0"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a6e6674c5f0b6b4f0f523fcd4cba878c0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a6e6674c5f0b6b4f0f523fcd4cba878c0">erase_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a6e6674c5f0b6b4f0f523fcd4cba878c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the map using <code>pred</code> predicate for searching.  <a href="#a6e6674c5f0b6b4f0f523fcd4cba878c0">More...</a><br /></td></tr>
<tr class="separator:a6e6674c5f0b6b4f0f523fcd4cba878c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0d10489ab3ad0da3fd7ed9aa32e994"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a4e0d10489ab3ad0da3fd7ed9aa32e994"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a4e0d10489ab3ad0da3fd7ed9aa32e994">erase</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:a4e0d10489ab3ad0da3fd7ed9aa32e994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes <code>key</code> from the map.  <a href="#a4e0d10489ab3ad0da3fd7ed9aa32e994">More...</a><br /></td></tr>
<tr class="separator:a4e0d10489ab3ad0da3fd7ed9aa32e994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93282b6aba0332c6fce60c3fedf23115"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a93282b6aba0332c6fce60c3fedf23115"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a93282b6aba0332c6fce60c3fedf23115">erase_with</a> (K const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:a93282b6aba0332c6fce60c3fedf23115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the map using <code>pred</code> predicate for searching.  <a href="#a93282b6aba0332c6fce60c3fedf23115">More...</a><br /></td></tr>
<tr class="separator:a93282b6aba0332c6fce60c3fedf23115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d26ad0509a27b9c8ce94e2ef84aab8"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a42d26ad0509a27b9c8ce94e2ef84aab8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#af2b237bfaeb025412114274e5ca57b14">exempt_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a42d26ad0509a27b9c8ce94e2ef84aab8">extract</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a42d26ad0509a27b9c8ce94e2ef84aab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item from the map.  <a href="#a42d26ad0509a27b9c8ce94e2ef84aab8">More...</a><br /></td></tr>
<tr class="separator:a42d26ad0509a27b9c8ce94e2ef84aab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1f93f1f491242438c6ba9071fd0f69"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a7d1f93f1f491242438c6ba9071fd0f69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#af2b237bfaeb025412114274e5ca57b14">exempt_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a7d1f93f1f491242438c6ba9071fd0f69">extract_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a7d1f93f1f491242438c6ba9071fd0f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item from the map using <code>pred</code> predicate for searching.  <a href="#a7d1f93f1f491242438c6ba9071fd0f69">More...</a><br /></td></tr>
<tr class="separator:a7d1f93f1f491242438c6ba9071fd0f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b497490353d85557018c5b908f82f0"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:ab1b497490353d85557018c5b908f82f0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#ab1b497490353d85557018c5b908f82f0">find</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:ab1b497490353d85557018c5b908f82f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code>.  <a href="#ab1b497490353d85557018c5b908f82f0">More...</a><br /></td></tr>
<tr class="separator:ab1b497490353d85557018c5b908f82f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad593abbddb349e7e7d5642269f70d0cd"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:ad593abbddb349e7e7d5642269f70d0cd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#ad593abbddb349e7e7d5642269f70d0cd">find_with</a> (K const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:ad593abbddb349e7e7d5642269f70d0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code> using <code>pred</code> predicate for searching.  <a href="#ad593abbddb349e7e7d5642269f70d0cd">More...</a><br /></td></tr>
<tr class="separator:ad593abbddb349e7e7d5642269f70d0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961195d3d1094db952437c69c7be9767"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a961195d3d1094db952437c69c7be9767"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a961195d3d1094db952437c69c7be9767">contains</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a961195d3d1094db952437c69c7be9767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the map contains <code>key</code>.  <a href="#a961195d3d1094db952437c69c7be9767">More...</a><br /></td></tr>
<tr class="separator:a961195d3d1094db952437c69c7be9767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6070cade4eb1619e92abf568b7d1659d"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a6070cade4eb1619e92abf568b7d1659d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a6070cade4eb1619e92abf568b7d1659d">contains</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a6070cade4eb1619e92abf568b7d1659d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the map contains <code>key</code> using <code>pred</code> predicate for searching.  <a href="#a6070cade4eb1619e92abf568b7d1659d">More...</a><br /></td></tr>
<tr class="separator:a6070cade4eb1619e92abf568b7d1659d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee9a675a958ee274c2de200432a00ca"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:aeee9a675a958ee274c2de200432a00ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#afa307bb5de70335cf963bb9195017f62">raw_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aeee9a675a958ee274c2de200432a00ca">get</a> (K const &amp;key)</td></tr>
<tr class="memdesc:aeee9a675a958ee274c2de200432a00ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> and return the item found.  <a href="#aeee9a675a958ee274c2de200432a00ca">More...</a><br /></td></tr>
<tr class="separator:aeee9a675a958ee274c2de200432a00ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bee6446a58cf200ac613d54c24c8b9a"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a9bee6446a58cf200ac613d54c24c8b9a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#afa307bb5de70335cf963bb9195017f62">raw_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9bee6446a58cf200ac613d54c24c8b9a">get_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a9bee6446a58cf200ac613d54c24c8b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> with predicate specified and return the item found.  <a href="#a9bee6446a58cf200ac613d54c24c8b9a">More...</a><br /></td></tr>
<tr class="separator:a9bee6446a58cf200ac613d54c24c8b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bba93ee1391b60e4155702a3f32fbf"><td class="memItemLeft" align="right" valign="top"><a id="a22bba93ee1391b60e4155702a3f32fbf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a22bba93ee1391b60e4155702a3f32fbf">clear</a> ()</td></tr>
<tr class="memdesc:a22bba93ee1391b60e4155702a3f32fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the map (not atomic) <br /></td></tr>
<tr class="separator:a22bba93ee1391b60e4155702a3f32fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b521c0358541175621a2420f369495"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a90b521c0358541175621a2420f369495">empty</a> () const</td></tr>
<tr class="memdesc:a90b521c0358541175621a2420f369495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the map is empty.  <a href="#a90b521c0358541175621a2420f369495">More...</a><br /></td></tr>
<tr class="separator:a90b521c0358541175621a2420f369495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73661e05bd90a7dae8abf53b3c994e1a"><td class="memItemLeft" align="right" valign="top"><a id="a73661e05bd90a7dae8abf53b3c994e1a"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a73661e05bd90a7dae8abf53b3c994e1a">size</a> () const</td></tr>
<tr class="memdesc:a73661e05bd90a7dae8abf53b3c994e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the map. <br /></td></tr>
<tr class="separator:a73661e05bd90a7dae8abf53b3c994e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56179fff1fbdbc8a125298e6687ccd3d"><td class="memItemLeft" align="right" valign="top"><a id="a56179fff1fbdbc8a125298e6687ccd3d"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#ae10f892fa310e8bfa8b72794f4584d5b">stat</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a56179fff1fbdbc8a125298e6687ccd3d">statistics</a> () const</td></tr>
<tr class="memdesc:a56179fff1fbdbc8a125298e6687ccd3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns internal statistics. <br /></td></tr>
<tr class="separator:a56179fff1fbdbc8a125298e6687ccd3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9156fdd36cb9fff402414d0138e2b466"><td class="memItemLeft" align="right" valign="top"><a id="a9156fdd36cb9fff402414d0138e2b466"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_map.html#a42a1ea3ebcc4cae7b8570a3b43564167">ordered_list::stat</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9156fdd36cb9fff402414d0138e2b466">list_statistics</a> () const</td></tr>
<tr class="memdesc:a9156fdd36cb9fff402414d0138e2b466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns internal statistics for <code>ordered_list</code>. <br /></td></tr>
<tr class="separator:a9156fdd36cb9fff402414d0138e2b466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8be02c5db939d294100b542a281efa00"><td class="memItemLeft" align="right" valign="top"><a id="a8be02c5db939d294100b542a281efa00"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9039192cd438d5b60e8583d510f79e9f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a8be02c5db939d294100b542a281efa00">begin</a> () const</td></tr>
<tr class="memdesc:a8be02c5db939d294100b542a281efa00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a map. <br /></td></tr>
<tr class="separator:a8be02c5db939d294100b542a281efa00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f39805181868c3d42a46be5ff93323"><td class="memItemLeft" align="right" valign="top"><a id="a11f39805181868c3d42a46be5ff93323"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9039192cd438d5b60e8583d510f79e9f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> () const</td></tr>
<tr class="separator:a11f39805181868c3d42a46be5ff93323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a10bec257d53bffb3f6f43422791bc4f7"><td class="memItemLeft" align="right" valign="top"><a id="a10bec257d53bffb3f6f43422791bc4f7"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9039192cd438d5b60e8583d510f79e9f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a10bec257d53bffb3f6f43422791bc4f7">end</a> () const</td></tr>
<tr class="memdesc:a10bec257d53bffb3f6f43422791bc4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator that addresses the location succeeding the last element in a map. <br /></td></tr>
<tr class="separator:a10bec257d53bffb3f6f43422791bc4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab2d34b92c97096cac9f5cccf7e0e1b"><td class="memItemLeft" align="right" valign="top"><a id="a8ab2d34b92c97096cac9f5cccf7e0e1b"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9039192cd438d5b60e8583d510f79e9f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> () const</td></tr>
<tr class="separator:a8ab2d34b92c97096cac9f5cccf7e0e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a9e7433d0460d1c7dbae0d40bcee89c1e"><td class="memItemLeft" align="right" valign="top"><a id="a9e7433d0460d1c7dbae0d40bcee89c1e"></a>
static constexpr const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9e7433d0460d1c7dbae0d40bcee89c1e">c_bExtractLockExternal</a> = base_class::c_bExtractLockExternal</td></tr>
<tr class="memdesc:a9e7433d0460d1c7dbae0d40bcee89c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group of <code>extract_xxx</code> functions require external locking if underlying ordered list requires that. <br /></td></tr>
<tr class="separator:a9e7433d0460d1c7dbae0d40bcee89c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_types_classcds_1_1container_1_1_split_list_set"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classcds_1_1container_1_1_split_list_set')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, std::pair&lt; Key const, Value &gt;, split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt; &gt;</a></td></tr>
<tr class="memitem:a7b2c74a504580b5971e333db4c29248d inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a7b2c74a504580b5971e333db4c29248d"></a>
typedef cds::urcu::gc&lt; RCU &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a7b2c74a504580b5971e333db4c29248d">gc</a></td></tr>
<tr class="memdesc:a7b2c74a504580b5971e333db4c29248d inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br /></td></tr>
<tr class="separator:a7b2c74a504580b5971e333db4c29248d inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb30a4ce7b104b6cea584e4987029aeb inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="acb30a4ce7b104b6cea584e4987029aeb"></a>
typedef std::pair&lt; Key const, Value &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#acb30a4ce7b104b6cea584e4987029aeb">value_type</a></td></tr>
<tr class="memdesc:acb30a4ce7b104b6cea584e4987029aeb inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of vlue to be stored in split-list. <br /></td></tr>
<tr class="separator:acb30a4ce7b104b6cea584e4987029aeb inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b05520aea1e3dab4ae7bb080df7c9d5 inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a5b05520aea1e3dab4ae7bb080df7c9d5"></a>
typedef split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a5b05520aea1e3dab4ae7bb080df7c9d5">traits</a></td></tr>
<tr class="memdesc:a5b05520aea1e3dab4ae7bb080df7c9d5 inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>Traits</code> template argument <br /></td></tr>
<tr class="separator:a5b05520aea1e3dab4ae7bb080df7c9d5 inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843cd4ac855f36a0ea09b2a91318533e inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a843cd4ac855f36a0ea09b2a91318533e"></a>
typedef maker::ordered_list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a843cd4ac855f36a0ea09b2a91318533e">ordered_list</a></td></tr>
<tr class="memdesc:a843cd4ac855f36a0ea09b2a91318533e inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying ordered list class. <br /></td></tr>
<tr class="separator:a843cd4ac855f36a0ea09b2a91318533e inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5497c22d61d56489cbca457a5e7f047 inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="af5497c22d61d56489cbca457a5e7f047"></a>
typedef base_class::key_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#af5497c22d61d56489cbca457a5e7f047">key_comparator</a></td></tr>
<tr class="memdesc:af5497c22d61d56489cbca457a5e7f047 inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">key compare functor <br /></td></tr>
<tr class="separator:af5497c22d61d56489cbca457a5e7f047 inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2ab388cbeccec46d1dc63e66ea5ec7 inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="aaa2ab388cbeccec46d1dc63e66ea5ec7"></a>
typedef base_class::hash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#aaa2ab388cbeccec46d1dc63e66ea5ec7">hash</a></td></tr>
<tr class="memdesc:aaa2ab388cbeccec46d1dc63e66ea5ec7 inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor for <code>value_type</code> and all its derivatives that you use. <br /></td></tr>
<tr class="separator:aaa2ab388cbeccec46d1dc63e66ea5ec7 inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0847071460189800f9002e2d03ef99 inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a7b0847071460189800f9002e2d03ef99"></a>
typedef base_class::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a7b0847071460189800f9002e2d03ef99">item_counter</a></td></tr>
<tr class="memdesc:a7b0847071460189800f9002e2d03ef99 inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter type. <br /></td></tr>
<tr class="separator:a7b0847071460189800f9002e2d03ef99 inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39196ac90597908219c5b130b37f47c inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="ad39196ac90597908219c5b130b37f47c"></a>
typedef base_class::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ad39196ac90597908219c5b130b37f47c">stat</a></td></tr>
<tr class="memdesc:ad39196ac90597908219c5b130b37f47c inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics. <br /></td></tr>
<tr class="separator:ad39196ac90597908219c5b130b37f47c inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a910658827d385bc3ee5564bfa1c05 inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="ab1a910658827d385bc3ee5564bfa1c05"></a>
typedef gc::template <a class="el" href="classcds_1_1container_1_1_split_list_set.html#ab1a910658827d385bc3ee5564bfa1c05">guarded_ptr</a>&lt; node_type, <a class="el" href="classcds_1_1container_1_1_split_list_set.html#acb30a4ce7b104b6cea584e4987029aeb">value_type</a>, details::guarded_ptr_cast_set&lt; node_type, <a class="el" href="classcds_1_1container_1_1_split_list_set.html#acb30a4ce7b104b6cea584e4987029aeb">value_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ab1a910658827d385bc3ee5564bfa1c05">guarded_ptr</a></td></tr>
<tr class="memdesc:ab1a910658827d385bc3ee5564bfa1c05 inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded pointer. <br /></td></tr>
<tr class="separator:ab1a910658827d385bc3ee5564bfa1c05 inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb1e96121f36af3252e2aa1ea09ff1b inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">typedef iterator_type&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a3bb1e96121f36af3252e2aa1ea09ff1b">iterator</a></td></tr>
<tr class="memdesc:a3bb1e96121f36af3252e2aa1ea09ff1b inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward iterator.  <a href="classcds_1_1container_1_1_split_list_set.html#a3bb1e96121f36af3252e2aa1ea09ff1b">More...</a><br /></td></tr>
<tr class="separator:a3bb1e96121f36af3252e2aa1ea09ff1b inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944c54c5061ce4d8d2b04dbe1dea152f inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a944c54c5061ce4d8d2b04dbe1dea152f"></a>
typedef iterator_type&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a944c54c5061ce4d8d2b04dbe1dea152f">const_iterator</a></td></tr>
<tr class="memdesc:a944c54c5061ce4d8d2b04dbe1dea152f inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const forward iterator. <br /></td></tr>
<tr class="separator:a944c54c5061ce4d8d2b04dbe1dea152f inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_classcds_1_1intrusive_1_1_split_list_set"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classcds_1_1intrusive_1_1_split_list_set')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html">cds::intrusive::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt; ::ordered_list, split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt; &gt;</a></td></tr>
<tr class="memitem:aea2de69bd86f37bd184ca50d50e29f0e inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="aea2de69bd86f37bd184ca50d50e29f0e"></a>
typedef cds::urcu::gc&lt; RCU &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#aea2de69bd86f37bd184ca50d50e29f0e">gc</a></td></tr>
<tr class="memdesc:aea2de69bd86f37bd184ca50d50e29f0e inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br /></td></tr>
<tr class="separator:aea2de69bd86f37bd184ca50d50e29f0e inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8244c115c0dd6b116c9edb9a456c2ee inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="ab8244c115c0dd6b116c9edb9a456c2ee"></a>
typedef split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#ab8244c115c0dd6b116c9edb9a456c2ee">traits</a></td></tr>
<tr class="memdesc:ab8244c115c0dd6b116c9edb9a456c2ee inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set traits. <br /></td></tr>
<tr class="separator:ab8244c115c0dd6b116c9edb9a456c2ee inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719263aaf48921d5ced55707389f961a inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a719263aaf48921d5ced55707389f961a"></a>
typedef split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt; ::<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a719263aaf48921d5ced55707389f961a">ordered_list</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a719263aaf48921d5ced55707389f961a">ordered_list</a></td></tr>
<tr class="memdesc:a719263aaf48921d5ced55707389f961a inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of ordered list used as a base for split-list <br /></td></tr>
<tr class="separator:a719263aaf48921d5ced55707389f961a inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae9f358f06403565d75e8a6666e0f8f inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="afae9f358f06403565d75e8a6666e0f8f"></a>
typedef ordered_list::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#afae9f358f06403565d75e8a6666e0f8f">value_type</a></td></tr>
<tr class="memdesc:afae9f358f06403565d75e8a6666e0f8f inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the split-list <br /></td></tr>
<tr class="separator:afae9f358f06403565d75e8a6666e0f8f inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ac7447e2749a53db596bef99378f0a inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="ac4ac7447e2749a53db596bef99378f0a"></a>
typedef ordered_list::key_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#ac4ac7447e2749a53db596bef99378f0a">key_comparator</a></td></tr>
<tr class="memdesc:ac4ac7447e2749a53db596bef99378f0a inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparison functor <br /></td></tr>
<tr class="separator:ac4ac7447e2749a53db596bef99378f0a inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4cfc2f23920086d62cef263e4b4f879 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="aa4cfc2f23920086d62cef263e4b4f879"></a>
typedef ordered_list::disposer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#aa4cfc2f23920086d62cef263e4b4f879">disposer</a></td></tr>
<tr class="memdesc:aa4cfc2f23920086d62cef263e4b4f879 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node disposer functor. <br /></td></tr>
<tr class="separator:aa4cfc2f23920086d62cef263e4b4f879 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1255a3a554c960d60f7c07d8c0d71b9 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="af1255a3a554c960d60f7c07d8c0d71b9"></a>
typedef cds::opt::v::hash_selector&lt; typename traits::hash &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#af1255a3a554c960d60f7c07d8c0d71b9">hash</a></td></tr>
<tr class="memdesc:af1255a3a554c960d60f7c07d8c0d71b9 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor for <code>value_type</code> and all its derivatives you use. <br /></td></tr>
<tr class="separator:af1255a3a554c960d60f7c07d8c0d71b9 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1562c4a7ce60945722157d589606eb0 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="aa1562c4a7ce60945722157d589606eb0"></a>
typedef traits::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#aa1562c4a7ce60945722157d589606eb0">item_counter</a></td></tr>
<tr class="memdesc:aa1562c4a7ce60945722157d589606eb0 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter type. <br /></td></tr>
<tr class="separator:aa1562c4a7ce60945722157d589606eb0 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69886a6028245b341ac8dfaaaf70a40 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="ab69886a6028245b341ac8dfaaaf70a40"></a>
typedef traits::back_off&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#ab69886a6028245b341ac8dfaaaf70a40">back_off</a></td></tr>
<tr class="memdesc:ab69886a6028245b341ac8dfaaaf70a40 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">back-off strategy for spinning <br /></td></tr>
<tr class="separator:ab69886a6028245b341ac8dfaaaf70a40 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac781a58af799ac8bcfeb5027d1b03536 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="ac781a58af799ac8bcfeb5027d1b03536"></a>
typedef traits::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#ac781a58af799ac8bcfeb5027d1b03536">memory_model</a></td></tr>
<tr class="memdesc:ac781a58af799ac8bcfeb5027d1b03536 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering. See <code><a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">cds::opt::memory_model</a></code> option. <br /></td></tr>
<tr class="separator:ac781a58af799ac8bcfeb5027d1b03536 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3b57584e1fd7f743b1ab806c138a72 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a6b3b57584e1fd7f743b1ab806c138a72"></a>
typedef traits::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a6b3b57584e1fd7f743b1ab806c138a72">stat</a></td></tr>
<tr class="memdesc:a6b3b57584e1fd7f743b1ab806c138a72 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics, see <code>spit_list::stat</code>. <br /></td></tr>
<tr class="separator:a6b3b57584e1fd7f743b1ab806c138a72 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0933c1b9d510566c2538779f1ad81e14 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a0933c1b9d510566c2538779f1ad81e14"></a>
typedef ordered_list::guarded_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a0933c1b9d510566c2538779f1ad81e14">guarded_ptr</a></td></tr>
<tr class="memdesc:a0933c1b9d510566c2538779f1ad81e14 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded pointer. <br /></td></tr>
<tr class="separator:a0933c1b9d510566c2538779f1ad81e14 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c70b5bacc4b3d7d69efbf122f4d2c0b inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">typedef iterator_type&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a2c70b5bacc4b3d7d69efbf122f4d2c0b">iterator</a></td></tr>
<tr class="memdesc:a2c70b5bacc4b3d7d69efbf122f4d2c0b inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward iterator.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a2c70b5bacc4b3d7d69efbf122f4d2c0b">More...</a><br /></td></tr>
<tr class="separator:a2c70b5bacc4b3d7d69efbf122f4d2c0b inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6498e34acc524dd27767347acefbdb inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">typedef iterator_type&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a1e6498e34acc524dd27767347acefbdb">const_iterator</a></td></tr>
<tr class="memdesc:a1e6498e34acc524dd27767347acefbdb inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const forward iterator.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a1e6498e34acc524dd27767347acefbdb">More...</a><br /></td></tr>
<tr class="separator:a1e6498e34acc524dd27767347acefbdb inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classcds_1_1container_1_1_split_list_set"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classcds_1_1container_1_1_split_list_set')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, std::pair&lt; Key const, Value &gt;, split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt; &gt;</a></td></tr>
<tr class="memitem:aa5670755719b66f046d52f43292a0611 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#aa5670755719b66f046d52f43292a0611">SplitListSet</a> ()</td></tr>
<tr class="memdesc:aa5670755719b66f046d52f43292a0611 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes split-ordered list of default capacity.  <a href="classcds_1_1container_1_1_split_list_set.html#aa5670755719b66f046d52f43292a0611">More...</a><br /></td></tr>
<tr class="separator:aa5670755719b66f046d52f43292a0611 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16928087454c9e0ac58e2eb94a2346b2 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a16928087454c9e0ac58e2eb94a2346b2">SplitListSet</a> (size_t nItemCount, size_t nLoadFactor=1)</td></tr>
<tr class="memdesc:a16928087454c9e0ac58e2eb94a2346b2 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes split-ordered list.  <a href="classcds_1_1container_1_1_split_list_set.html#a16928087454c9e0ac58e2eb94a2346b2">More...</a><br /></td></tr>
<tr class="separator:a16928087454c9e0ac58e2eb94a2346b2 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a8790c2df3bd4a2eb31890c87ff036 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ac5a8790c2df3bd4a2eb31890c87ff036">insert</a> (Q &amp;&amp;val)</td></tr>
<tr class="memdesc:ac5a8790c2df3bd4a2eb31890c87ff036 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="classcds_1_1container_1_1_split_list_set.html#ac5a8790c2df3bd4a2eb31890c87ff036">More...</a><br /></td></tr>
<tr class="separator:ac5a8790c2df3bd4a2eb31890c87ff036 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467a3977bba0540cfc5c045d53b7c87a inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a467a3977bba0540cfc5c045d53b7c87a">insert</a> (Q &amp;&amp;val, Func f)</td></tr>
<tr class="memdesc:a467a3977bba0540cfc5c045d53b7c87a inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="classcds_1_1container_1_1_split_list_set.html#a467a3977bba0540cfc5c045d53b7c87a">More...</a><br /></td></tr>
<tr class="separator:a467a3977bba0540cfc5c045d53b7c87a inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67f6844ae57154b69f2b2de17737f67 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ae67f6844ae57154b69f2b2de17737f67">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ae67f6844ae57154b69f2b2de17737f67 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts data of type <code>value_type</code> created from <code>args</code>.  <a href="classcds_1_1container_1_1_split_list_set.html#ae67f6844ae57154b69f2b2de17737f67">More...</a><br /></td></tr>
<tr class="separator:ae67f6844ae57154b69f2b2de17737f67 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704763f17b0ed46a27988034acddb7b6 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a704763f17b0ed46a27988034acddb7b6">upsert</a> (Q &amp;&amp;val, bool bAllowInsert=true)</td></tr>
<tr class="memdesc:a704763f17b0ed46a27988034acddb7b6 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts or updates the node (only for <code>IterableList</code> -based set)  <a href="classcds_1_1container_1_1_split_list_set.html#a704763f17b0ed46a27988034acddb7b6">More...</a><br /></td></tr>
<tr class="separator:a704763f17b0ed46a27988034acddb7b6 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b0a3635aef36dd9e27d57765236977 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ae0b0a3635aef36dd9e27d57765236977">update</a> (Q &amp;&amp;val, Func func, bool bAllowInsert=true)</td></tr>
<tr class="memdesc:ae0b0a3635aef36dd9e27d57765236977 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the node.  <a href="classcds_1_1container_1_1_split_list_set.html#ae0b0a3635aef36dd9e27d57765236977">More...</a><br /></td></tr>
<tr class="separator:ae0b0a3635aef36dd9e27d57765236977 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79de44e57ed7a992995eb9d81cfb41e inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ab79de44e57ed7a992995eb9d81cfb41e">erase</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:ab79de44e57ed7a992995eb9d81cfb41e inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes <code>key</code> from the set.  <a href="classcds_1_1container_1_1_split_list_set.html#ab79de44e57ed7a992995eb9d81cfb41e">More...</a><br /></td></tr>
<tr class="separator:ab79de44e57ed7a992995eb9d81cfb41e inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1e1f60b52aeab4963ff44d17f2f347 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a5b1e1f60b52aeab4963ff44d17f2f347">erase</a> (Q const &amp;key, Func f)</td></tr>
<tr class="memdesc:a5b1e1f60b52aeab4963ff44d17f2f347 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes <code>key</code> from the set.  <a href="classcds_1_1container_1_1_split_list_set.html#a5b1e1f60b52aeab4963ff44d17f2f347">More...</a><br /></td></tr>
<tr class="separator:a5b1e1f60b52aeab4963ff44d17f2f347 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd6216eb4f162b274299a6e31c5713c inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#afcd6216eb4f162b274299a6e31c5713c">erase_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:afcd6216eb4f162b274299a6e31c5713c inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="classcds_1_1container_1_1_split_list_set.html#afcd6216eb4f162b274299a6e31c5713c">More...</a><br /></td></tr>
<tr class="separator:afcd6216eb4f162b274299a6e31c5713c inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac564ef5c7e381397898aa53b83c58d58 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ac564ef5c7e381397898aa53b83c58d58">erase_with</a> (Q const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:ac564ef5c7e381397898aa53b83c58d58 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="classcds_1_1container_1_1_split_list_set.html#ac564ef5c7e381397898aa53b83c58d58">More...</a><br /></td></tr>
<tr class="separator:ac564ef5c7e381397898aa53b83c58d58 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7636eacfce8c2960b7775a342938292 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ab1a910658827d385bc3ee5564bfa1c05">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ab7636eacfce8c2960b7775a342938292">extract</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:ab7636eacfce8c2960b7775a342938292 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item with specified <code>key</code>.  <a href="classcds_1_1container_1_1_split_list_set.html#ab7636eacfce8c2960b7775a342938292">More...</a><br /></td></tr>
<tr class="separator:ab7636eacfce8c2960b7775a342938292 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fec9dee7ee988e20549d3a3aa53c27 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ab1a910658827d385bc3ee5564bfa1c05">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a97fec9dee7ee988e20549d3a3aa53c27">extract_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a97fec9dee7ee988e20549d3a3aa53c27 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item using compare functor <code>pred</code>.  <a href="classcds_1_1container_1_1_split_list_set.html#a97fec9dee7ee988e20549d3a3aa53c27">More...</a><br /></td></tr>
<tr class="separator:a97fec9dee7ee988e20549d3a3aa53c27 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19488fdbd28c4c0490f6b55adc60d4fd inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a19488fdbd28c4c0490f6b55adc60d4fd">find</a> (Q &amp;key, Func f)</td></tr>
<tr class="memdesc:a19488fdbd28c4c0490f6b55adc60d4fd inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code>.  <a href="classcds_1_1container_1_1_split_list_set.html#a19488fdbd28c4c0490f6b55adc60d4fd">More...</a><br /></td></tr>
<tr class="separator:a19488fdbd28c4c0490f6b55adc60d4fd inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69dbd0a91ed82db230bec8a32ba85e4a inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a3bb1e96121f36af3252e2aa1ea09ff1b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a69dbd0a91ed82db230bec8a32ba85e4a">find</a> (Q &amp;key)</td></tr>
<tr class="memdesc:a69dbd0a91ed82db230bec8a32ba85e4a inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> and returns iterator pointed to the item found (only for <code>IterableList</code> -based set)  <a href="classcds_1_1container_1_1_split_list_set.html#a69dbd0a91ed82db230bec8a32ba85e4a">More...</a><br /></td></tr>
<tr class="separator:a69dbd0a91ed82db230bec8a32ba85e4a inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afaabe2cfffe1454ce1b17242d1cd9f inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a2afaabe2cfffe1454ce1b17242d1cd9f">find_with</a> (Q &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:a2afaabe2cfffe1454ce1b17242d1cd9f inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code> using <code>pred</code> predicate for searching.  <a href="classcds_1_1container_1_1_split_list_set.html#a2afaabe2cfffe1454ce1b17242d1cd9f">More...</a><br /></td></tr>
<tr class="separator:a2afaabe2cfffe1454ce1b17242d1cd9f inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af048f0fb68c30b21efb0b43dfe73947b inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a3bb1e96121f36af3252e2aa1ea09ff1b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#af048f0fb68c30b21efb0b43dfe73947b">find_with</a> (Q &amp;key, Less pred)</td></tr>
<tr class="memdesc:af048f0fb68c30b21efb0b43dfe73947b inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> using <code>pred</code> predicate and returns iterator pointed to the item found (only for <code>IterableList</code> -based set)  <a href="classcds_1_1container_1_1_split_list_set.html#af048f0fb68c30b21efb0b43dfe73947b">More...</a><br /></td></tr>
<tr class="separator:af048f0fb68c30b21efb0b43dfe73947b inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77525470b724f8833e96608c0309caa inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#aa77525470b724f8833e96608c0309caa">contains</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:aa77525470b724f8833e96608c0309caa inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>key</code>.  <a href="classcds_1_1container_1_1_split_list_set.html#aa77525470b724f8833e96608c0309caa">More...</a><br /></td></tr>
<tr class="separator:aa77525470b724f8833e96608c0309caa inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32c2131830853f016bb9180f07a3129 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ad32c2131830853f016bb9180f07a3129">contains</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:ad32c2131830853f016bb9180f07a3129 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the map contains <code>key</code> using <code>pred</code> predicate for searching.  <a href="classcds_1_1container_1_1_split_list_set.html#ad32c2131830853f016bb9180f07a3129">More...</a><br /></td></tr>
<tr class="separator:ad32c2131830853f016bb9180f07a3129 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d4175df387c0cf1fae98d485efa174 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ab1a910658827d385bc3ee5564bfa1c05">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a16d4175df387c0cf1fae98d485efa174">get</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a16d4175df387c0cf1fae98d485efa174 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code> and return the item found.  <a href="classcds_1_1container_1_1_split_list_set.html#a16d4175df387c0cf1fae98d485efa174">More...</a><br /></td></tr>
<tr class="separator:a16d4175df387c0cf1fae98d485efa174 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4ce221e181457872bd54e63728ab95 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ab1a910658827d385bc3ee5564bfa1c05">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a9f4ce221e181457872bd54e63728ab95">get_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a9f4ce221e181457872bd54e63728ab95 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> and return the item found.  <a href="classcds_1_1container_1_1_split_list_set.html#a9f4ce221e181457872bd54e63728ab95">More...</a><br /></td></tr>
<tr class="separator:a9f4ce221e181457872bd54e63728ab95 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1472496ebd650294f6a3d7695bb1b4a6 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a1472496ebd650294f6a3d7695bb1b4a6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a1472496ebd650294f6a3d7695bb1b4a6">clear</a> ()</td></tr>
<tr class="memdesc:a1472496ebd650294f6a3d7695bb1b4a6 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set (not atomic) <br /></td></tr>
<tr class="separator:a1472496ebd650294f6a3d7695bb1b4a6 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462a46cd4a8639cbfa94ba8b7ce91a97 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a462a46cd4a8639cbfa94ba8b7ce91a97">empty</a> () const</td></tr>
<tr class="memdesc:a462a46cd4a8639cbfa94ba8b7ce91a97 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty.  <a href="classcds_1_1container_1_1_split_list_set.html#a462a46cd4a8639cbfa94ba8b7ce91a97">More...</a><br /></td></tr>
<tr class="separator:a462a46cd4a8639cbfa94ba8b7ce91a97 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c010723afb429dbc276a3a9e92960fc inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a4c010723afb429dbc276a3a9e92960fc"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a4c010723afb429dbc276a3a9e92960fc">size</a> () const</td></tr>
<tr class="memdesc:a4c010723afb429dbc276a3a9e92960fc inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set. <br /></td></tr>
<tr class="separator:a4c010723afb429dbc276a3a9e92960fc inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c21029737e34e9e455763db2d3eec5 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a04c21029737e34e9e455763db2d3eec5"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_set.html#ad39196ac90597908219c5b130b37f47c">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a04c21029737e34e9e455763db2d3eec5">statistics</a> () const</td></tr>
<tr class="memdesc:a04c21029737e34e9e455763db2d3eec5 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns internal statistics. <br /></td></tr>
<tr class="separator:a04c21029737e34e9e455763db2d3eec5 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa99ee47b8f0087927f736fb71904fa inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a3aa99ee47b8f0087927f736fb71904fa"></a>
ordered_list::stat const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a3aa99ee47b8f0087927f736fb71904fa">list_statistics</a> () const</td></tr>
<tr class="memdesc:a3aa99ee47b8f0087927f736fb71904fa inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns internal statistics for <code>ordered_list</code>. <br /></td></tr>
<tr class="separator:a3aa99ee47b8f0087927f736fb71904fa inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dedb00d0e55b82a0f7975993c9b2975 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a3bb1e96121f36af3252e2aa1ea09ff1b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a5dedb00d0e55b82a0f7975993c9b2975">begin</a> ()</td></tr>
<tr class="memdesc:a5dedb00d0e55b82a0f7975993c9b2975 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator addressing the first element in a set.  <a href="classcds_1_1container_1_1_split_list_set.html#a5dedb00d0e55b82a0f7975993c9b2975">More...</a><br /></td></tr>
<tr class="separator:a5dedb00d0e55b82a0f7975993c9b2975 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca83192d535ded5115ac82f339feea9 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="aeca83192d535ded5115ac82f339feea9"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_set.html#a944c54c5061ce4d8d2b04dbe1dea152f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#aeca83192d535ded5115ac82f339feea9">begin</a> () const</td></tr>
<tr class="memdesc:aeca83192d535ded5115ac82f339feea9 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a set. <br /></td></tr>
<tr class="separator:aeca83192d535ded5115ac82f339feea9 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae399126f499a0d084959f66a6dc5115d inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a3bb1e96121f36af3252e2aa1ea09ff1b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ae399126f499a0d084959f66a6dc5115d">end</a> ()</td></tr>
<tr class="memdesc:ae399126f499a0d084959f66a6dc5115d inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator that addresses the location succeeding the last element in a set.  <a href="classcds_1_1container_1_1_split_list_set.html#ae399126f499a0d084959f66a6dc5115d">More...</a><br /></td></tr>
<tr class="separator:ae399126f499a0d084959f66a6dc5115d inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff98e6fca295ef37d48af8016a59603 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a4ff98e6fca295ef37d48af8016a59603"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_set.html#a944c54c5061ce4d8d2b04dbe1dea152f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a4ff98e6fca295ef37d48af8016a59603">end</a> () const</td></tr>
<tr class="memdesc:a4ff98e6fca295ef37d48af8016a59603 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator that addresses the location succeeding the last element in a set. <br /></td></tr>
<tr class="separator:a4ff98e6fca295ef37d48af8016a59603 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735c40a386916530459587e59c3ee9bd inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a735c40a386916530459587e59c3ee9bd"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_set.html#a944c54c5061ce4d8d2b04dbe1dea152f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a735c40a386916530459587e59c3ee9bd">cbegin</a> () const</td></tr>
<tr class="memdesc:a735c40a386916530459587e59c3ee9bd inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a set. <br /></td></tr>
<tr class="separator:a735c40a386916530459587e59c3ee9bd inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df33544c2263f3ad66542de0c05073a inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a6df33544c2263f3ad66542de0c05073a"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_set.html#a944c54c5061ce4d8d2b04dbe1dea152f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a6df33544c2263f3ad66542de0c05073a">cend</a> () const</td></tr>
<tr class="memdesc:a6df33544c2263f3ad66542de0c05073a inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator that addresses the location succeeding the last element in a set. <br /></td></tr>
<tr class="separator:a6df33544c2263f3ad66542de0c05073a inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classcds_1_1intrusive_1_1_split_list_set')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html">cds::intrusive::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt; ::ordered_list, split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt; &gt;</a></td></tr>
<tr class="memitem:a685c56051b1ffc44511a5ec12b80b2d0 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a685c56051b1ffc44511a5ec12b80b2d0">SplitListSet</a> ()</td></tr>
<tr class="memdesc:a685c56051b1ffc44511a5ec12b80b2d0 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize split-ordered list of default capacity.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a685c56051b1ffc44511a5ec12b80b2d0">More...</a><br /></td></tr>
<tr class="separator:a685c56051b1ffc44511a5ec12b80b2d0 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c73356d78265849a8cce93155480eb inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a56c73356d78265849a8cce93155480eb">SplitListSet</a> (size_t nItemCount, size_t nLoadFactor=1)</td></tr>
<tr class="memdesc:a56c73356d78265849a8cce93155480eb inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize split-ordered list.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a56c73356d78265849a8cce93155480eb">More...</a><br /></td></tr>
<tr class="separator:a56c73356d78265849a8cce93155480eb inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac107f9755fb5080b6c4cd03f3245bbbe inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="ac107f9755fb5080b6c4cd03f3245bbbe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#ac107f9755fb5080b6c4cd03f3245bbbe">~SplitListSet</a> ()</td></tr>
<tr class="memdesc:ac107f9755fb5080b6c4cd03f3245bbbe inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys split-list set. <br /></td></tr>
<tr class="separator:ac107f9755fb5080b6c4cd03f3245bbbe inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa996ee4f495c0a059c3bb031f7aa06 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a5fa996ee4f495c0a059c3bb031f7aa06">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#afae9f358f06403565d75e8a6666e0f8f">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a5fa996ee4f495c0a059c3bb031f7aa06 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a5fa996ee4f495c0a059c3bb031f7aa06">More...</a><br /></td></tr>
<tr class="separator:a5fa996ee4f495c0a059c3bb031f7aa06 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93fc790b0a2969b2795ddad438d4243a inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a93fc790b0a2969b2795ddad438d4243a">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#afae9f358f06403565d75e8a6666e0f8f">value_type</a> &amp;val, Func f)</td></tr>
<tr class="memdesc:a93fc790b0a2969b2795ddad438d4243a inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a93fc790b0a2969b2795ddad438d4243a">More...</a><br /></td></tr>
<tr class="separator:a93fc790b0a2969b2795ddad438d4243a inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ab1789e44fe8fec6bfb5bbc3a1d4c2 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#ac7ab1789e44fe8fec6bfb5bbc3a1d4c2">update</a> (<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#afae9f358f06403565d75e8a6666e0f8f">value_type</a> &amp;val, Func func, bool bAllowInsert=true)</td></tr>
<tr class="memdesc:ac7ab1789e44fe8fec6bfb5bbc3a1d4c2 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the node.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#ac7ab1789e44fe8fec6bfb5bbc3a1d4c2">More...</a><br /></td></tr>
<tr class="separator:ac7ab1789e44fe8fec6bfb5bbc3a1d4c2 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ac55def7875486d4872cbd0c36d3d0 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a46ac55def7875486d4872cbd0c36d3d0">upsert</a> (<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#afae9f358f06403565d75e8a6666e0f8f">value_type</a> &amp;val, bool bAllowInsert=true)</td></tr>
<tr class="memdesc:a46ac55def7875486d4872cbd0c36d3d0 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts or updates the node (only for <code>IterableList</code>)  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a46ac55def7875486d4872cbd0c36d3d0">More...</a><br /></td></tr>
<tr class="separator:a46ac55def7875486d4872cbd0c36d3d0 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4e3d7523dc3b7b2d1a0ac73fec4c3e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a0a4e3d7523dc3b7b2d1a0ac73fec4c3e">unlink</a> (<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#afae9f358f06403565d75e8a6666e0f8f">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a0a4e3d7523dc3b7b2d1a0ac73fec4c3e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlinks the item <code>val</code> from the set.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a0a4e3d7523dc3b7b2d1a0ac73fec4c3e">More...</a><br /></td></tr>
<tr class="separator:a0a4e3d7523dc3b7b2d1a0ac73fec4c3e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ab99e28bc6bc1147c12ef0994e7c0e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a25ab99e28bc6bc1147c12ef0994e7c0e">erase</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a25ab99e28bc6bc1147c12ef0994e7c0e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a25ab99e28bc6bc1147c12ef0994e7c0e">More...</a><br /></td></tr>
<tr class="separator:a25ab99e28bc6bc1147c12ef0994e7c0e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72b3c31a3fe7f78fc7795c5744848b0 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#ae72b3c31a3fe7f78fc7795c5744848b0">erase</a> (Q const &amp;key, Func f)</td></tr>
<tr class="memdesc:ae72b3c31a3fe7f78fc7795c5744848b0 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#ae72b3c31a3fe7f78fc7795c5744848b0">More...</a><br /></td></tr>
<tr class="separator:ae72b3c31a3fe7f78fc7795c5744848b0 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a3128bc56d8278fcdfb1930d37fb98 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a87a3128bc56d8278fcdfb1930d37fb98">erase_with</a> (const Q &amp;key, Less pred)</td></tr>
<tr class="memdesc:a87a3128bc56d8278fcdfb1930d37fb98 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set with comparing functor <code>pred</code>.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a87a3128bc56d8278fcdfb1930d37fb98">More...</a><br /></td></tr>
<tr class="separator:a87a3128bc56d8278fcdfb1930d37fb98 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b525b1f5b240a9c6036057bc0003fd8 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a6b525b1f5b240a9c6036057bc0003fd8">erase_with</a> (Q const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:a6b525b1f5b240a9c6036057bc0003fd8 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set with comparing functor <code>pred</code>.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a6b525b1f5b240a9c6036057bc0003fd8">More...</a><br /></td></tr>
<tr class="separator:a6b525b1f5b240a9c6036057bc0003fd8 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc11d5658a648a54098ec1455b70578 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a0933c1b9d510566c2538779f1ad81e14">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a4fc11d5658a648a54098ec1455b70578">extract</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a4fc11d5658a648a54098ec1455b70578 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item with specified <code>key</code>.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a4fc11d5658a648a54098ec1455b70578">More...</a><br /></td></tr>
<tr class="separator:a4fc11d5658a648a54098ec1455b70578 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2511f775b91f22e6372c361011eca3e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a0933c1b9d510566c2538779f1ad81e14">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#aa2511f775b91f22e6372c361011eca3e">extract_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:aa2511f775b91f22e6372c361011eca3e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item using compare functor <code>pred</code>.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#aa2511f775b91f22e6372c361011eca3e">More...</a><br /></td></tr>
<tr class="separator:aa2511f775b91f22e6372c361011eca3e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14087851b392163b5c6317c4c7fcfc54 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a14087851b392163b5c6317c4c7fcfc54">find</a> (Q &amp;key, Func f)</td></tr>
<tr class="memdesc:a14087851b392163b5c6317c4c7fcfc54 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code>.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a14087851b392163b5c6317c4c7fcfc54">More...</a><br /></td></tr>
<tr class="separator:a14087851b392163b5c6317c4c7fcfc54 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d12f67fb5b9f880037f58aac58f7d16 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a2c70b5bacc4b3d7d69efbf122f4d2c0b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a2d12f67fb5b9f880037f58aac58f7d16">find</a> (Q &amp;key)</td></tr>
<tr class="memdesc:a2d12f67fb5b9f880037f58aac58f7d16 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> and returns iterator pointed to the item found (only for <code>IterableList</code>)  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a2d12f67fb5b9f880037f58aac58f7d16">More...</a><br /></td></tr>
<tr class="separator:a2d12f67fb5b9f880037f58aac58f7d16 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcb668b144364e7c2bab2f4dc0cc9e6 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#acfcb668b144364e7c2bab2f4dc0cc9e6">find_with</a> (Q &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:acfcb668b144364e7c2bab2f4dc0cc9e6 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code> with <code>pred</code> predicate for comparing.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#acfcb668b144364e7c2bab2f4dc0cc9e6">More...</a><br /></td></tr>
<tr class="separator:acfcb668b144364e7c2bab2f4dc0cc9e6 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8141589095b24499111ab2cf10e6b8a2 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a2c70b5bacc4b3d7d69efbf122f4d2c0b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a8141589095b24499111ab2cf10e6b8a2">find_with</a> (Q &amp;key, Less pred)</td></tr>
<tr class="memdesc:a8141589095b24499111ab2cf10e6b8a2 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> using <code>pred</code> predicate and returns iterator pointed to the item found (only for <code>IterableList</code>)  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a8141589095b24499111ab2cf10e6b8a2">More...</a><br /></td></tr>
<tr class="separator:a8141589095b24499111ab2cf10e6b8a2 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce860bde9bcb5ef71f87a796387687e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a9ce860bde9bcb5ef71f87a796387687e">contains</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a9ce860bde9bcb5ef71f87a796387687e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>key</code>.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a9ce860bde9bcb5ef71f87a796387687e">More...</a><br /></td></tr>
<tr class="separator:a9ce860bde9bcb5ef71f87a796387687e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba7f5058868947b9b9ac189fd97e712 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#adba7f5058868947b9b9ac189fd97e712">contains</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:adba7f5058868947b9b9ac189fd97e712 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>key</code> using <code>pred</code> predicate for searching.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#adba7f5058868947b9b9ac189fd97e712">More...</a><br /></td></tr>
<tr class="separator:adba7f5058868947b9b9ac189fd97e712 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6e8ba28a58586de9e556b1c82069a5 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a0933c1b9d510566c2538779f1ad81e14">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#afe6e8ba28a58586de9e556b1c82069a5">get</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:afe6e8ba28a58586de9e556b1c82069a5 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code> and return the item found.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#afe6e8ba28a58586de9e556b1c82069a5">More...</a><br /></td></tr>
<tr class="separator:afe6e8ba28a58586de9e556b1c82069a5 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0217cf552409c17f9d49689224812fb5 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a0933c1b9d510566c2538779f1ad81e14">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a0217cf552409c17f9d49689224812fb5">get_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a0217cf552409c17f9d49689224812fb5 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code> and return the item found.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a0217cf552409c17f9d49689224812fb5">More...</a><br /></td></tr>
<tr class="separator:a0217cf552409c17f9d49689224812fb5 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b445fac9e849bc2c8a584f414460749 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a0b445fac9e849bc2c8a584f414460749"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a0b445fac9e849bc2c8a584f414460749">size</a> () const</td></tr>
<tr class="memdesc:a0b445fac9e849bc2c8a584f414460749 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set. <br /></td></tr>
<tr class="separator:a0b445fac9e849bc2c8a584f414460749 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49303695660aa5da4f07971bc22f8230 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a49303695660aa5da4f07971bc22f8230">empty</a> () const</td></tr>
<tr class="memdesc:a49303695660aa5da4f07971bc22f8230 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a49303695660aa5da4f07971bc22f8230">More...</a><br /></td></tr>
<tr class="separator:a49303695660aa5da4f07971bc22f8230 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3fc77a7939fd3553a594fc5a315572 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a0f3fc77a7939fd3553a594fc5a315572">clear</a> ()</td></tr>
<tr class="memdesc:a0f3fc77a7939fd3553a594fc5a315572 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set (non-atomic)  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a0f3fc77a7939fd3553a594fc5a315572">More...</a><br /></td></tr>
<tr class="separator:a0f3fc77a7939fd3553a594fc5a315572 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c9eec1fc9886e87391ec042d567f43 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a47c9eec1fc9886e87391ec042d567f43"></a>
<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a6b3b57584e1fd7f743b1ab806c138a72">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a47c9eec1fc9886e87391ec042d567f43">statistics</a> () const</td></tr>
<tr class="memdesc:a47c9eec1fc9886e87391ec042d567f43 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns internal statistics. <br /></td></tr>
<tr class="separator:a47c9eec1fc9886e87391ec042d567f43 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec9eee48751a4718bff046a19404b77 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="aeec9eee48751a4718bff046a19404b77"></a>
split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt; ::<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a719263aaf48921d5ced55707389f961a">ordered_list</a> ::<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a6b3b57584e1fd7f743b1ab806c138a72">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#aeec9eee48751a4718bff046a19404b77">list_statistics</a> () const</td></tr>
<tr class="memdesc:aeec9eee48751a4718bff046a19404b77 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns internal statistics for <code>OrderedList</code>. <br /></td></tr>
<tr class="separator:aeec9eee48751a4718bff046a19404b77 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f775376add33a1d7d2b82463670a55 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a2c70b5bacc4b3d7d69efbf122f4d2c0b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#ae9f775376add33a1d7d2b82463670a55">begin</a> ()</td></tr>
<tr class="memdesc:ae9f775376add33a1d7d2b82463670a55 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator addressing the first element in a split-list.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#ae9f775376add33a1d7d2b82463670a55">More...</a><br /></td></tr>
<tr class="separator:ae9f775376add33a1d7d2b82463670a55 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca35336f221c112be2292cc0f85a5f9 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a7ca35336f221c112be2292cc0f85a5f9"></a>
<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a1e6498e34acc524dd27767347acefbdb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a7ca35336f221c112be2292cc0f85a5f9">begin</a> () const</td></tr>
<tr class="memdesc:a7ca35336f221c112be2292cc0f85a5f9 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a split-list. <br /></td></tr>
<tr class="separator:a7ca35336f221c112be2292cc0f85a5f9 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5c1a7fb52b15cea10bbaa04c926517 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a2c70b5bacc4b3d7d69efbf122f4d2c0b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a4f5c1a7fb52b15cea10bbaa04c926517">end</a> ()</td></tr>
<tr class="memdesc:a4f5c1a7fb52b15cea10bbaa04c926517 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator that addresses the location succeeding the last element in a split-list.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#a4f5c1a7fb52b15cea10bbaa04c926517">More...</a><br /></td></tr>
<tr class="separator:a4f5c1a7fb52b15cea10bbaa04c926517 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78e5d2e78aa2f53eece612ed47d4e51 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="ab78e5d2e78aa2f53eece612ed47d4e51"></a>
<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a1e6498e34acc524dd27767347acefbdb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#ab78e5d2e78aa2f53eece612ed47d4e51">end</a> () const</td></tr>
<tr class="memdesc:ab78e5d2e78aa2f53eece612ed47d4e51 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator that addresses the location succeeding the last element in a split-list. <br /></td></tr>
<tr class="separator:ab78e5d2e78aa2f53eece612ed47d4e51 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa964f67e0f108826c03b1cef0b30aa2e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="aa964f67e0f108826c03b1cef0b30aa2e"></a>
<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a1e6498e34acc524dd27767347acefbdb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#aa964f67e0f108826c03b1cef0b30aa2e">cbegin</a> () const</td></tr>
<tr class="memdesc:aa964f67e0f108826c03b1cef0b30aa2e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a split-list. <br /></td></tr>
<tr class="separator:aa964f67e0f108826c03b1cef0b30aa2e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18634ad0407319550ce70512d9993d86 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a18634ad0407319550ce70512d9993d86"></a>
<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a1e6498e34acc524dd27767347acefbdb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a18634ad0407319550ce70512d9993d86">cend</a> () const</td></tr>
<tr class="memdesc:a18634ad0407319550ce70512d9993d86 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator that addresses the location succeeding the last element in a split-list. <br /></td></tr>
<tr class="separator:a18634ad0407319550ce70512d9993d86 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classcds_1_1container_1_1_split_list_set"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classcds_1_1container_1_1_split_list_set')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, std::pair&lt; Key const, Value &gt;, split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt; &gt;</a></td></tr>
<tr class="memitem:a04e9824c9f5a4bc2e695e7abce216289 inherit pro_static_attribs_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a04e9824c9f5a4bc2e695e7abce216289"></a>
static constexpr const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a04e9824c9f5a4bc2e695e7abce216289">c_nHazardPtrCount</a></td></tr>
<tr class="memdesc:a04e9824c9f5a4bc2e695e7abce216289 inherit pro_static_attribs_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of hazard pointer required. <br /></td></tr>
<tr class="separator:a04e9824c9f5a4bc2e695e7abce216289 inherit pro_static_attribs_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classcds_1_1intrusive_1_1_split_list_set"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classcds_1_1intrusive_1_1_split_list_set')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html">cds::intrusive::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt; ::ordered_list, split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt; &gt;</a></td></tr>
<tr class="memitem:a85e623d9bfc5b586f0d00aa38d1ae011 inherit pro_static_attribs_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a85e623d9bfc5b586f0d00aa38d1ae011"></a>
static constexpr const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a85e623d9bfc5b586f0d00aa38d1ae011">c_nHazardPtrCount</a></td></tr>
<tr class="memdesc:a85e623d9bfc5b586f0d00aa38d1ae011 inherit pro_static_attribs_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of hazard pointer required. <br /></td></tr>
<tr class="separator:a85e623d9bfc5b586f0d00aa38d1ae011 inherit pro_static_attribs_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class RCU, typename Key, typename Value, class Traits = split_list::traits&gt;<br />
class cds::container::SplitListMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;</h3>

<p>Split-ordered list map (template specialization for <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_desc">RCU</a>) </p>
<p><a class="anchor" id="cds_nonintrusive_SplitListMap_rcu"></a> Hash table implementation based on split-ordered list algorithm discovered by Ori Shalev and Nir Shavit, see</p><ul>
<li>[2003] Ori Shalev, Nir Shavit "Split-Ordered Lists - Lock-free Resizable Hash Tables"</li>
<li>[2008] Nir Shavit "The Art of Multiprocessor Programming"</li>
</ul>
<p>See <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html" title="Split-ordered list. ">intrusive::SplitListSet</a> for a brief description of the split-list algorithm.</p>
<p>Template parameters:</p><ul>
<li><code>RCU</code> - one of <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_gc">RCU type</a></li>
<li><code>Key</code> - key type to be stored in the map</li>
<li><code>Value</code> - value type to be stored in the map</li>
<li><code>Traits</code> - type traits, default is <code><a class="el" href="structcds_1_1container_1_1split__list_1_1traits.html" title="SplitListSet traits. ">split_list::traits</a></code>. Instead of declaring <code>split_list::traits</code> -based struct you may apply option-based notation with <code><a class="el" href="structcds_1_1container_1_1split__list_1_1make__traits.html" title="Metafunction converting option list to traits struct. ">split_list::make_traits</a></code> metafunction.</li>
</ul>
<p><b>Iterators</b></p>
<p>The class supports a forward unordered iterator (<a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a> and <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9039192cd438d5b60e8583d510f79e9f">const_iterator</a>). You may iterate over split-list map items only under RCU lock. Only in this case the iterator is thread-safe since while RCU is locked any map's item cannot be reclaimed. The requirement of RCU lock during iterating means that deletion of the elements is not possible.</p>
<dl class="section warning"><dt>Warning</dt><dd>The iterator object cannot be passed between threads. Due to concurrent nature of split-list map it is not guarantee that you can iterate all elements in the map: any concurrent deletion can exclude the element pointed by the iterator from the map, and your iteration can be terminated before end of the map. Therefore, such iteration is more suitable for debugging purposes</dd></dl>
<p>The iterator class supports the following minimalistic interface: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a> {</div><div class="line">    <span class="comment">// Default ctor</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Copy ctor</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a>( <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a> <span class="keyword">const</span>&amp; s);</div><div class="line"></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a682405bbab11f0cd0287f763ac14f5a5">value_type</a> * operator -&gt;() <span class="keyword">const</span>;</div><div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a682405bbab11f0cd0287f763ac14f5a5">value_type</a>&amp; operator *() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Pre-increment</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a>&amp; operator ++();</div><div class="line"></div><div class="line">    <span class="comment">// Copy assignment</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a>&amp; operator = (<span class="keyword">const</span> <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a>&amp; src);</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> operator ==(<a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a> <span class="keyword">const</span>&amp; i ) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">bool</span> operator !=(<a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a> <span class="keyword">const</span>&amp; i ) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p> Note, the iterator object returned by <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9411b38419a5dc5ce92ba48f48339e52">end</a>, <code>cend</code> member functions points to <code>nullptr</code> and should not be dereferenced.</p>
<dl class="section user"><dt>Usage</dt><dd></dd></dl>
<p>You should decide what garbage collector you want, and what ordered list you want to use. Split-ordered list is original data structure based on an ordered list. Suppose, you want construct split-list map based on <code>cds::urcu::general_buffered&lt;&gt;</code> GC and <code><a class="el" href="classcds_1_1container_1_1_michael_list.html" title="Michael&#39;s ordered list. ">MichaelList</a></code> as ordered list implementation. Your map should map <code>int</code> key to <code>std::string</code> value. So, you beginning your program with following include: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/urcu/general_buffered.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cds/container/michael_list_rcu.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cds/container/split_list_map_rcu.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>cc = <a class="code" href="namespacecds_1_1container.html">cds::container</a>;</div></div><!-- fragment --><p> The inclusion order is important:</p><ul>
<li>first, include one of <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_gc">RCU implementation</a> (<code>cds/urcu/general_buffered.h</code> in our case)</li>
<li>second, include the header of ordered-list implementation (for this example, <code>cds/container/michael_list_rcu.h</code>),</li>
<li>then, the header for RCU-based split-list map <code>cds/container/split_list_map_rcu.h</code>.</li>
</ul>
<p>Now, you should declare traits for split-list map. The main parts of traits are a hash functor for the map key and a comparing functor for ordered list. We use <code><a class="el" href="classcds_1_1container_1_1_split_list_map.html#a0b6d934bbe36bbc47a3e768ee4747ecc" title="Hash functor for key_type. ">std::hash&lt;int&gt;</a></code> and <code>std::less&lt;int&gt;</code>.</p>
<p>The second attention: instead of using <code>MichaelList</code> in <code>SplitListMap</code> traits we use a tag <code>ds::contaner::michael_list_tag</code> for the Michael's list. The split-list requires significant support from underlying ordered list class and it is not good idea to dive you into deep implementation details of split-list and ordered list interrelations. The tag paradigm simplifies split-list interface.</p>
<div class="fragment"><div class="line"><span class="comment">// SplitListMap traits</span></div><div class="line"><span class="keyword">struct </span>foo_set_traits: <span class="keyword">public</span> <a class="code" href="classcds_1_1container_1_1_split_list_map.html#a5b56db4ca8d93f8b2800ad9591f35752">cc::split_list::traits</a></div><div class="line">{</div><div class="line">    <span class="keyword">typedef</span> cc::michael_list_tag   <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#ad4e33ceb9acfeec3ae22f3e54075bf40">ordered_list</a>    ;   <span class="comment">// what type of ordered list we want to use</span></div><div class="line">    <span class="keyword">typedef</span> std::hash&lt;int&gt;         <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#ad3f287833bda6211df83817d566d526d">hash</a>            ;   <span class="comment">// hash functor for the key stored in split-list map</span></div><div class="line"></div><div class="line">    <span class="comment">// Type traits for our MichaelList class</span></div><div class="line">    <span class="keyword">struct </span>ordered_list_traits: <span class="keyword">public</span> <a class="code" href="classcds_1_1container_1_1_split_list_map.html#a5b56db4ca8d93f8b2800ad9591f35752">cc::michael_list::traits</a></div><div class="line">    {</div><div class="line">        <span class="keyword">typedef</span> std::less&lt;int&gt; less   ;   <span class="comment">// use our std::less predicate as comparator to order list nodes</span></div><div class="line">    };</div><div class="line">};</div></div><!-- fragment --><p>Now you are ready to declare our map class based on <code>SplitListMap</code>: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> cc::SplitListMap&lt; cds::urcu::gc&lt;cds::urcu::general_buffered&lt;&gt; &gt;, int, std::string, foo_set_traits &gt; int_string_map;</div></div><!-- fragment --><p>You may use the modern option-based declaration instead of classic traits-based one: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_split_list_map.html#aa1232ffae7993121ab80929d2d17be11">cc::SplitListMap</a>&lt;</div><div class="line">    cds::urcu::gc&lt;cds::urcu::general_buffered&lt;&gt; &gt;  <span class="comment">// RCU type</span></div><div class="line">    ,<span class="keywordtype">int</span>                    <span class="comment">// key type</span></div><div class="line">    ,std::string            <span class="comment">// value type</span></div><div class="line">    ,cc::split_list::make_traits&lt;      <span class="comment">// metafunction to build split-list traits</span></div><div class="line">        cc::split_list::ordered_list&lt;cc::michael_list_tag&gt;     <span class="comment">// tag for underlying ordered list implementation</span></div><div class="line">        ,cc::opt::hash&lt; std::hash&lt;int&gt; &gt;        <span class="comment">// hash functor</span></div><div class="line">        ,cc::split_list::ordered_list_traits&lt;    <span class="comment">// ordered list traits desired</span></div><div class="line">            cc::michael_list::make_traits&lt;    <span class="comment">// metafunction to build lazy list traits</span></div><div class="line">                cc::opt::less&lt; std::less&lt;int&gt; &gt;         <span class="comment">// less-based compare functor</span></div><div class="line">            &gt;::type</div><div class="line">        &gt;</div><div class="line">    &gt;::type</div><div class="line">&gt;  int_string_map;</div></div><!-- fragment --><p> In case of option-based declaration using <code><a class="el" href="structcds_1_1container_1_1split__list_1_1make__traits.html" title="Metafunction converting option list to traits struct. ">split_list::make_traits</a></code> metafunction the struct <code>foo_set_traits</code> is not required.</p>
<p>Now, the map of type <code>int_string_map</code> is ready to use in your program.</p>
<p>Note that in this example we show only mandatory <code>traits</code> parts, optional ones is the default and they are inherited from <a class="el" href="structcds_1_1container_1_1split__list_1_1traits.html" title="SplitListSet traits. ">cds::container::split_list::traits</a>. There are many other useful options for deep tuning the split-list and ordered-list containers. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af2b237bfaeb025412114274e5ca57b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b237bfaeb025412114274e5ca57b14">&sect;&nbsp;</a></span>exempt_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_class::exempt_ptr <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_map.html#ae871f7f4aaab464d2b5ee09308aafd18">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#af2b237bfaeb025412114274e5ca57b14">exempt_ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>pointer to extracted node </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0392614ddcd0ada7bb78136dc97bbc85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0392614ddcd0ada7bb78136dc97bbc85">&sect;&nbsp;</a></span>SplitListMap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_map.html#ae871f7f4aaab464d2b5ee09308aafd18">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_split_list_map.html">SplitListMap</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes split-ordered map of default capacity. </p>
<p>The default capacity is defined in bucket table constructor. See <code><a class="el" href="classcds_1_1intrusive_1_1split__list_1_1expandable__bucket__table.html" title="Expandable bucket table. ">intrusive::split_list::expandable_bucket_table</a></code>, <code><a class="el" href="classcds_1_1intrusive_1_1split__list_1_1static__bucket__table.html" title="Static bucket table. ">intrusive::split_list::static_bucket_table</a></code> which selects by <code><a class="el" href="namespacecds_1_1container_1_1split__list.html#ad43684b671934bab89303c17d9af9981" title="Selector of bucket table implementation = typedef for intrusive::split_list::dynamic_bucket_table. ">split_list::dynamic_bucket_table</a></code> option. </p>

</div>
</div>
<a id="a4bcf30da24623b50f97a1f5e49e2bc55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bcf30da24623b50f97a1f5e49e2bc55">&sect;&nbsp;</a></span>SplitListMap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_map.html#ae871f7f4aaab464d2b5ee09308aafd18">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_split_list_map.html">SplitListMap</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nItemCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nLoadFactor</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes split-ordered map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nItemCount</td><td>estimated average item count </td></tr>
    <tr><td class="paramname">nLoadFactor</td><td>load factor - average item count per bucket. Small integer up to 10, default is 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2e9a7ffed701fe108e98e27790782042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e9a7ffed701fe108e98e27790782042">&sect;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a> <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_map.html#ae871f7f4aaab464d2b5ee09308aafd18">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a forward iterator addressing the first element in a map. </p>
<p>For empty map</p><div class="fragment"><div class="line"><a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a2e9a7ffed701fe108e98e27790782042">begin</a>() == <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9411b38419a5dc5ce92ba48f48339e52">end</a>() </div></div><!-- fragment --> 
</div>
</div>
<a id="a961195d3d1094db952437c69c7be9767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961195d3d1094db952437c69c7be9767">&sect;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_map.html#ae871f7f4aaab464d2b5ee09308aafd18">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the map contains <code>key</code>. </p>
<p>The function searches the item with key equal to <code>key</code> and returns <code>true</code> if it is found, and <code>false</code> otherwise.</p>
<p>The function applies RCU lock internally. </p>

</div>
</div>
<a id="a6070cade4eb1619e92abf568b7d1659d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6070cade4eb1619e92abf568b7d1659d">&sect;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_map.html#ae871f7f4aaab464d2b5ee09308aafd18">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the map contains <code>key</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <code>contains( key )</code> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a id="a3748adb0dfa0fb4c905cf923951762d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3748adb0dfa0fb4c905cf923951762d1">&sect;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_map.html#ae871f7f4aaab464d2b5ee09308aafd18">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For key <code>key</code> inserts data of type <code>mapped_type</code> created in-place from <code>args</code>. </p>
<p><code>key_type</code> should be constructible from type <code>K</code> </p>
<p>The function applies RCU lock internally.</p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise. </p>

</div>
</div>
<a id="a90b521c0358541175621a2420f369495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b521c0358541175621a2420f369495">&sect;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_map.html#ae871f7f4aaab464d2b5ee09308aafd18">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the map is empty. </p>
<p>Emptiness is checked by item counting: if item count is zero then the map is empty. Thus, the correct item counting is an important part of the map implementation. </p>

</div>
</div>
<a id="a9411b38419a5dc5ce92ba48f48339e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9411b38419a5dc5ce92ba48f48339e52">&sect;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a> <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_map.html#ae871f7f4aaab464d2b5ee09308aafd18">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator that addresses the location succeeding the last element in a map. </p>
<p>Do not use the value returned by <code>end</code> function to access any item. The returned value can be used only to control reaching the end of the map. For empty map</p><div class="fragment"><div class="line"><a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a2e9a7ffed701fe108e98e27790782042">begin</a>() == <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9411b38419a5dc5ce92ba48f48339e52">end</a>() </div></div><!-- fragment --> 
</div>
</div>
<a id="aebb1f2b166d2b12f9f2a84344e264003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb1f2b166d2b12f9f2a84344e264003">&sect;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_map.html#ae871f7f4aaab464d2b5ee09308aafd18">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes <code>key</code> from the map. </p>
<p><a class="anchor" id="cds_nonintrusive_SplitListMap_rcu_erase_val"></a> RCU <code>synchronize</code> method can be called. RCU should not be locked.</p>
<p>Return <code>true</code> if <code>key</code> is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a id="a4e0d10489ab3ad0da3fd7ed9aa32e994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e0d10489ab3ad0da3fd7ed9aa32e994">&sect;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_map.html#ae871f7f4aaab464d2b5ee09308aafd18">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes <code>key</code> from the map. </p>
<p><a class="anchor" id="cds_nonintrusive_SplitListMap_rcu_erase_func"></a> The function searches an item with key <code>key</code>, calls <code>f</code> functor and deletes the item. If <code>key</code> is not found, the functor is not called.</p>
<p>The functor <code>Func</code> interface is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>extractor {</div><div class="line">    <span class="keywordtype">void</span> operator()(<a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a682405bbab11f0cd0287f763ac14f5a5">value_type</a>&amp; item) { ... }</div><div class="line">};</div></div><!-- fragment --><p>RCU <code>synchronize</code> method can be called. RCU should not be locked.</p>
<p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a id="a6e6674c5f0b6b4f0f523fcd4cba878c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6674c5f0b6b4f0f523fcd4cba878c0">&sect;&nbsp;</a></span>erase_with() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_map.html#ae871f7f4aaab464d2b5ee09308aafd18">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the map using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#cds_nonintrusive_SplitListMap_rcu_erase_val">erase(K const&amp;)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a id="a93282b6aba0332c6fce60c3fedf23115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93282b6aba0332c6fce60c3fedf23115">&sect;&nbsp;</a></span>erase_with() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_map.html#ae871f7f4aaab464d2b5ee09308aafd18">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the map using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#cds_nonintrusive_SplitListMap_rcu_erase_func">erase(K const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a id="a42d26ad0509a27b9c8ce94e2ef84aab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d26ad0509a27b9c8ce94e2ef84aab8">&sect;&nbsp;</a></span>extract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#af2b237bfaeb025412114274e5ca57b14">exempt_ptr</a> <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_map.html#ae871f7f4aaab464d2b5ee09308aafd18">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::extract </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item from the map. </p>
<p><a class="anchor" id="cds_nonintrusive_SplitListMap_rcu_extract"></a>The function searches an item with key equal to <code>key</code> in the map, unlinks it from the map, and returns <a class="el" href="classcds_1_1urcu_1_1exempt__ptr.html">exempt_ptr</a> pointer to the item found. If the item with the key equal to <code>key</code> is not found the function returns an empty <code>exempt_ptr</code>.</p>
<p>Depends on ordered list you should or should not lock RCU before calling of this function:</p><ul>
<li>for the set based on <a class="el" href="classcds_1_1intrusive_1_1_michael_list_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#cds_intrusive_MichaelList_rcu">MichaelList</a> RCU should not be locked</li>
<li>for the set based on <a class="el" href="classcds_1_1intrusive_1_1_lazy_list_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#cds_intrusive_LazyList_rcu">LazyList</a> RCU should be locked See ordered list implementation for details.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> cds::urcu::gc&lt; general_buffered&lt;&gt; &gt; rcu;</div><div class="line"></div><div class="line"><span class="comment">// Split-list set based on MichaelList by default</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap&lt; rcu, int, Foo &gt;</a> splitlist_map;</div><div class="line"></div><div class="line">splitlist_map theMap;</div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="keyword">typename</span> splitlist_map::exempt_ptr p;</div><div class="line"></div><div class="line"><span class="comment">// For MichaelList we should not lock RCU</span></div><div class="line"></div><div class="line"><span class="comment">// Now, you can apply extract function</span></div><div class="line">p = theMap.<a class="code" href="classcds_1_1container_1_1_split_list_map.html#a73d89c9fd93e3fb5dd8b1e6ded4216d1">extract</a>( 10 )</div><div class="line"><span class="keywordflow">if</span> ( p ) {</div><div class="line">    <span class="comment">// do something with p</span></div><div class="line">    ...</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// We may safely release p here</span></div><div class="line"><span class="comment">// release() passes the pointer to RCU reclamation cycle</span></div><div class="line">p.release();</div></div><!-- fragment --> 
</div>
</div>
<a id="a7d1f93f1f491242438c6ba9071fd0f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d1f93f1f491242438c6ba9071fd0f69">&sect;&nbsp;</a></span>extract_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#af2b237bfaeb025412114274e5ca57b14">exempt_ptr</a> <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_map.html#ae871f7f4aaab464d2b5ee09308aafd18">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::extract_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item from the map using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <code><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a42d26ad0509a27b9c8ce94e2ef84aab8" title="Extracts an item from the map. ">extract(K const&amp;)</a></code> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a id="ab1b497490353d85557018c5b908f82f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1b497490353d85557018c5b908f82f0">&sect;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_map.html#ae871f7f4aaab464d2b5ee09308aafd18">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>key</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_SplitListMap_rcu_find_cfunc"></a> The function searches the item with key equal to <code>key</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div><div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a682405bbab11f0cd0287f763ac14f5a5">value_type</a>&amp; item );</div><div class="line">};</div></div><!-- fragment --><p> where <code>item</code> is the item found.</p>
<p>The functor may change <code>item.second</code>. Note that the functor is only guarantee that <code>item</code> cannot be disposed during functor is executing. The functor does not serialize simultaneous access to the map's <code>item</code>. If such access is possible you must provide your own synchronization schema on item level to exclude unsafe item modifications.</p>
<p>The function applies RCU lock internally.</p>
<p>The function returns <code>true</code> if <code>key</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a id="ad593abbddb349e7e7d5642269f70d0cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad593abbddb349e7e7d5642269f70d0cd">&sect;&nbsp;</a></span>find_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_map.html#ae871f7f4aaab464d2b5ee09308aafd18">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>key</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#cds_nonintrusive_SplitListMap_rcu_find_cfunc">find(K const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a id="aeee9a675a958ee274c2de200432a00ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee9a675a958ee274c2de200432a00ca">&sect;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#afa307bb5de70335cf963bb9195017f62">raw_ptr</a> <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_map.html#ae871f7f4aaab464d2b5ee09308aafd18">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::get </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds <code>key</code> and return the item found. </p>
<p><a class="anchor" id="cds_intrusive_SplitListMap_rcu_get"></a>The function searches the item with key equal to <code>key</code> and returns the pointer to item found. If <code>key</code> is not found it returns empty <code>raw_ptr</code>.</p>
<p>Note the compare functor should accept a parameter of type <code>K</code> that can be not the same as <code>value_type</code>.</p>
<p>RCU should be locked before call of this function. Returned item is valid only while RCU is locked: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> cds::urcu::gc&lt; general_buffered&lt;&gt; &gt; rcu;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap&lt; rcu, int, Foo &gt;</a> splitlist_map;</div><div class="line">splitlist_map theMap;</div><div class="line"><span class="comment">// ...</span></div><div class="line">{</div><div class="line">    <span class="comment">// Lock RCU</span></div><div class="line">    <span class="keyword">typename</span> splitlist_map::rcu_lock lock;</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> splitlist_map::raw_ptr pVal = theMap.<a class="code" href="classcds_1_1container_1_1_split_list_map.html#a15d2b96d25ebd4bc4f622dafd4da87c9">get</a>( 5 );</div><div class="line">    <span class="keywordflow">if</span> ( pVal ) {</div><div class="line">        <span class="comment">// Deal with pVal</span></div><div class="line">        <span class="comment">//...</span></div><div class="line">    }</div><div class="line">    <span class="comment">// Unlock RCU by rcu_lock destructor</span></div><div class="line">    <span class="comment">// pVal can be retired by disposer at any time after RCU has been unlocked</span></div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="a9bee6446a58cf200ac613d54c24c8b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bee6446a58cf200ac613d54c24c8b9a">&sect;&nbsp;</a></span>get_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#afa307bb5de70335cf963bb9195017f62">raw_ptr</a> <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_map.html#ae871f7f4aaab464d2b5ee09308aafd18">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::get_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds <code>key</code> with predicate specified and return the item found. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#cds_intrusive_SplitListMap_rcu_get">get(K const&amp;)</a> but <code>pred</code> is used for comparing the keys.</p>
<p><code>Less</code> functor has the semantics like <code>std::less</code> but should take arguments of type <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a682405bbab11f0cd0287f763ac14f5a5">value_type</a> and <code>K</code> in any order. <code>pred</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a id="a9732e42943b07d8e216d25c42def7f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9732e42943b07d8e216d25c42def7f01">&sect;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_map.html#ae871f7f4aaab464d2b5ee09308aafd18">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node with key and default value. </p>
<p>The function creates a node with <code>key</code> and the default value, and then inserts the node created into the map.</p>
<p>Preconditions:</p><ul>
<li>The <code>key_type</code> should be constructible from value of type <code>K</code>.</li>
<li>The <code>mapped_type</code> should be default-constructible.</li>
</ul>
<p>The function applies RCU lock internally.</p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise. </p>

</div>
</div>
<a id="a37e1da831a875c8ef38964f7a63d68fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37e1da831a875c8ef38964f7a63d68fb">&sect;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_map.html#ae871f7f4aaab464d2b5ee09308aafd18">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function creates a node with copy of <code>val</code> value and then inserts the node into the map.</p>
<p>Preconditions:</p><ul>
<li>The <code>key_type</code> should be constructible from <code>key</code> of type <code>K</code>.</li>
<li>The <code>mapped_type</code> should be constructible from <code>val</code> of type <code>V</code>.</li>
</ul>
<p>The function applies RCU lock internally.</p>
<p>Returns <code>true</code> if <code>val</code> is inserted into the map, <code>false</code> otherwise. </p>

</div>
</div>
<a id="a977a9f295cffc445355b5ac4c23bdf39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977a9f295cffc445355b5ac4c23bdf39">&sect;&nbsp;</a></span>insert_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_map.html#ae871f7f4aaab464d2b5ee09308aafd18">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::insert_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node and initialize it by a functor. </p>
<p>This function inserts new node with key <code>key</code> and if inserting is successful then it calls <code>func</code> functor with signature </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div><div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a682405bbab11f0cd0287f763ac14f5a5">value_type</a>&amp; item );</div><div class="line">};</div></div><!-- fragment --><p>The argument <code>item</code> of user-defined functor <code>func</code> is the reference to the map's item inserted:</p><ul>
<li><code>item.first</code> is a const reference to item's key that cannot be changed.</li>
<li><code>item.second</code> is a reference to item's value that may be changed.</li>
</ul>
<p>It should be keep in mind that concurrent modifications of <code><code>item.second</code></code> in <code>func</code> body should be careful. You shouldf guarantee that during changing item's value in <code>func</code> no any other changes could be made on this <code>item</code> by concurrent threads.</p>
<p><code>func</code> is called only if inserting is successful.</p>
<p>The function allows to split creating of new item into two part:</p><ul>
<li>create item from <code>key</code>;</li>
<li>insert new item into the map;</li>
<li>if inserting is successful, initialize the value of item by calling <code>func</code> functor</li>
</ul>
<p>This can be useful if complete initialization of object of <code>mapped_type</code> is heavyweight and it is preferable that the initialization should be completed only if inserting is successful.</p>
<p>The function applies RCU lock internally. </p>

</div>
</div>
<a id="a04090173571564ec3983bd37b19699bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04090173571564ec3983bd37b19699bb">&sect;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_split_list_map.html#ae871f7f4aaab464d2b5ee09308aafd18">cds::urcu::gc</a>&lt; RCU &gt;, Key, Value, Traits &gt;::update </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowInsert</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates data by <code>key</code>. </p>
<p>The operation performs inserting or replacing the element with lock-free manner.</p>
<p>If the <code>key</code> not found in the map, then the new item created from <code>key</code> will be inserted into the map iff <code>bAllowInsert</code> is <code>true</code>. (note that in this case the <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9e25dd8f881eb1af7bf624a64330ab18">key_type</a> should be constructible from type <code>K</code>). Otherwise, if <code>key</code> is found, the functor <code>func</code> is called with item found.</p>
<p>The functor <code>Func</code> signature is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>my_functor {</div><div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a682405bbab11f0cd0287f763ac14f5a5">value_type</a>&amp; item );</div><div class="line">};</div></div><!-- fragment --><p> with arguments:</p><ul>
<li><code>bNew</code> - <code>true</code> if the item has been inserted, <code>false</code> otherwise</li>
<li><code>item</code> - the item found or inserted</li>
</ul>
<p>The functor may change any fields of the <code>item.second</code> that is <code>mapped_type</code>.</p>
<p>The function applies RCU lock internally.</p>
<p>Returns <code> std::pair&lt;bool, bool&gt; </code> where <code>first</code> is true if operation is successful, <code>second</code> is true if new item has been added or <code>false</code> if the item with <code>key</code> already exists.</p>
<dl class="section warning"><dt>Warning</dt><dd>For <a class="el" href="classcds_1_1container_1_1_michael_k_v_list.html#cds_nonintrusive_MichaelKVList_gc">MichaelKVList</a> as the ordered list see <a class="el" href="namespacecds_1_1intrusive.html#cds_intrusive_item_creating">insert item troubleshooting</a>. <a class="el" href="classcds_1_1container_1_1_lazy_k_v_list.html#cds_nonintrusive_LazyKVList_gc">LazyKVList</a> provides exclusive access to inserted item and does not require any node-level synchronization. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/container/split_list_map_rcu.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.2.0</b> 
  Developed by <i>Maxim Khizhinsky aka khizmax</i> 2007 - 2017
  <br/>
  <i>Autogenerated Wed Jan 4 2017 08:49:42 by Doxygen 1.8.12</i>
</div>
</body>
</html>
