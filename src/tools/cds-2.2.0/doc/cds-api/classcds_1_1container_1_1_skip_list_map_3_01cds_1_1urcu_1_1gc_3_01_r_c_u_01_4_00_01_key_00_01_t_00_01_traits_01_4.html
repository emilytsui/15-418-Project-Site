<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cds: cds::container::SkipListMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::SkipListMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__nonintrusive__containers.html">Non-intrusive containers</a> &raquo; <a class="el" href="group__cds__nonintrusive__map.html">Map</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Lock-free skip-list map (template specialization for <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_desc">RCU</a>)  
 <a href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#details">More...</a></p>

<p><code>#include &lt;cds/container/skip_list_map_rcu.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::container::SkipListMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.png" usemap="#cds::container::SkipListMap_3C_20cds::urcu::gc_3C_20RCU_20_3E_2C_20Key_2C_20T_2C_20Traits_20_3E_map" alt=""/>
  <map id="cds::container::SkipListMap_3C_20cds::urcu::gc_3C_20RCU_20_3E_2C_20Key_2C_20T_2C_20Traits_20_3E_map" name="cds::container::SkipListMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;_map">
<area href="classcds_1_1intrusive_1_1_skip_list_set.html" alt="cds::intrusive::SkipListSet&lt; cds::urcu::gc&lt; RCU &gt;, std::pair&lt; Key const, T &gt;, Traits &gt;" shape="rect" coords="0,0,488,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5dea770b123d9afffdf3c975089a8c60"><td class="memItemLeft" align="right" valign="top"><a id="a5dea770b123d9afffdf3c975089a8c60"></a>
typedef cds::urcu::gc&lt; RCU &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a5dea770b123d9afffdf3c975089a8c60">gc</a></td></tr>
<tr class="memdesc:a5dea770b123d9afffdf3c975089a8c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector used. <br /></td></tr>
<tr class="separator:a5dea770b123d9afffdf3c975089a8c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990b253457b725e094c126ea9a71fef3"><td class="memItemLeft" align="right" valign="top"><a id="a990b253457b725e094c126ea9a71fef3"></a>
typedef Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a990b253457b725e094c126ea9a71fef3">key_type</a></td></tr>
<tr class="memdesc:a990b253457b725e094c126ea9a71fef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key type. <br /></td></tr>
<tr class="separator:a990b253457b725e094c126ea9a71fef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78036d3bb19ae9dc00d148a03fc7fd2"><td class="memItemLeft" align="right" valign="top"><a id="ae78036d3bb19ae9dc00d148a03fc7fd2"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ae78036d3bb19ae9dc00d148a03fc7fd2">mapped_type</a></td></tr>
<tr class="memdesc:ae78036d3bb19ae9dc00d148a03fc7fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapped type. <br /></td></tr>
<tr class="separator:ae78036d3bb19ae9dc00d148a03fc7fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5234aa90b9e7eaa8424c3732e7dfddbe"><td class="memItemLeft" align="right" valign="top"><a id="a5234aa90b9e7eaa8424c3732e7dfddbe"></a>
typedef std::pair&lt; K const, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a5234aa90b9e7eaa8424c3732e7dfddbe">value_type</a></td></tr>
<tr class="memdesc:a5234aa90b9e7eaa8424c3732e7dfddbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type stored in the map. <br /></td></tr>
<tr class="separator:a5234aa90b9e7eaa8424c3732e7dfddbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57ad2af320482578c9326a33784fbef"><td class="memItemLeft" align="right" valign="top"><a id="aa57ad2af320482578c9326a33784fbef"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#aa57ad2af320482578c9326a33784fbef">traits</a></td></tr>
<tr class="memdesc:aa57ad2af320482578c9326a33784fbef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map traits. <br /></td></tr>
<tr class="separator:aa57ad2af320482578c9326a33784fbef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497766668e674479eea0cfee3dd10a0c"><td class="memItemLeft" align="right" valign="top"><a id="a497766668e674479eea0cfee3dd10a0c"></a>
typedef base_class::back_off&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a497766668e674479eea0cfee3dd10a0c">back_off</a></td></tr>
<tr class="memdesc:a497766668e674479eea0cfee3dd10a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Back-off strategy used. <br /></td></tr>
<tr class="separator:a497766668e674479eea0cfee3dd10a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac311ab4f19cd34afbd08cc01367368ba"><td class="memItemLeft" align="right" valign="top"><a id="ac311ab4f19cd34afbd08cc01367368ba"></a>
typedef traits::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ac311ab4f19cd34afbd08cc01367368ba">allocator_type</a></td></tr>
<tr class="memdesc:ac311ab4f19cd34afbd08cc01367368ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator type used for allocate/deallocate the skip-list nodes. <br /></td></tr>
<tr class="separator:ac311ab4f19cd34afbd08cc01367368ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cbe91eb3e0cc506a771135963e05228"><td class="memItemLeft" align="right" valign="top"><a id="a8cbe91eb3e0cc506a771135963e05228"></a>
typedef base_class::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a8cbe91eb3e0cc506a771135963e05228">item_counter</a></td></tr>
<tr class="memdesc:a8cbe91eb3e0cc506a771135963e05228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy used. <br /></td></tr>
<tr class="separator:a8cbe91eb3e0cc506a771135963e05228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e53e060358d8b47cc5d648f7e4ba094"><td class="memItemLeft" align="right" valign="top"><a id="a1e53e060358d8b47cc5d648f7e4ba094"></a>
typedef maker::key_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a1e53e060358d8b47cc5d648f7e4ba094">key_comparator</a></td></tr>
<tr class="memdesc:a1e53e060358d8b47cc5d648f7e4ba094"><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparison functor <br /></td></tr>
<tr class="separator:a1e53e060358d8b47cc5d648f7e4ba094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b79e59abbd7e4226654188e7d4ecf17"><td class="memItemLeft" align="right" valign="top"><a id="a5b79e59abbd7e4226654188e7d4ecf17"></a>
typedef base_class::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a5b79e59abbd7e4226654188e7d4ecf17">memory_model</a></td></tr>
<tr class="memdesc:a5b79e59abbd7e4226654188e7d4ecf17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering. See <a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">cds::opt::memory_model</a> option. <br /></td></tr>
<tr class="separator:a5b79e59abbd7e4226654188e7d4ecf17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fc95c193e4c52deab6118aa836528f"><td class="memItemLeft" align="right" valign="top"><a id="a73fc95c193e4c52deab6118aa836528f"></a>
typedef traits::random_level_generator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a73fc95c193e4c52deab6118aa836528f">random_level_generator</a></td></tr>
<tr class="memdesc:a73fc95c193e4c52deab6118aa836528f"><td class="mdescLeft">&#160;</td><td class="mdescRight">random level generator <br /></td></tr>
<tr class="separator:a73fc95c193e4c52deab6118aa836528f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae326f28f4a051390963e3cc7a7973692"><td class="memItemLeft" align="right" valign="top"><a id="ae326f28f4a051390963e3cc7a7973692"></a>
typedef traits::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ae326f28f4a051390963e3cc7a7973692">stat</a></td></tr>
<tr class="memdesc:ae326f28f4a051390963e3cc7a7973692"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics type <br /></td></tr>
<tr class="separator:ae326f28f4a051390963e3cc7a7973692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4437a4b82ffae452dd9965e3f0dae36"><td class="memItemLeft" align="right" valign="top">typedef base_class::rcu_lock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#aa4437a4b82ffae452dd9965e3f0dae36">rcu_lock</a></td></tr>
<tr class="separator:aa4437a4b82ffae452dd9965e3f0dae36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad793833cd6a6363a487427e4ee31d531"><td class="memItemLeft" align="right" valign="top"><a id="ad793833cd6a6363a487427e4ee31d531"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ad793833cd6a6363a487427e4ee31d531">exempt_ptr</a> = <a class="el" href="classcds_1_1urcu_1_1exempt__ptr.html">cds::urcu::exempt_ptr</a>&lt; <a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a5dea770b123d9afffdf3c975089a8c60">gc</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aeb1c111410605d85dee2daf622820e34">node_type</a>, <a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a5234aa90b9e7eaa8424c3732e7dfddbe">value_type</a>, typename <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ae9b394b2f922a1400b2eb2c3e6b2bacc">maker::intrusive_type_traits::disposer</a> &gt;</td></tr>
<tr class="memdesc:ad793833cd6a6363a487427e4ee31d531"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to extracted node <br /></td></tr>
<tr class="separator:ad793833cd6a6363a487427e4ee31d531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af29d35cb5176743c6ad76fab351ccd"><td class="memItemLeft" align="right" valign="top"><a id="a8af29d35cb5176743c6ad76fab351ccd"></a>
typedef cds::urcu::raw_ptr_adaptor&lt; <a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a5234aa90b9e7eaa8424c3732e7dfddbe">value_type</a>, typename base_class::raw_ptr, raw_ptr_converter &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a8af29d35cb5176743c6ad76fab351ccd">raw_ptr</a></td></tr>
<tr class="memdesc:a8af29d35cb5176743c6ad76fab351ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result of <code><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a4f720be58b42f25432176750a6534029" title="Finds the key key and return the item found. ">get()</a></code>, <code><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a8ee63cb325e31fa057c2c4334500c8e8" title="Finds the key key and return the item found. ">get_with()</a></code> functions - pointer to the node found. <br /></td></tr>
<tr class="separator:a8af29d35cb5176743c6ad76fab351ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac098883e8ab3a2158a16677bf635d67b"><td class="memItemLeft" align="right" valign="top"><a id="ac098883e8ab3a2158a16677bf635d67b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ac098883e8ab3a2158a16677bf635d67b">SkipListMap</a> ()</td></tr>
<tr class="memdesc:ac098883e8ab3a2158a16677bf635d67b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default ctor. <br /></td></tr>
<tr class="separator:ac098883e8ab3a2158a16677bf635d67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f505eca02bc7ee6f3ebd29a7409343"><td class="memItemLeft" align="right" valign="top"><a id="a33f505eca02bc7ee6f3ebd29a7409343"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a33f505eca02bc7ee6f3ebd29a7409343">~SkipListMap</a> ()</td></tr>
<tr class="memdesc:a33f505eca02bc7ee6f3ebd29a7409343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor destroys the set object. <br /></td></tr>
<tr class="separator:a33f505eca02bc7ee6f3ebd29a7409343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877fb2f6a50d28f4202a4b8699e75000"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a877fb2f6a50d28f4202a4b8699e75000"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a877fb2f6a50d28f4202a4b8699e75000">insert</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a877fb2f6a50d28f4202a4b8699e75000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node with key and default value.  <a href="#a877fb2f6a50d28f4202a4b8699e75000">More...</a><br /></td></tr>
<tr class="separator:a877fb2f6a50d28f4202a4b8699e75000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9036ea2f2b5cf943bac33fc367afda"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a3f9036ea2f2b5cf943bac33fc367afda"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a3f9036ea2f2b5cf943bac33fc367afda">insert</a> (K const &amp;key, V const &amp;val)</td></tr>
<tr class="memdesc:a3f9036ea2f2b5cf943bac33fc367afda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a3f9036ea2f2b5cf943bac33fc367afda">More...</a><br /></td></tr>
<tr class="separator:a3f9036ea2f2b5cf943bac33fc367afda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf451841ee82289c5a442c619346d02b"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:aaf451841ee82289c5a442c619346d02b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#aaf451841ee82289c5a442c619346d02b">insert_with</a> (const K &amp;key, Func func)</td></tr>
<tr class="memdesc:aaf451841ee82289c5a442c619346d02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node and initialize it by a functor.  <a href="#aaf451841ee82289c5a442c619346d02b">More...</a><br /></td></tr>
<tr class="separator:aaf451841ee82289c5a442c619346d02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08193421ee3ecc2f576cd89405c91e03"><td class="memTemplParams" colspan="2">template&lt;typename K , typename... Args&gt; </td></tr>
<tr class="memitem:a08193421ee3ecc2f576cd89405c91e03"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a08193421ee3ecc2f576cd89405c91e03">emplace</a> (K &amp;&amp;key, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a08193421ee3ecc2f576cd89405c91e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">For key <code>key</code> inserts data of type <code>value_type</code> created in-place from <code>args</code>.  <a href="#a08193421ee3ecc2f576cd89405c91e03">More...</a><br /></td></tr>
<tr class="separator:a08193421ee3ecc2f576cd89405c91e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670e057905fbd297ca65c22564140222"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a670e057905fbd297ca65c22564140222"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a670e057905fbd297ca65c22564140222">update</a> (K const &amp;key, Func func, bool bInsert=true)</td></tr>
<tr class="memdesc:a670e057905fbd297ca65c22564140222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates data by <code>key</code>.  <a href="#a670e057905fbd297ca65c22564140222">More...</a><br /></td></tr>
<tr class="separator:a670e057905fbd297ca65c22564140222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33830c59e1a27dc4f04c106ba7f148d6"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a33830c59e1a27dc4f04c106ba7f148d6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a33830c59e1a27dc4f04c106ba7f148d6">erase</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a33830c59e1a27dc4f04c106ba7f148d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the map.  <a href="#a33830c59e1a27dc4f04c106ba7f148d6">More...</a><br /></td></tr>
<tr class="separator:a33830c59e1a27dc4f04c106ba7f148d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ecd16cab44082e831187b7fbd5add2"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:ae8ecd16cab44082e831187b7fbd5add2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ae8ecd16cab44082e831187b7fbd5add2">erase_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:ae8ecd16cab44082e831187b7fbd5add2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the map using <code>pred</code> predicate for searching.  <a href="#ae8ecd16cab44082e831187b7fbd5add2">More...</a><br /></td></tr>
<tr class="separator:ae8ecd16cab44082e831187b7fbd5add2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ae3bc414ead99a641f7cc34e0d1c7f"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a11ae3bc414ead99a641f7cc34e0d1c7f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a11ae3bc414ead99a641f7cc34e0d1c7f">erase</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:a11ae3bc414ead99a641f7cc34e0d1c7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the map.  <a href="#a11ae3bc414ead99a641f7cc34e0d1c7f">More...</a><br /></td></tr>
<tr class="separator:a11ae3bc414ead99a641f7cc34e0d1c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9829639614690fe81c89aeb550756c5"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:ae9829639614690fe81c89aeb550756c5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ae9829639614690fe81c89aeb550756c5">erase_with</a> (K const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:ae9829639614690fe81c89aeb550756c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the map using <code>pred</code> predicate for searching.  <a href="#ae9829639614690fe81c89aeb550756c5">More...</a><br /></td></tr>
<tr class="separator:ae9829639614690fe81c89aeb550756c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affbd6d8a9164159c2813ea4c33ce3172"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:affbd6d8a9164159c2813ea4c33ce3172"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ad793833cd6a6363a487427e4ee31d531">exempt_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#affbd6d8a9164159c2813ea4c33ce3172">extract</a> (K const &amp;key)</td></tr>
<tr class="memdesc:affbd6d8a9164159c2813ea4c33ce3172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item from the map with specified <code>key</code>.  <a href="#affbd6d8a9164159c2813ea4c33ce3172">More...</a><br /></td></tr>
<tr class="separator:affbd6d8a9164159c2813ea4c33ce3172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ebe0f106a85072767a297ae4ecbb36"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:af5ebe0f106a85072767a297ae4ecbb36"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ad793833cd6a6363a487427e4ee31d531">exempt_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#af5ebe0f106a85072767a297ae4ecbb36">extract_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:af5ebe0f106a85072767a297ae4ecbb36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item from the map with comparing functor <code>pred</code>.  <a href="#af5ebe0f106a85072767a297ae4ecbb36">More...</a><br /></td></tr>
<tr class="separator:af5ebe0f106a85072767a297ae4ecbb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35fe7c0c2b37037a68198244ced4064"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ad793833cd6a6363a487427e4ee31d531">exempt_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#aa35fe7c0c2b37037a68198244ced4064">extract_min</a> ()</td></tr>
<tr class="memdesc:aa35fe7c0c2b37037a68198244ced4064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with minimal key from the map.  <a href="#aa35fe7c0c2b37037a68198244ced4064">More...</a><br /></td></tr>
<tr class="separator:aa35fe7c0c2b37037a68198244ced4064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee26a22d61d61a9a72c7b8edb0c88162"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ad793833cd6a6363a487427e4ee31d531">exempt_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#aee26a22d61d61a9a72c7b8edb0c88162">extract_max</a> ()</td></tr>
<tr class="memdesc:aee26a22d61d61a9a72c7b8edb0c88162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with maximal key from the map.  <a href="#aee26a22d61d61a9a72c7b8edb0c88162">More...</a><br /></td></tr>
<tr class="separator:aee26a22d61d61a9a72c7b8edb0c88162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624f4560772cc0bfd9357f11f9030f81"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a624f4560772cc0bfd9357f11f9030f81"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a624f4560772cc0bfd9357f11f9030f81">find</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:a624f4560772cc0bfd9357f11f9030f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>key</code>.  <a href="#a624f4560772cc0bfd9357f11f9030f81">More...</a><br /></td></tr>
<tr class="separator:a624f4560772cc0bfd9357f11f9030f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0eb86986df2465845d0bc922a762ebf"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:aa0eb86986df2465845d0bc922a762ebf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#aa0eb86986df2465845d0bc922a762ebf">find_with</a> (K const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:aa0eb86986df2465845d0bc922a762ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for searching.  <a href="#aa0eb86986df2465845d0bc922a762ebf">More...</a><br /></td></tr>
<tr class="separator:aa0eb86986df2465845d0bc922a762ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c988c8df76dae5e99390c1600dcd99"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a80c988c8df76dae5e99390c1600dcd99"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a80c988c8df76dae5e99390c1600dcd99">contains</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a80c988c8df76dae5e99390c1600dcd99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the map contains <code>key</code>.  <a href="#a80c988c8df76dae5e99390c1600dcd99">More...</a><br /></td></tr>
<tr class="separator:a80c988c8df76dae5e99390c1600dcd99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa974b413e15121f36efe968d90ab758e"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:aa974b413e15121f36efe968d90ab758e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#aa974b413e15121f36efe968d90ab758e">contains</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:aa974b413e15121f36efe968d90ab758e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the map contains <code>key</code> using <code>pred</code> predicate for searching.  <a href="#aa974b413e15121f36efe968d90ab758e">More...</a><br /></td></tr>
<tr class="separator:aa974b413e15121f36efe968d90ab758e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f720be58b42f25432176750a6534029"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a4f720be58b42f25432176750a6534029"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a8af29d35cb5176743c6ad76fab351ccd">raw_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a4f720be58b42f25432176750a6534029">get</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a4f720be58b42f25432176750a6534029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code> and return the item found.  <a href="#a4f720be58b42f25432176750a6534029">More...</a><br /></td></tr>
<tr class="separator:a4f720be58b42f25432176750a6534029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee63cb325e31fa057c2c4334500c8e8"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a8ee63cb325e31fa057c2c4334500c8e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a8af29d35cb5176743c6ad76fab351ccd">raw_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a8ee63cb325e31fa057c2c4334500c8e8">get_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a8ee63cb325e31fa057c2c4334500c8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code> and return the item found.  <a href="#a8ee63cb325e31fa057c2c4334500c8e8">More...</a><br /></td></tr>
<tr class="separator:a8ee63cb325e31fa057c2c4334500c8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2616f25a29884b1ef3837eea9be6c4f"><td class="memItemLeft" align="right" valign="top"><a id="af2616f25a29884b1ef3837eea9be6c4f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#af2616f25a29884b1ef3837eea9be6c4f">clear</a> ()</td></tr>
<tr class="memdesc:af2616f25a29884b1ef3837eea9be6c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the map (not atomic) <br /></td></tr>
<tr class="separator:af2616f25a29884b1ef3837eea9be6c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f809b94002b7fb312af2be52f8f438"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ab5f809b94002b7fb312af2be52f8f438">empty</a> () const</td></tr>
<tr class="memdesc:ab5f809b94002b7fb312af2be52f8f438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the map is empty.  <a href="#ab5f809b94002b7fb312af2be52f8f438">More...</a><br /></td></tr>
<tr class="separator:ab5f809b94002b7fb312af2be52f8f438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e51b942d17da7d5d382feeb6454686"><td class="memItemLeft" align="right" valign="top"><a id="a03e51b942d17da7d5d382feeb6454686"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a03e51b942d17da7d5d382feeb6454686">size</a> () const</td></tr>
<tr class="memdesc:a03e51b942d17da7d5d382feeb6454686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the map. <br /></td></tr>
<tr class="separator:a03e51b942d17da7d5d382feeb6454686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7da96bf023a05af74ff56d82b2d25e"><td class="memItemLeft" align="right" valign="top"><a id="aed7da96bf023a05af74ff56d82b2d25e"></a>
<a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ae326f28f4a051390963e3cc7a7973692">stat</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#aed7da96bf023a05af74ff56d82b2d25e">statistics</a> () const</td></tr>
<tr class="memdesc:aed7da96bf023a05af74ff56d82b2d25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br /></td></tr>
<tr class="separator:aed7da96bf023a05af74ff56d82b2d25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a1f311f6a06423bac59c8fd5a39370094"><td class="memItemLeft" align="right" valign="top"><a id="a1f311f6a06423bac59c8fd5a39370094"></a>
static constexpr const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a1f311f6a06423bac59c8fd5a39370094">c_bExtractLockExternal</a> = base_class::c_bExtractLockExternal</td></tr>
<tr class="memdesc:a1f311f6a06423bac59c8fd5a39370094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group of <code>extract_xxx</code> functions do not require external locking. <br /></td></tr>
<tr class="separator:a1f311f6a06423bac59c8fd5a39370094"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Forward ordered iterators (thread-safe under RCU lock)</h2></td></tr>
<tr class="memitem:ae8de0e2b1f72007dd753bbf7191a8523"><td class="memItemLeft" align="right" valign="top">typedef skip_list::details::iterator&lt; typename base_class::iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ae8de0e2b1f72007dd753bbf7191a8523">iterator</a></td></tr>
<tr class="memdesc:ae8de0e2b1f72007dd753bbf7191a8523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward iterator.  <a href="#ae8de0e2b1f72007dd753bbf7191a8523">More...</a><br /></td></tr>
<tr class="separator:ae8de0e2b1f72007dd753bbf7191a8523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ce464e550466bf72dd0f387cf71d3c"><td class="memItemLeft" align="right" valign="top"><a id="ad2ce464e550466bf72dd0f387cf71d3c"></a>
typedef <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a457e4cc42df8bd25208a4a2e0dc80b2e">skip_list::details::iterator</a>&lt; typename base_class::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ad2ce464e550466bf72dd0f387cf71d3c">const_iterator</a></td></tr>
<tr class="memdesc:ad2ce464e550466bf72dd0f387cf71d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator type. <br /></td></tr>
<tr class="separator:ad2ce464e550466bf72dd0f387cf71d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972d341bdbd029b947fae1342e789b5e"><td class="memItemLeft" align="right" valign="top"><a id="a972d341bdbd029b947fae1342e789b5e"></a>
<a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ae8de0e2b1f72007dd753bbf7191a8523">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a972d341bdbd029b947fae1342e789b5e">begin</a> ()</td></tr>
<tr class="memdesc:a972d341bdbd029b947fae1342e789b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator addressing the first element in a map. <br /></td></tr>
<tr class="separator:a972d341bdbd029b947fae1342e789b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f541e18274ba358e302da00c49e147"><td class="memItemLeft" align="right" valign="top"><a id="ab9f541e18274ba358e302da00c49e147"></a>
<a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ad2ce464e550466bf72dd0f387cf71d3c">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ab9f541e18274ba358e302da00c49e147">begin</a> () const</td></tr>
<tr class="memdesc:ab9f541e18274ba358e302da00c49e147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a map. <br /></td></tr>
<tr class="separator:ab9f541e18274ba358e302da00c49e147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2856e43383404e9e760903bb20e1ec3"><td class="memItemLeft" align="right" valign="top"><a id="aa2856e43383404e9e760903bb20e1ec3"></a>
<a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ad2ce464e550466bf72dd0f387cf71d3c">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#aa2856e43383404e9e760903bb20e1ec3">cbegin</a> () const</td></tr>
<tr class="memdesc:aa2856e43383404e9e760903bb20e1ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a map. <br /></td></tr>
<tr class="separator:aa2856e43383404e9e760903bb20e1ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2c4d5bc6c6536740cea06b2d8110a9"><td class="memItemLeft" align="right" valign="top"><a id="a0e2c4d5bc6c6536740cea06b2d8110a9"></a>
<a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ae8de0e2b1f72007dd753bbf7191a8523">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a0e2c4d5bc6c6536740cea06b2d8110a9">end</a> ()</td></tr>
<tr class="memdesc:a0e2c4d5bc6c6536740cea06b2d8110a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator that addresses the location succeeding the last element in a map. <br /></td></tr>
<tr class="separator:a0e2c4d5bc6c6536740cea06b2d8110a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21763fd4079e392222fbe625b523f630"><td class="memItemLeft" align="right" valign="top"><a id="a21763fd4079e392222fbe625b523f630"></a>
<a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ad2ce464e550466bf72dd0f387cf71d3c">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a21763fd4079e392222fbe625b523f630">end</a> () const</td></tr>
<tr class="memdesc:a21763fd4079e392222fbe625b523f630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator that addresses the location succeeding the last element in a map. <br /></td></tr>
<tr class="separator:a21763fd4079e392222fbe625b523f630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9152b392635f558460606be3facbb686"><td class="memItemLeft" align="right" valign="top"><a id="a9152b392635f558460606be3facbb686"></a>
<a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ad2ce464e550466bf72dd0f387cf71d3c">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a9152b392635f558460606be3facbb686">cend</a> () const</td></tr>
<tr class="memdesc:a9152b392635f558460606be3facbb686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator that addresses the location succeeding the last element in a map. <br /></td></tr>
<tr class="separator:a9152b392635f558460606be3facbb686"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classcds_1_1intrusive_1_1_skip_list_set')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet&lt; cds::urcu::gc&lt; RCU &gt;, std::pair&lt; Key const, T &gt;, Traits &gt;</a></td></tr>
<tr class="memitem:ab687ac3a8e557334e59f7b0373b70f0d inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="ab687ac3a8e557334e59f7b0373b70f0d"></a>
typedef node_type::atomic_marked_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ab687ac3a8e557334e59f7b0373b70f0d">atomic_node_ptr</a></td></tr>
<tr class="memdesc:ab687ac3a8e557334e59f7b0373b70f0d inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic marked node pointer. <br /></td></tr>
<tr class="separator:ab687ac3a8e557334e59f7b0373b70f0d inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c805bcce3eb95b1fc81ed212a90b3c5 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a8c805bcce3eb95b1fc81ed212a90b3c5"></a>
typedef node_type::marked_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a8c805bcce3eb95b1fc81ed212a90b3c5">marked_node_ptr</a></td></tr>
<tr class="memdesc:a8c805bcce3eb95b1fc81ed212a90b3c5 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node marked pointer. <br /></td></tr>
<tr class="separator:a8c805bcce3eb95b1fc81ed212a90b3c5 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121ea0b7fdd8c0e6796409fce834305e inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a121ea0b7fdd8c0e6796409fce834305e"></a>
typedef cds::urcu::gc&lt; RCU &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a121ea0b7fdd8c0e6796409fce834305e">gc</a></td></tr>
<tr class="memdesc:a121ea0b7fdd8c0e6796409fce834305e inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br /></td></tr>
<tr class="separator:a121ea0b7fdd8c0e6796409fce834305e inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e97287193c265e405565645f3f3809 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a56e97287193c265e405565645f3f3809"></a>
typedef std::pair&lt; Key const, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a56e97287193c265e405565645f3f3809">value_type</a></td></tr>
<tr class="memdesc:a56e97287193c265e405565645f3f3809 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the skip-list <br /></td></tr>
<tr class="separator:a56e97287193c265e405565645f3f3809 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd2004e9bb6cf6a6df8cf39f9b00c27 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a0dd2004e9bb6cf6a6df8cf39f9b00c27"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a0dd2004e9bb6cf6a6df8cf39f9b00c27">traits</a></td></tr>
<tr class="memdesc:a0dd2004e9bb6cf6a6df8cf39f9b00c27 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits template parameter. <br /></td></tr>
<tr class="separator:a0dd2004e9bb6cf6a6df8cf39f9b00c27 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9abd070c6551d3fc3c46f0f70126c5 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a7c9abd070c6551d3fc3c46f0f70126c5"></a>
typedef traits::hook&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a7c9abd070c6551d3fc3c46f0f70126c5">hook</a></td></tr>
<tr class="memdesc:a7c9abd070c6551d3fc3c46f0f70126c5 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">hook type <br /></td></tr>
<tr class="separator:a7c9abd070c6551d3fc3c46f0f70126c5 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1c111410605d85dee2daf622820e34 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="aeb1c111410605d85dee2daf622820e34"></a>
typedef hook::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aeb1c111410605d85dee2daf622820e34">node_type</a></td></tr>
<tr class="memdesc:aeb1c111410605d85dee2daf622820e34 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">node type <br /></td></tr>
<tr class="separator:aeb1c111410605d85dee2daf622820e34 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4549fb15869b93cf05194c65fed873 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a3f4549fb15869b93cf05194c65fed873"></a>
typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a3f4549fb15869b93cf05194c65fed873">key_comparator</a></td></tr>
<tr class="memdesc:a3f4549fb15869b93cf05194c65fed873 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparison functor based on opt::compare and opt::less option setter. <br /></td></tr>
<tr class="separator:a3f4549fb15869b93cf05194c65fed873 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b394b2f922a1400b2eb2c3e6b2bacc inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="ae9b394b2f922a1400b2eb2c3e6b2bacc"></a>
typedef traits::disposer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ae9b394b2f922a1400b2eb2c3e6b2bacc">disposer</a></td></tr>
<tr class="memdesc:ae9b394b2f922a1400b2eb2c3e6b2bacc inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">item disposer <br /></td></tr>
<tr class="separator:ae9b394b2f922a1400b2eb2c3e6b2bacc inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7c65a30daf01ebe2e7c365f01d1129 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="ada7c65a30daf01ebe2e7c365f01d1129"></a>
typedef <a class="el" href="structcds_1_1intrusive_1_1get__node__traits.html">get_node_traits</a>&lt; <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a56e97287193c265e405565645f3f3809">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aeb1c111410605d85dee2daf622820e34">node_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a7c9abd070c6551d3fc3c46f0f70126c5">hook</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ada7c65a30daf01ebe2e7c365f01d1129">node_traits</a></td></tr>
<tr class="memdesc:ada7c65a30daf01ebe2e7c365f01d1129 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">node traits <br /></td></tr>
<tr class="separator:ada7c65a30daf01ebe2e7c365f01d1129 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ba2cd482243590355f3e07f31d5410 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="ad5ba2cd482243590355f3e07f31d5410"></a>
typedef traits::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ad5ba2cd482243590355f3e07f31d5410">item_counter</a></td></tr>
<tr class="memdesc:ad5ba2cd482243590355f3e07f31d5410 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy. <br /></td></tr>
<tr class="separator:ad5ba2cd482243590355f3e07f31d5410 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d335de0dc676276ffb41c842da0f0e inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="ac8d335de0dc676276ffb41c842da0f0e"></a>
typedef traits::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ac8d335de0dc676276ffb41c842da0f0e">memory_model</a></td></tr>
<tr class="memdesc:ac8d335de0dc676276ffb41c842da0f0e inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering, see <code><a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">cds::opt::memory_model</a></code> option. <br /></td></tr>
<tr class="separator:ac8d335de0dc676276ffb41c842da0f0e inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af8cf6e792b254e40124b677f946913 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a1af8cf6e792b254e40124b677f946913"></a>
typedef traits::random_level_generator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a1af8cf6e792b254e40124b677f946913">random_level_generator</a></td></tr>
<tr class="memdesc:a1af8cf6e792b254e40124b677f946913 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">random level generator <br /></td></tr>
<tr class="separator:a1af8cf6e792b254e40124b677f946913 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574d4a097c85e8f016b02775084d8188 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a574d4a097c85e8f016b02775084d8188"></a>
typedef traits::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a574d4a097c85e8f016b02775084d8188">allocator_type</a></td></tr>
<tr class="memdesc:a574d4a097c85e8f016b02775084d8188 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator for maintaining array of next pointers of the node <br /></td></tr>
<tr class="separator:a574d4a097c85e8f016b02775084d8188 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d807ce1c14954306ea2e1c51cb302b7 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a8d807ce1c14954306ea2e1c51cb302b7"></a>
typedef traits::back_off&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a8d807ce1c14954306ea2e1c51cb302b7">back_off</a></td></tr>
<tr class="memdesc:a8d807ce1c14954306ea2e1c51cb302b7 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Back-off strategy. <br /></td></tr>
<tr class="separator:a8d807ce1c14954306ea2e1c51cb302b7 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a61dadcef3d9667a679d57f7443a42 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="ae2a61dadcef3d9667a679d57f7443a42"></a>
typedef traits::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ae2a61dadcef3d9667a679d57f7443a42">stat</a></td></tr>
<tr class="memdesc:ae2a61dadcef3d9667a679d57f7443a42 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics type <br /></td></tr>
<tr class="separator:ae2a61dadcef3d9667a679d57f7443a42 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758da15b68e18ac7bd73c0f4aeae67f8 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a758da15b68e18ac7bd73c0f4aeae67f8"></a>
typedef gc::template <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a758da15b68e18ac7bd73c0f4aeae67f8">guarded_ptr</a>&lt; <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a56e97287193c265e405565645f3f3809">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a758da15b68e18ac7bd73c0f4aeae67f8">guarded_ptr</a></td></tr>
<tr class="memdesc:a758da15b68e18ac7bd73c0f4aeae67f8 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded pointer. <br /></td></tr>
<tr class="separator:a758da15b68e18ac7bd73c0f4aeae67f8 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5837aaa0b5d7e47b3df0b13c66ed4f inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">typedef skip_list::details::iterator&lt; <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a121ea0b7fdd8c0e6796409fce834305e">gc</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ada7c65a30daf01ebe2e7c365f01d1129">node_traits</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a8d807ce1c14954306ea2e1c51cb302b7">back_off</a>, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aef5837aaa0b5d7e47b3df0b13c66ed4f">iterator</a></td></tr>
<tr class="memdesc:aef5837aaa0b5d7e47b3df0b13c66ed4f inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#aef5837aaa0b5d7e47b3df0b13c66ed4f">More...</a><br /></td></tr>
<tr class="separator:aef5837aaa0b5d7e47b3df0b13c66ed4f inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf8dabaa6f1f1bacee706f8c71e0896 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="aadf8dabaa6f1f1bacee706f8c71e0896"></a>
typedef skip_list::details::iterator&lt; <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a121ea0b7fdd8c0e6796409fce834305e">gc</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ada7c65a30daf01ebe2e7c365f01d1129">node_traits</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a8d807ce1c14954306ea2e1c51cb302b7">back_off</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aadf8dabaa6f1f1bacee706f8c71e0896">const_iterator</a></td></tr>
<tr class="memdesc:aadf8dabaa6f1f1bacee706f8c71e0896 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator type. <br /></td></tr>
<tr class="separator:aadf8dabaa6f1f1bacee706f8c71e0896 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classcds_1_1intrusive_1_1_skip_list_set')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet&lt; cds::urcu::gc&lt; RCU &gt;, std::pair&lt; Key const, T &gt;, Traits &gt;</a></td></tr>
<tr class="memitem:ae919ad1a045a397fda269e2c2924b818 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ae919ad1a045a397fda269e2c2924b818">SkipListSet</a> ()</td></tr>
<tr class="memdesc:ae919ad1a045a397fda269e2c2924b818 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#ae919ad1a045a397fda269e2c2924b818">More...</a><br /></td></tr>
<tr class="separator:ae919ad1a045a397fda269e2c2924b818 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71bc587ae2e26e0fb5aae6fbc155e3f inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="aa71bc587ae2e26e0fb5aae6fbc155e3f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aa71bc587ae2e26e0fb5aae6fbc155e3f">~SkipListSet</a> ()</td></tr>
<tr class="memdesc:aa71bc587ae2e26e0fb5aae6fbc155e3f inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears and destructs the skip-list. <br /></td></tr>
<tr class="separator:aa71bc587ae2e26e0fb5aae6fbc155e3f inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51afff99d91ece7435020b6715697b91 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a51afff99d91ece7435020b6715697b91">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a56e97287193c265e405565645f3f3809">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a51afff99d91ece7435020b6715697b91 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a51afff99d91ece7435020b6715697b91">More...</a><br /></td></tr>
<tr class="separator:a51afff99d91ece7435020b6715697b91 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cce1422756e1f63a84f67c5a78d9553 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a8cce1422756e1f63a84f67c5a78d9553">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a56e97287193c265e405565645f3f3809">value_type</a> &amp;val, Func f)</td></tr>
<tr class="memdesc:a8cce1422756e1f63a84f67c5a78d9553 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a8cce1422756e1f63a84f67c5a78d9553">More...</a><br /></td></tr>
<tr class="separator:a8cce1422756e1f63a84f67c5a78d9553 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae105856d6ea412dc3283d01cfed5e1 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#acae105856d6ea412dc3283d01cfed5e1">update</a> (<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a56e97287193c265e405565645f3f3809">value_type</a> &amp;val, Func func, bool bInsert=true)</td></tr>
<tr class="memdesc:acae105856d6ea412dc3283d01cfed5e1 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the node.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#acae105856d6ea412dc3283d01cfed5e1">More...</a><br /></td></tr>
<tr class="separator:acae105856d6ea412dc3283d01cfed5e1 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0561887682f47f5358170b6a87ca18 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a6c0561887682f47f5358170b6a87ca18">unlink</a> (<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a56e97287193c265e405565645f3f3809">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a6c0561887682f47f5358170b6a87ca18 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlinks the item <code>val</code> from the set.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a6c0561887682f47f5358170b6a87ca18">More...</a><br /></td></tr>
<tr class="separator:a6c0561887682f47f5358170b6a87ca18 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b615614b9ee394bd38a60d71bb4156 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a758da15b68e18ac7bd73c0f4aeae67f8">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a90b615614b9ee394bd38a60d71bb4156">extract</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a90b615614b9ee394bd38a60d71bb4156 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item from the set with specified <code>key</code>.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a90b615614b9ee394bd38a60d71bb4156">More...</a><br /></td></tr>
<tr class="separator:a90b615614b9ee394bd38a60d71bb4156 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e441df6f9fc2627e95d320ee6375871 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a758da15b68e18ac7bd73c0f4aeae67f8">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a7e441df6f9fc2627e95d320ee6375871">extract_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a7e441df6f9fc2627e95d320ee6375871 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item from the set with comparing functor <code>pred</code>.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a7e441df6f9fc2627e95d320ee6375871">More...</a><br /></td></tr>
<tr class="separator:a7e441df6f9fc2627e95d320ee6375871 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ba518ea3321e4d0434b62ebeb6e19c inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a758da15b68e18ac7bd73c0f4aeae67f8">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a95ba518ea3321e4d0434b62ebeb6e19c">extract_min</a> ()</td></tr>
<tr class="memdesc:a95ba518ea3321e4d0434b62ebeb6e19c inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with minimal key from the list.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a95ba518ea3321e4d0434b62ebeb6e19c">More...</a><br /></td></tr>
<tr class="separator:a95ba518ea3321e4d0434b62ebeb6e19c inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e17af7064fa115bb4ef40789beac714 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a758da15b68e18ac7bd73c0f4aeae67f8">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a5e17af7064fa115bb4ef40789beac714">extract_max</a> ()</td></tr>
<tr class="memdesc:a5e17af7064fa115bb4ef40789beac714 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with maximal key from the list.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a5e17af7064fa115bb4ef40789beac714">More...</a><br /></td></tr>
<tr class="separator:a5e17af7064fa115bb4ef40789beac714 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442cc388b70130898a6a40e53e5286b6 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a442cc388b70130898a6a40e53e5286b6">erase</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a442cc388b70130898a6a40e53e5286b6 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a442cc388b70130898a6a40e53e5286b6">More...</a><br /></td></tr>
<tr class="separator:a442cc388b70130898a6a40e53e5286b6 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1831116fe2eaea39643d3fcb65371d5b inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a1831116fe2eaea39643d3fcb65371d5b">erase</a> (Q const &amp;key, Func f)</td></tr>
<tr class="memdesc:a1831116fe2eaea39643d3fcb65371d5b inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a1831116fe2eaea39643d3fcb65371d5b">More...</a><br /></td></tr>
<tr class="separator:a1831116fe2eaea39643d3fcb65371d5b inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e1caa5f872abb2fd071c6b6d43f016 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ad7e1caa5f872abb2fd071c6b6d43f016">erase_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:ad7e1caa5f872abb2fd071c6b6d43f016 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set with comparing functor <code>pred</code>.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#ad7e1caa5f872abb2fd071c6b6d43f016">More...</a><br /></td></tr>
<tr class="separator:ad7e1caa5f872abb2fd071c6b6d43f016 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b7ec55a6a3f0005cbf03a3829a67c7 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a06b7ec55a6a3f0005cbf03a3829a67c7">erase_with</a> (Q const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:a06b7ec55a6a3f0005cbf03a3829a67c7 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set with comparing functor <code>pred</code>.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a06b7ec55a6a3f0005cbf03a3829a67c7">More...</a><br /></td></tr>
<tr class="separator:a06b7ec55a6a3f0005cbf03a3829a67c7 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc70165841bf8871caed0a1f8c0dece inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a3dc70165841bf8871caed0a1f8c0dece">find</a> (Q &amp;key, Func f)</td></tr>
<tr class="memdesc:a3dc70165841bf8871caed0a1f8c0dece inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code>.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a3dc70165841bf8871caed0a1f8c0dece">More...</a><br /></td></tr>
<tr class="separator:a3dc70165841bf8871caed0a1f8c0dece inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90bce91b752b0998e66fc3e7ed403b6 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aa90bce91b752b0998e66fc3e7ed403b6">find_with</a> (Q &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:aa90bce91b752b0998e66fc3e7ed403b6 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code> with <code>pred</code> predicate for comparing.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#aa90bce91b752b0998e66fc3e7ed403b6">More...</a><br /></td></tr>
<tr class="separator:aa90bce91b752b0998e66fc3e7ed403b6 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36002a45fe274785c75df1ec1fb45f7b inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a36002a45fe274785c75df1ec1fb45f7b">contains</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a36002a45fe274785c75df1ec1fb45f7b inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>key</code>.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a36002a45fe274785c75df1ec1fb45f7b">More...</a><br /></td></tr>
<tr class="separator:a36002a45fe274785c75df1ec1fb45f7b inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9144433fb4828db74b8066ea785e775f inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a9144433fb4828db74b8066ea785e775f">contains</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a9144433fb4828db74b8066ea785e775f inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>key</code> using <code>pred</code> predicate for searching.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a9144433fb4828db74b8066ea785e775f">More...</a><br /></td></tr>
<tr class="separator:a9144433fb4828db74b8066ea785e775f inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba7de0d4e7a8f1097c481f46b7a1ca0 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a758da15b68e18ac7bd73c0f4aeae67f8">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a6ba7de0d4e7a8f1097c481f46b7a1ca0">get</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a6ba7de0d4e7a8f1097c481f46b7a1ca0 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> and return the item found.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a6ba7de0d4e7a8f1097c481f46b7a1ca0">More...</a><br /></td></tr>
<tr class="separator:a6ba7de0d4e7a8f1097c481f46b7a1ca0 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516aac70e4451b8b1df59510e0bdd6bc inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a758da15b68e18ac7bd73c0f4aeae67f8">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a516aac70e4451b8b1df59510e0bdd6bc">get_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a516aac70e4451b8b1df59510e0bdd6bc inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> and return the item found.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a516aac70e4451b8b1df59510e0bdd6bc">More...</a><br /></td></tr>
<tr class="separator:a516aac70e4451b8b1df59510e0bdd6bc inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b03c24311d1d458d3e4c2d508b2b12e inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a3b03c24311d1d458d3e4c2d508b2b12e">size</a> () const</td></tr>
<tr class="memdesc:a3b03c24311d1d458d3e4c2d508b2b12e inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a3b03c24311d1d458d3e4c2d508b2b12e">More...</a><br /></td></tr>
<tr class="separator:a3b03c24311d1d458d3e4c2d508b2b12e inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c86bda8d2579181ba1bda3f2ae32419 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a2c86bda8d2579181ba1bda3f2ae32419"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a2c86bda8d2579181ba1bda3f2ae32419">empty</a> () const</td></tr>
<tr class="memdesc:a2c86bda8d2579181ba1bda3f2ae32419 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty. <br /></td></tr>
<tr class="separator:a2c86bda8d2579181ba1bda3f2ae32419 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28947a855f1e0e702da233287eb3c59f inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a28947a855f1e0e702da233287eb3c59f">clear</a> ()</td></tr>
<tr class="memdesc:a28947a855f1e0e702da233287eb3c59f inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set (not atomic)  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a28947a855f1e0e702da233287eb3c59f">More...</a><br /></td></tr>
<tr class="separator:a28947a855f1e0e702da233287eb3c59f inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50eceb105e53ffdab01e8f5bb65fa62f inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a50eceb105e53ffdab01e8f5bb65fa62f"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ae2a61dadcef3d9667a679d57f7443a42">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a50eceb105e53ffdab01e8f5bb65fa62f">statistics</a> () const</td></tr>
<tr class="memdesc:a50eceb105e53ffdab01e8f5bb65fa62f inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br /></td></tr>
<tr class="separator:a50eceb105e53ffdab01e8f5bb65fa62f inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b00185809fb7842667287ed4a2ee0c2 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a4b00185809fb7842667287ed4a2ee0c2"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aef5837aaa0b5d7e47b3df0b13c66ed4f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a4b00185809fb7842667287ed4a2ee0c2">begin</a> ()</td></tr>
<tr class="memdesc:a4b00185809fb7842667287ed4a2ee0c2 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator addressing the first element in a set. <br /></td></tr>
<tr class="separator:a4b00185809fb7842667287ed4a2ee0c2 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae452d327ab88ee1bcc97592bdf91d2cc inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="ae452d327ab88ee1bcc97592bdf91d2cc"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aadf8dabaa6f1f1bacee706f8c71e0896">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ae452d327ab88ee1bcc97592bdf91d2cc">begin</a> () const</td></tr>
<tr class="memdesc:ae452d327ab88ee1bcc97592bdf91d2cc inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a set. <br /></td></tr>
<tr class="separator:ae452d327ab88ee1bcc97592bdf91d2cc inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c0269e4f5f6f1f2da64afb977b1dd3 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a67c0269e4f5f6f1f2da64afb977b1dd3"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aadf8dabaa6f1f1bacee706f8c71e0896">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a67c0269e4f5f6f1f2da64afb977b1dd3">cbegin</a> () const</td></tr>
<tr class="memdesc:a67c0269e4f5f6f1f2da64afb977b1dd3 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a set. <br /></td></tr>
<tr class="separator:a67c0269e4f5f6f1f2da64afb977b1dd3 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af350224256d13022cc13025597668139 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="af350224256d13022cc13025597668139"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aef5837aaa0b5d7e47b3df0b13c66ed4f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#af350224256d13022cc13025597668139">end</a> ()</td></tr>
<tr class="memdesc:af350224256d13022cc13025597668139 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator that addresses the location succeeding the last element in a set. <br /></td></tr>
<tr class="separator:af350224256d13022cc13025597668139 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d11738d37b967d2ae0be5bf3c883536 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a8d11738d37b967d2ae0be5bf3c883536"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aadf8dabaa6f1f1bacee706f8c71e0896">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a8d11738d37b967d2ae0be5bf3c883536">end</a> () const</td></tr>
<tr class="memdesc:a8d11738d37b967d2ae0be5bf3c883536 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator that addresses the location succeeding the last element in a set. <br /></td></tr>
<tr class="separator:a8d11738d37b967d2ae0be5bf3c883536 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e4f545922f036c2363f3f1eb0c9aa4 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="aa4e4f545922f036c2363f3f1eb0c9aa4"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aadf8dabaa6f1f1bacee706f8c71e0896">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aa4e4f545922f036c2363f3f1eb0c9aa4">cend</a> () const</td></tr>
<tr class="memdesc:aa4e4f545922f036c2363f3f1eb0c9aa4 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator that addresses the location succeeding the last element in a set. <br /></td></tr>
<tr class="separator:aa4e4f545922f036c2363f3f1eb0c9aa4 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classcds_1_1intrusive_1_1_skip_list_set"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classcds_1_1intrusive_1_1_skip_list_set')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet&lt; cds::urcu::gc&lt; RCU &gt;, std::pair&lt; Key const, T &gt;, Traits &gt;</a></td></tr>
<tr class="memitem:a891742e136dd2a31a2bdc80ecfdf73f4 inherit pro_static_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a891742e136dd2a31a2bdc80ecfdf73f4"></a>
static constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a891742e136dd2a31a2bdc80ecfdf73f4">max_height</a> () noexcept()</td></tr>
<tr class="memdesc:a891742e136dd2a31a2bdc80ecfdf73f4 inherit pro_static_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns maximum height of skip-list. The max height is a constant for each object and does not exceed 32. <br /></td></tr>
<tr class="separator:a891742e136dd2a31a2bdc80ecfdf73f4 inherit pro_static_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classcds_1_1intrusive_1_1_skip_list_set"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classcds_1_1intrusive_1_1_skip_list_set')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet&lt; cds::urcu::gc&lt; RCU &gt;, std::pair&lt; Key const, T &gt;, Traits &gt;</a></td></tr>
<tr class="memitem:a92a0f389d6be4dd2dc2ea005aa49e79e inherit pro_static_attribs_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">static unsigned int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a92a0f389d6be4dd2dc2ea005aa49e79e">c_nMaxHeight</a></td></tr>
<tr class="memdesc:a92a0f389d6be4dd2dc2ea005aa49e79e inherit pro_static_attribs_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max node height. The actual node height should be in range <code>[0 .. c_nMaxHeight)</code>  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a92a0f389d6be4dd2dc2ea005aa49e79e">More...</a><br /></td></tr>
<tr class="separator:a92a0f389d6be4dd2dc2ea005aa49e79e inherit pro_static_attribs_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad011a35dde50fa4b515466dadcf27a2 inherit pro_static_attribs_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="aad011a35dde50fa4b515466dadcf27a2"></a>
static size_t const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aad011a35dde50fa4b515466dadcf27a2">c_nHazardPtrCount</a></td></tr>
<tr class="memdesc:aad011a35dde50fa4b515466dadcf27a2 inherit pro_static_attribs_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of hazard pointer required for the skip-list. <br /></td></tr>
<tr class="separator:aad011a35dde50fa4b515466dadcf27a2 inherit pro_static_attribs_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename RCU, typename Key, typename T, typename Traits = skip_list::traits&gt;<br />
class cds::container::SkipListMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;</h3>

<p>Lock-free skip-list map (template specialization for <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_desc">RCU</a>) </p>
<p><a class="anchor" id="cds_nonintrusive_SkipListMap_rcu"></a> The implementation of well-known probabilistic data structure called skip-list invented by W.Pugh in his papers:</p><ul>
<li>[1989] W.Pugh Skip Lists: A Probabilistic Alternative to Balanced Trees</li>
<li>[1990] W.Pugh A Skip List Cookbook</li>
</ul>
<p>A skip-list is a probabilistic data structure that provides expected logarithmic time search without the need of rebalance. The skip-list is a collection of sorted linked list. Nodes are ordered by key. Each node is linked into a subset of the lists. Each list has a level, ranging from 0 to 32. The bottom-level list contains all the nodes, and each higher-level list is a sublist of the lower-level lists. Each node is created with a random top level (with a random height), and belongs to all lists up to that level. The probability that a node has the height 1 is 1/2. The probability that a node has the height N is 1/2 ** N (more precisely, the distribution depends on an random generator provided, but our generators have this property).</p>
<p>The lock-free variant of skip-list is implemented according to book</p><ul>
<li>[2008] M.Herlihy, N.Shavit "The Art of Multiprocessor Programming", chapter 14.4 "A Lock-Free Concurrent Skiplist"</li>
</ul>
<p>Template arguments:</p><ul>
<li><code>RCU</code> - one of <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_gc">RCU type</a>.</li>
<li><code>K</code> - type of a key to be stored in the list.</li>
<li><code>T</code> - type of a value to be stored in the list.</li>
<li><code>Traits</code> - map traits, default is <code><a class="el" href="structcds_1_1container_1_1skip__list_1_1traits.html" title="SkipListSet traits. ">skip_list::traits</a></code>. It is possible to declare option-based list with <code><a class="el" href="structcds_1_1container_1_1skip__list_1_1make__traits.html" title="Metafunction converting option list to SkipListSet traits. ">cds::container::skip_list::make_traits</a></code> metafunction instead of <code>Traits</code> template argument.</li>
</ul>
<p>Like STL map class, <code>SkipListMap</code> stores its key-value pair as <code>std:pair&lt; K const, T&gt;</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Before including <code>&lt;cds/container/skip_list_map_rcu.h&gt;</code> you should include appropriate RCU header file, see <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_gc">RCU type</a> for list of existing RCU class and corresponding header files.</dd></dl>
<p><b>Iterators</b></p>
<p>The class supports a forward iterator (<a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ae8de0e2b1f72007dd753bbf7191a8523">iterator</a> and <a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ad2ce464e550466bf72dd0f387cf71d3c">const_iterator</a>). The iteration is ordered. You may iterate over skip-list set items only under RCU lock. Only in this case the iterator is thread-safe since while RCU is locked any set's item cannot be reclaimed.</p>
<p>The requirement of RCU lock during iterating means that deletion of the elements (i.e. <a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a33830c59e1a27dc4f04c106ba7f148d6">erase</a>) is not possible.</p>
<dl class="section warning"><dt>Warning</dt><dd>The iterator object cannot be passed between threads</dd></dl>
<p>The iterator class supports the following minimalistic interface: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ae8de0e2b1f72007dd753bbf7191a8523">iterator</a> {</div><div class="line">    <span class="comment">// Default ctor</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ae8de0e2b1f72007dd753bbf7191a8523">iterator</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Copy ctor</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ae8de0e2b1f72007dd753bbf7191a8523">iterator</a>( <a class="code" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ae8de0e2b1f72007dd753bbf7191a8523">iterator</a> <span class="keyword">const</span>&amp; s);</div><div class="line"></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a5234aa90b9e7eaa8424c3732e7dfddbe">value_type</a> * operator -&gt;() <span class="keyword">const</span>;</div><div class="line">    <a class="code" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a5234aa90b9e7eaa8424c3732e7dfddbe">value_type</a>&amp; operator *() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Pre-increment</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ae8de0e2b1f72007dd753bbf7191a8523">iterator</a>&amp; operator ++();</div><div class="line"></div><div class="line">    <span class="comment">// Copy assignment</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ae8de0e2b1f72007dd753bbf7191a8523">iterator</a>&amp; operator = (<span class="keyword">const</span> <a class="code" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ae8de0e2b1f72007dd753bbf7191a8523">iterator</a>&amp; src);</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> operator ==(<a class="code" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ae8de0e2b1f72007dd753bbf7191a8523">iterator</a> <span class="keyword">const</span>&amp; i ) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">bool</span> operator !=(<a class="code" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ae8de0e2b1f72007dd753bbf7191a8523">iterator</a> <span class="keyword">const</span>&amp; i ) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p> Note, the iterator object returned by <a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a0e2c4d5bc6c6536740cea06b2d8110a9">end</a>, <code>cend</code> member functions points to <code>nullptr</code> and should not be dereferenced. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae8de0e2b1f72007dd753bbf7191a8523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8de0e2b1f72007dd753bbf7191a8523">&sect;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef skip_list::details::iterator&lt; typename base_class::iterator &gt; <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a607e6f9399217c2abb1e7d172b756b1e">cds::urcu::gc</a>&lt; RCU &gt;, Key, T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ae8de0e2b1f72007dd753bbf7191a8523">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forward iterator. </p>
<p>The forward iterator has some features:</p><ul>
<li>it has no post-increment operator</li>
<li>it depends on iterator of underlying <code>OrderedList</code> </li>
</ul>
<p>You may safely use iterators in multi-threaded environment only under RCU lock. Otherwise, a crash is possible if another thread deletes the element the iterator points to. </p>

</div>
</div>
<a id="aa4437a4b82ffae452dd9965e3f0dae36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4437a4b82ffae452dd9965e3f0dae36">&sect;&nbsp;</a></span>rcu_lock</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_class::rcu_lock <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a607e6f9399217c2abb1e7d172b756b1e">cds::urcu::gc</a>&lt; RCU &gt;, Key, T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#aa4437a4b82ffae452dd9965e3f0dae36">rcu_lock</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RCU scoped lock </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a80c988c8df76dae5e99390c1600dcd99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c988c8df76dae5e99390c1600dcd99">&sect;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a607e6f9399217c2abb1e7d172b756b1e">cds::urcu::gc</a>&lt; RCU &gt;, Key, T, Traits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the map contains <code>key</code>. </p>
<p>The function searches the item with key equal to <code>key</code> and returns <code>true</code> if it is found, and <code>false</code> otherwise.</p>
<p>The function applies RCU lock internally. </p>

</div>
</div>
<a id="aa974b413e15121f36efe968d90ab758e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa974b413e15121f36efe968d90ab758e">&sect;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a607e6f9399217c2abb1e7d172b756b1e">cds::urcu::gc</a>&lt; RCU &gt;, Key, T, Traits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the map contains <code>key</code> using <code>pred</code> predicate for searching. </p>
<p>The function is similar to <code>contains( key )</code> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a id="a08193421ee3ecc2f576cd89405c91e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08193421ee3ecc2f576cd89405c91e03">&sect;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a607e6f9399217c2abb1e7d172b756b1e">cds::urcu::gc</a>&lt; RCU &gt;, Key, T, Traits &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For key <code>key</code> inserts data of type <code>value_type</code> created in-place from <code>args</code>. </p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise.</p>
<p>RCU <code>synchronize()</code> method can be called. RCU should not be locked. </p>

</div>
</div>
<a id="ab5f809b94002b7fb312af2be52f8f438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f809b94002b7fb312af2be52f8f438">&sect;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a607e6f9399217c2abb1e7d172b756b1e">cds::urcu::gc</a>&lt; RCU &gt;, Key, T, Traits &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the map is empty. </p>
<p>Emptiness is checked by item counting: if item count is zero then the map is empty. </p>

</div>
</div>
<a id="a33830c59e1a27dc4f04c106ba7f148d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33830c59e1a27dc4f04c106ba7f148d6">&sect;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a607e6f9399217c2abb1e7d172b756b1e">cds::urcu::gc</a>&lt; RCU &gt;, Key, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the map. </p>
<p><a class="anchor" id="cds_nonintrusive_SkipListMap_rcu_erase_val"></a> RCU <code>synchronize</code> method can be called. RCU should not be locked.</p>
<p>Return <code>true</code> if <code>key</code> is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a id="a11ae3bc414ead99a641f7cc34e0d1c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ae3bc414ead99a641f7cc34e0d1c7f">&sect;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a607e6f9399217c2abb1e7d172b756b1e">cds::urcu::gc</a>&lt; RCU &gt;, Key, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the map. </p>
<p><a class="anchor" id="cds_nonintrusive_SkipListMap_rcu_erase_func"></a> The function searches an item with key <code>key</code>, calls <code>f</code> functor and deletes the item. If <code>key</code> is not found, the functor is not called.</p>
<p>The functor <code>Func</code> interface: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>extractor {</div><div class="line">    <span class="keywordtype">void</span> operator()(<a class="code" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a5234aa90b9e7eaa8424c3732e7dfddbe">value_type</a>&amp; item) { ... }</div><div class="line">};</div></div><!-- fragment --><p>RCU <code>synchronize</code> method can be called. RCU should not be locked.</p>
<p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a id="ae8ecd16cab44082e831187b7fbd5add2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ecd16cab44082e831187b7fbd5add2">&sect;&nbsp;</a></span>erase_with() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a607e6f9399217c2abb1e7d172b756b1e">cds::urcu::gc</a>&lt; RCU &gt;, Key, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the map using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#cds_nonintrusive_SkipListMap_rcu_erase_val">erase(K const&amp;)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a id="ae9829639614690fe81c89aeb550756c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9829639614690fe81c89aeb550756c5">&sect;&nbsp;</a></span>erase_with() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a607e6f9399217c2abb1e7d172b756b1e">cds::urcu::gc</a>&lt; RCU &gt;, Key, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the map using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#cds_nonintrusive_SkipListMap_rcu_erase_func">erase(K const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a id="affbd6d8a9164159c2813ea4c33ce3172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affbd6d8a9164159c2813ea4c33ce3172">&sect;&nbsp;</a></span>extract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ad793833cd6a6363a487427e4ee31d531">exempt_ptr</a> <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a607e6f9399217c2abb1e7d172b756b1e">cds::urcu::gc</a>&lt; RCU &gt;, Key, T, Traits &gt;::extract </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the item from the map with specified <code>key</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_SkipListMap_rcu_extract"></a>The function searches an item with key equal to <code>key</code> in the map, unlinks it from the set, and returns <a class="el" href="classcds_1_1urcu_1_1exempt__ptr.html">exempt_ptr</a> pointer to the item found. If the item is not found the function returns an empty <code>exempt_ptr</code> </p>
<p>Note the compare functor from <code>Traits</code> class' template argument should accept a parameter of type <code>K</code> that can be not the same as <code>key_type</code>.</p>
<p>RCU <code>synchronize()</code> method can be called. RCU should NOT be locked.</p>
<p>The function does not free the item found. The item will be implicitly freed when the returned object is destroyed or when its <code>release()</code> member function is called. </p>

</div>
</div>
<a id="aee26a22d61d61a9a72c7b8edb0c88162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee26a22d61d61a9a72c7b8edb0c88162">&sect;&nbsp;</a></span>extract_max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ad793833cd6a6363a487427e4ee31d531">exempt_ptr</a> <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a607e6f9399217c2abb1e7d172b756b1e">cds::urcu::gc</a>&lt; RCU &gt;, Key, T, Traits &gt;::extract_max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item with maximal key from the map. </p>
<p>The function searches an item with maximal key, unlinks it from the set, and returns <a class="el" href="classcds_1_1urcu_1_1exempt__ptr.html">exempt_ptr</a> pointer to the item. If the skip-list is empty the function returns an empty <code>exempt_ptr</code>.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should NOT be locked.</p>
<p>The function does not free the item found. The item will be implicitly freed when the returned object is destroyed or when its <code>release()</code> member function is called. </p>

</div>
</div>
<a id="aa35fe7c0c2b37037a68198244ced4064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa35fe7c0c2b37037a68198244ced4064">&sect;&nbsp;</a></span>extract_min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ad793833cd6a6363a487427e4ee31d531">exempt_ptr</a> <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a607e6f9399217c2abb1e7d172b756b1e">cds::urcu::gc</a>&lt; RCU &gt;, Key, T, Traits &gt;::extract_min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item with minimal key from the map. </p>
<p>The function searches an item with minimal key, unlinks it, and returns <a class="el" href="classcds_1_1urcu_1_1exempt__ptr.html">exempt_ptr</a> pointer to the item. If the skip-list is empty the function returns an empty <code>exempt_ptr</code>.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should NOT be locked.</p>
<p>The function does not free the item found. The item will be implicitly freed when the returned object is destroyed or when its <code>release()</code> member function is called. </p>

</div>
</div>
<a id="af5ebe0f106a85072767a297ae4ecbb36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ebe0f106a85072767a297ae4ecbb36">&sect;&nbsp;</a></span>extract_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ad793833cd6a6363a487427e4ee31d531">exempt_ptr</a> <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a607e6f9399217c2abb1e7d172b756b1e">cds::urcu::gc</a>&lt; RCU &gt;, Key, T, Traits &gt;::extract_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the item from the map with comparing functor <code>pred</code>. </p>
<p>The function is an analog of <code><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#affbd6d8a9164159c2813ea4c33ce3172" title="Extracts the item from the map with specified key. ">extract(K const&amp;)</a></code> but <code>pred</code> predicate is used for key comparing. <code>Less</code> has the semantics like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a id="a624f4560772cc0bfd9357f11f9030f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624f4560772cc0bfd9357f11f9030f81">&sect;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a607e6f9399217c2abb1e7d172b756b1e">cds::urcu::gc</a>&lt; RCU &gt;, Key, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>key</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_SkipListMap_rcu_find_cfunc"></a> The function searches the item with key equal to <code>key</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div><div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a5234aa90b9e7eaa8424c3732e7dfddbe">value_type</a>&amp; item );</div><div class="line">};</div></div><!-- fragment --><p> where <code>item</code> is the item found.</p>
<p>The functor may change <code>item.second</code>.</p>
<p>The function applies RCU lock internally.</p>
<p>The function returns <code>true</code> if <code>key</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a id="aa0eb86986df2465845d0bc922a762ebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0eb86986df2465845d0bc922a762ebf">&sect;&nbsp;</a></span>find_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a607e6f9399217c2abb1e7d172b756b1e">cds::urcu::gc</a>&lt; RCU &gt;, Key, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#cds_nonintrusive_SkipListMap_rcu_find_cfunc">find(K const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a id="a4f720be58b42f25432176750a6534029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f720be58b42f25432176750a6534029">&sect;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a8af29d35cb5176743c6ad76fab351ccd">raw_ptr</a> <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a607e6f9399217c2abb1e7d172b756b1e">cds::urcu::gc</a>&lt; RCU &gt;, Key, T, Traits &gt;::get </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>key</code> and return the item found. </p>
<p><a class="anchor" id="cds_nonintrusive_SkipListMap_rcu_get"></a>The function searches the item with key equal to <code>key</code> and returns a <code>raw_ptr</code> object pointing to an item found. If <code>key</code> is not found it returns empty <code>raw_ptr</code>.</p>
<p>Note the compare functor in <code>Traits</code> class' template argument should accept a parameter of type <code>K</code> that can be not the same as <code>key_type</code>.</p>
<p>RCU should be locked before call of this function. Returned item is valid only while RCU is locked: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap&lt; cds::urcu::gc&lt; cds::urcu::general_buffered&lt;&gt;</a> &gt;, int, foo, my_traits &gt; skip_list;</div><div class="line">skip_list theList;</div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">typename</span> skip_list::raw_ptr pVal;</div><div class="line">{</div><div class="line">    <span class="comment">// Lock RCU</span></div><div class="line">    skip_list::rcu_lock lock;</div><div class="line"></div><div class="line">    pVal = theList.get( 5 );</div><div class="line">    <span class="keywordflow">if</span> ( pVal ) {</div><div class="line">        <span class="comment">// Deal with pVal</span></div><div class="line">        <span class="comment">//...</span></div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="comment">// You can manually release pVal after RCU-locked section</span></div><div class="line">pVal.release();</div></div><!-- fragment --> 
</div>
</div>
<a id="a8ee63cb325e31fa057c2c4334500c8e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee63cb325e31fa057c2c4334500c8e8">&sect;&nbsp;</a></span>get_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a8af29d35cb5176743c6ad76fab351ccd">raw_ptr</a> <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a607e6f9399217c2abb1e7d172b756b1e">cds::urcu::gc</a>&lt; RCU &gt;, Key, T, Traits &gt;::get_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>key</code> and return the item found. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#cds_nonintrusive_SkipListMap_rcu_get">get(K const&amp;)</a> but <code>pred</code> is used for comparing the keys.</p>
<p><code>Less</code> functor has the semantics like <code>std::less</code> but should take arguments of type <a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a990b253457b725e094c126ea9a71fef3">key_type</a> and <code>K</code> in any order. <code>pred</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a id="a877fb2f6a50d28f4202a4b8699e75000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877fb2f6a50d28f4202a4b8699e75000">&sect;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a607e6f9399217c2abb1e7d172b756b1e">cds::urcu::gc</a>&lt; RCU &gt;, Key, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node with key and default value. </p>
<p>The function creates a node with <code>key</code> and default value, and then inserts the node created into the map.</p>
<p>Preconditions:</p><ul>
<li>The <code>key_type</code> should be constructible from a value of type <code>K</code>. In trivial case, <code>K</code> is equal to <code>key_type</code>.</li>
<li>The <code>mapped_type</code> should be default-constructible.</li>
</ul>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked.</p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise. </p>

</div>
</div>
<a id="a3f9036ea2f2b5cf943bac33fc367afda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9036ea2f2b5cf943bac33fc367afda">&sect;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a607e6f9399217c2abb1e7d172b756b1e">cds::urcu::gc</a>&lt; RCU &gt;, Key, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function creates a node with copy of <code>val</code> value and then inserts the node created into the map.</p>
<p>Preconditions:</p><ul>
<li>The <code>key_type</code> should be constructible from <code>key</code> of type <code>K</code>.</li>
<li>The <code>value_type</code> should be constructible from <code>val</code> of type <code>V</code>.</li>
</ul>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked.</p>
<p>Returns <code>true</code> if <code>val</code> is inserted into the set, <code>false</code> otherwise. </p>

</div>
</div>
<a id="aaf451841ee82289c5a442c619346d02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf451841ee82289c5a442c619346d02b">&sect;&nbsp;</a></span>insert_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a607e6f9399217c2abb1e7d172b756b1e">cds::urcu::gc</a>&lt; RCU &gt;, Key, T, Traits &gt;::insert_with </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node and initialize it by a functor. </p>
<p>This function inserts new node with key <code>key</code> and if inserting is successful then it calls <code>func</code> functor with signature </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div><div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a5234aa90b9e7eaa8424c3732e7dfddbe">value_type</a>&amp; item );</div><div class="line">};</div></div><!-- fragment --><p>The argument <code>item</code> of user-defined functor <code>func</code> is the reference to the map's item inserted:</p><ul>
<li><code>item.first</code> is a const reference to item's key that cannot be changed.</li>
<li><code>item.second</code> is a reference to item's value that may be changed.</li>
</ul>
<p>The function allows to split creating of new item into three part:</p><ul>
<li>create item from <code>key</code>;</li>
<li>insert new item into the map;</li>
<li>if inserting is successful, initialize the value of item by calling <code>func</code> functor</li>
</ul>
<p>This can be useful if complete initialization of object of <code>value_type</code> is heavyweight and it is preferable that the initialization should be completed only if inserting is successful.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked. </p>

</div>
</div>
<a id="a670e057905fbd297ca65c22564140222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a670e057905fbd297ca65c22564140222">&sect;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a607e6f9399217c2abb1e7d172b756b1e">cds::urcu::gc</a>&lt; RCU &gt;, Key, T, Traits &gt;::update </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bInsert</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates data by <code>key</code>. </p>
<p>The operation performs inserting or changing data with lock-free manner.</p>
<p>If the <code>key</code> not found in the map, then the new item created from <code>key</code> is inserted into the map iff <code>bInsert</code> is <code>true</code>. Otherwise, if <code>key</code> found, the functor <code>func</code> is called with item found. The functor <code>Func</code> interface is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>my_functor {</div><div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a5234aa90b9e7eaa8424c3732e7dfddbe">value_type</a>&amp; item );</div><div class="line">};</div></div><!-- fragment --><p> where:</p><ul>
<li><code>bNew</code> - <code>true</code> if the item has been inserted, <code>false</code> otherwise</li>
<li><code>item</code> - item of the map</li>
</ul>
<p>The functor may change any fields of <code>item.second</code>.</p>
<p>RCU <code>synchronize()</code> method can be called. RCU should not be locked.</p>
<p>Returns <code> std::pair&lt;bool, bool&gt; </code> where <code>first</code> is <code>true</code> if operation is successful, <code>second</code> is <code>true</code> if new item has been added or <code>false</code> if the item with <code>key</code> already exists.</p>
<dl class="section warning"><dt>Warning</dt><dd>See <a class="el" href="namespacecds_1_1intrusive.html#cds_intrusive_item_creating">insert item troubleshooting</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/container/skip_list_map_rcu.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.2.0</b> 
  Developed by <i>Maxim Khizhinsky aka khizmax</i> 2007 - 2017
  <br/>
  <i>Autogenerated Wed Jan 4 2017 08:49:41 by Doxygen 1.8.12</i>
</div>
</body>
</html>
