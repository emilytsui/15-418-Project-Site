<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cds: cds::container::MichaelList&lt; GC, T, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcds_1_1container_1_1_michael_list.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::MichaelList&lt; GC, T, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__nonintrusive__containers.html">Non-intrusive containers</a> &raquo; <a class="el" href="group__cds__nonintrusive__list.html">List</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Michael's ordered list.  
 <a href="classcds_1_1container_1_1_michael_list.html#details">More...</a></p>

<p><code>#include &lt;cds/container/impl/michael_list.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::container::MichaelList&lt; GC, T, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1container_1_1_michael_list.png" usemap="#cds::container::MichaelList_3C_20GC_2C_20T_2C_20Traits_20_3E_map" alt=""/>
  <map id="cds::container::MichaelList_3C_20GC_2C_20T_2C_20Traits_20_3E_map" name="cds::container::MichaelList&lt; GC, T, Traits &gt;_map">
<area href="classcds_1_1intrusive_1_1_michael_list.html" title="Michael&#39;s lock-free ordered single-linked list. " alt="cds::intrusive::MichaelList&lt; GC, T, Traits &gt;" shape="rect" coords="0,0,259,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a90906981ca9a1cbcb3240d2018816672"><td class="memItemLeft" align="right" valign="top"><a id="a90906981ca9a1cbcb3240d2018816672"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#a90906981ca9a1cbcb3240d2018816672">value_type</a></td></tr>
<tr class="memdesc:a90906981ca9a1cbcb3240d2018816672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of value stored in the list. <br /></td></tr>
<tr class="separator:a90906981ca9a1cbcb3240d2018816672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee516a216bfb0e3eaf44cb2f535a35e4"><td class="memItemLeft" align="right" valign="top"><a id="aee516a216bfb0e3eaf44cb2f535a35e4"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#aee516a216bfb0e3eaf44cb2f535a35e4">traits</a></td></tr>
<tr class="memdesc:aee516a216bfb0e3eaf44cb2f535a35e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">List traits. <br /></td></tr>
<tr class="separator:aee516a216bfb0e3eaf44cb2f535a35e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328d3c19491375f0837dfa0e7d5a50c0"><td class="memItemLeft" align="right" valign="top"><a id="a328d3c19491375f0837dfa0e7d5a50c0"></a>
typedef base_class::gc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#a328d3c19491375f0837dfa0e7d5a50c0">gc</a></td></tr>
<tr class="memdesc:a328d3c19491375f0837dfa0e7d5a50c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector used. <br /></td></tr>
<tr class="separator:a328d3c19491375f0837dfa0e7d5a50c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e159daccc63b0913e6efb9b963d596e"><td class="memItemLeft" align="right" valign="top"><a id="a0e159daccc63b0913e6efb9b963d596e"></a>
typedef base_class::back_off&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#a0e159daccc63b0913e6efb9b963d596e">back_off</a></td></tr>
<tr class="memdesc:a0e159daccc63b0913e6efb9b963d596e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Back-off strategy used. <br /></td></tr>
<tr class="separator:a0e159daccc63b0913e6efb9b963d596e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd474d50e13f83b78d4aba0182152826"><td class="memItemLeft" align="right" valign="top"><a id="afd474d50e13f83b78d4aba0182152826"></a>
typedef maker::allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#afd474d50e13f83b78d4aba0182152826">allocator_type</a></td></tr>
<tr class="memdesc:afd474d50e13f83b78d4aba0182152826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator type used for allocate/deallocate the nodes. <br /></td></tr>
<tr class="separator:afd474d50e13f83b78d4aba0182152826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9738498d25d8c48da8085a1f4e937346"><td class="memItemLeft" align="right" valign="top"><a id="a9738498d25d8c48da8085a1f4e937346"></a>
typedef base_class::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#a9738498d25d8c48da8085a1f4e937346">item_counter</a></td></tr>
<tr class="memdesc:a9738498d25d8c48da8085a1f4e937346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy used. <br /></td></tr>
<tr class="separator:a9738498d25d8c48da8085a1f4e937346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f5920ea2fb7328bc766f493652f799"><td class="memItemLeft" align="right" valign="top"><a id="a80f5920ea2fb7328bc766f493652f799"></a>
typedef maker::key_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#a80f5920ea2fb7328bc766f493652f799">key_comparator</a></td></tr>
<tr class="memdesc:a80f5920ea2fb7328bc766f493652f799"><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparison functor <br /></td></tr>
<tr class="separator:a80f5920ea2fb7328bc766f493652f799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7039eb820e53fcc60baa632664361f25"><td class="memItemLeft" align="right" valign="top"><a id="a7039eb820e53fcc60baa632664361f25"></a>
typedef base_class::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#a7039eb820e53fcc60baa632664361f25">memory_model</a></td></tr>
<tr class="memdesc:a7039eb820e53fcc60baa632664361f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering. See <code><a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">cds::opt::memory_model</a></code> option. <br /></td></tr>
<tr class="separator:a7039eb820e53fcc60baa632664361f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73c8ebe0317fe77c7726ee5bebe2cf7"><td class="memItemLeft" align="right" valign="top"><a id="ae73c8ebe0317fe77c7726ee5bebe2cf7"></a>
typedef base_class::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#ae73c8ebe0317fe77c7726ee5bebe2cf7">stat</a></td></tr>
<tr class="memdesc:ae73c8ebe0317fe77c7726ee5bebe2cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics. <br /></td></tr>
<tr class="separator:ae73c8ebe0317fe77c7726ee5bebe2cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed12d6f534bb7a919201c9d6f4890ff3"><td class="memItemLeft" align="right" valign="top"><a id="aed12d6f534bb7a919201c9d6f4890ff3"></a>
typedef gc::template <a class="el" href="classcds_1_1container_1_1_michael_list.html#aed12d6f534bb7a919201c9d6f4890ff3">guarded_ptr</a>&lt; <a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#aa92ea390b599d84e5142839aa4b50652">node_type</a>, <a class="el" href="classcds_1_1container_1_1_michael_list.html#a90906981ca9a1cbcb3240d2018816672">value_type</a>, details::guarded_ptr_cast_set&lt; <a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#aa92ea390b599d84e5142839aa4b50652">node_type</a>, <a class="el" href="classcds_1_1container_1_1_michael_list.html#a90906981ca9a1cbcb3240d2018816672">value_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#aed12d6f534bb7a919201c9d6f4890ff3">guarded_ptr</a></td></tr>
<tr class="memdesc:aed12d6f534bb7a919201c9d6f4890ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded pointer. <br /></td></tr>
<tr class="separator:aed12d6f534bb7a919201c9d6f4890ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a676f5c9655fa8a7c8b3c2abaac723bd7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#a676f5c9655fa8a7c8b3c2abaac723bd7">MichaelList</a> ()</td></tr>
<tr class="memdesc:a676f5c9655fa8a7c8b3c2abaac723bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a676f5c9655fa8a7c8b3c2abaac723bd7">More...</a><br /></td></tr>
<tr class="separator:a676f5c9655fa8a7c8b3c2abaac723bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c61670fe6e25a02be68ec0de6f4ef7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#a95c61670fe6e25a02be68ec0de6f4ef7">~MichaelList</a> ()</td></tr>
<tr class="memdesc:a95c61670fe6e25a02be68ec0de6f4ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">List destructor.  <a href="#a95c61670fe6e25a02be68ec0de6f4ef7">More...</a><br /></td></tr>
<tr class="separator:a95c61670fe6e25a02be68ec0de6f4ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5c9ee1e8160f907c8ca81cb6543566"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a5d5c9ee1e8160f907c8ca81cb6543566"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#a5d5c9ee1e8160f907c8ca81cb6543566">insert</a> (Q &amp;&amp;val)</td></tr>
<tr class="memdesc:a5d5c9ee1e8160f907c8ca81cb6543566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a5d5c9ee1e8160f907c8ca81cb6543566">More...</a><br /></td></tr>
<tr class="separator:a5d5c9ee1e8160f907c8ca81cb6543566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890764c4e82bc23e350da0ddc50436ca"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a890764c4e82bc23e350da0ddc50436ca"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#a890764c4e82bc23e350da0ddc50436ca">insert</a> (Q &amp;&amp;key, Func func)</td></tr>
<tr class="memdesc:a890764c4e82bc23e350da0ddc50436ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a890764c4e82bc23e350da0ddc50436ca">More...</a><br /></td></tr>
<tr class="separator:a890764c4e82bc23e350da0ddc50436ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a043623ccf8aef7fe0008d8da56752d"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a7a043623ccf8aef7fe0008d8da56752d"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#a7a043623ccf8aef7fe0008d8da56752d">update</a> (Q const &amp;key, Func func, bool bAllowInsert=true)</td></tr>
<tr class="memdesc:a7a043623ccf8aef7fe0008d8da56752d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates data by <code>key</code>.  <a href="#a7a043623ccf8aef7fe0008d8da56752d">More...</a><br /></td></tr>
<tr class="separator:a7a043623ccf8aef7fe0008d8da56752d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877c6f957db11c64d373a5823e27e9b4"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a877c6f957db11c64d373a5823e27e9b4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#a877c6f957db11c64d373a5823e27e9b4">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a877c6f957db11c64d373a5823e27e9b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts data of type <code>value_type</code> constructed with <code>std::forward&lt;Args&gt;(args)...</code>  <a href="#a877c6f957db11c64d373a5823e27e9b4">More...</a><br /></td></tr>
<tr class="separator:a877c6f957db11c64d373a5823e27e9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d09caf072bbe7fbfb73e96e193153c2"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a7d09caf072bbe7fbfb73e96e193153c2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#a7d09caf072bbe7fbfb73e96e193153c2">erase</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a7d09caf072bbe7fbfb73e96e193153c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the list.  <a href="#a7d09caf072bbe7fbfb73e96e193153c2">More...</a><br /></td></tr>
<tr class="separator:a7d09caf072bbe7fbfb73e96e193153c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff3bedb4c832bbaab88e6cc5a501124"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:afff3bedb4c832bbaab88e6cc5a501124"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#afff3bedb4c832bbaab88e6cc5a501124">erase_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:afff3bedb4c832bbaab88e6cc5a501124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the list using <code>pred</code> predicate for searching.  <a href="#afff3bedb4c832bbaab88e6cc5a501124">More...</a><br /></td></tr>
<tr class="separator:afff3bedb4c832bbaab88e6cc5a501124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5db2856cd2f52ea1db33f247dc3bf7"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a2b5db2856cd2f52ea1db33f247dc3bf7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#a2b5db2856cd2f52ea1db33f247dc3bf7">erase</a> (Q const &amp;key, Func f)</td></tr>
<tr class="memdesc:a2b5db2856cd2f52ea1db33f247dc3bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes <code>key</code> from the list.  <a href="#a2b5db2856cd2f52ea1db33f247dc3bf7">More...</a><br /></td></tr>
<tr class="separator:a2b5db2856cd2f52ea1db33f247dc3bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05de5b48fba190c5732fc6a49328eeb5"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a05de5b48fba190c5732fc6a49328eeb5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#a05de5b48fba190c5732fc6a49328eeb5">erase_with</a> (Q const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:a05de5b48fba190c5732fc6a49328eeb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the list using <code>pred</code> predicate for searching.  <a href="#a05de5b48fba190c5732fc6a49328eeb5">More...</a><br /></td></tr>
<tr class="separator:a05de5b48fba190c5732fc6a49328eeb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f881391b70725d2f3a40e16c7e7489b"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a4f881391b70725d2f3a40e16c7e7489b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_michael_list.html#aed12d6f534bb7a919201c9d6f4890ff3">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#a4f881391b70725d2f3a40e16c7e7489b">extract</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a4f881391b70725d2f3a40e16c7e7489b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item from the list with specified <code>key</code>.  <a href="#a4f881391b70725d2f3a40e16c7e7489b">More...</a><br /></td></tr>
<tr class="separator:a4f881391b70725d2f3a40e16c7e7489b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06774f490d9d410433d4243052cc8e37"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a06774f490d9d410433d4243052cc8e37"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_michael_list.html#aed12d6f534bb7a919201c9d6f4890ff3">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#a06774f490d9d410433d4243052cc8e37">extract_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a06774f490d9d410433d4243052cc8e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item from the list with comparing functor <code>pred</code>.  <a href="#a06774f490d9d410433d4243052cc8e37">More...</a><br /></td></tr>
<tr class="separator:a06774f490d9d410433d4243052cc8e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3b5601248b66f1eac1c2df1cf88ef0"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a0d3b5601248b66f1eac1c2df1cf88ef0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#a0d3b5601248b66f1eac1c2df1cf88ef0">contains</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a0d3b5601248b66f1eac1c2df1cf88ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the list contains <code>key</code>.  <a href="#a0d3b5601248b66f1eac1c2df1cf88ef0">More...</a><br /></td></tr>
<tr class="separator:a0d3b5601248b66f1eac1c2df1cf88ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae7acf3adbd0657ad3a0aab7f39abaf"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:aeae7acf3adbd0657ad3a0aab7f39abaf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#aeae7acf3adbd0657ad3a0aab7f39abaf">contains</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:aeae7acf3adbd0657ad3a0aab7f39abaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the list contains <code>key</code> using <code>pred</code> predicate for searching.  <a href="#aeae7acf3adbd0657ad3a0aab7f39abaf">More...</a><br /></td></tr>
<tr class="separator:aeae7acf3adbd0657ad3a0aab7f39abaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7b45c8c43229285fc2e112acb217c1"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a2d7b45c8c43229285fc2e112acb217c1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#a2d7b45c8c43229285fc2e112acb217c1">find</a> (Q &amp;key, Func f)</td></tr>
<tr class="memdesc:a2d7b45c8c43229285fc2e112acb217c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> and perform an action with it.  <a href="#a2d7b45c8c43229285fc2e112acb217c1">More...</a><br /></td></tr>
<tr class="separator:a2d7b45c8c43229285fc2e112acb217c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266a925919118ed4111afacc517a5fa5"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a266a925919118ed4111afacc517a5fa5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#a266a925919118ed4111afacc517a5fa5">find_with</a> (Q &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:a266a925919118ed4111afacc517a5fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> using <code>pred</code> predicate for searching.  <a href="#a266a925919118ed4111afacc517a5fa5">More...</a><br /></td></tr>
<tr class="separator:a266a925919118ed4111afacc517a5fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d9187204435cd200a127a4358f696c"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a10d9187204435cd200a127a4358f696c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_michael_list.html#aed12d6f534bb7a919201c9d6f4890ff3">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#a10d9187204435cd200a127a4358f696c">get</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a10d9187204435cd200a127a4358f696c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> and return the item found.  <a href="#a10d9187204435cd200a127a4358f696c">More...</a><br /></td></tr>
<tr class="separator:a10d9187204435cd200a127a4358f696c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781473491ffb18b08637c7d7a2172f4c"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a781473491ffb18b08637c7d7a2172f4c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_michael_list.html#aed12d6f534bb7a919201c9d6f4890ff3">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#a781473491ffb18b08637c7d7a2172f4c">get_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a781473491ffb18b08637c7d7a2172f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> and return the item found.  <a href="#a781473491ffb18b08637c7d7a2172f4c">More...</a><br /></td></tr>
<tr class="separator:a781473491ffb18b08637c7d7a2172f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76610c34928312059dd6dc6870e901e7"><td class="memItemLeft" align="right" valign="top"><a id="a76610c34928312059dd6dc6870e901e7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#a76610c34928312059dd6dc6870e901e7">empty</a> () const</td></tr>
<tr class="memdesc:a76610c34928312059dd6dc6870e901e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the list is empty. <br /></td></tr>
<tr class="separator:a76610c34928312059dd6dc6870e901e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db3b519185a393c30e34c8fec1e453c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#a8db3b519185a393c30e34c8fec1e453c">size</a> () const</td></tr>
<tr class="memdesc:a8db3b519185a393c30e34c8fec1e453c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns list's item count.  <a href="#a8db3b519185a393c30e34c8fec1e453c">More...</a><br /></td></tr>
<tr class="separator:a8db3b519185a393c30e34c8fec1e453c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9f7c17b8136925466e78644ea32e1c"><td class="memItemLeft" align="right" valign="top"><a id="a2e9f7c17b8136925466e78644ea32e1c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#a2e9f7c17b8136925466e78644ea32e1c">clear</a> ()</td></tr>
<tr class="memdesc:a2e9f7c17b8136925466e78644ea32e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the list. <br /></td></tr>
<tr class="separator:a2e9f7c17b8136925466e78644ea32e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19bcd485f92df789c312c4114487e6a7"><td class="memItemLeft" align="right" valign="top"><a id="a19bcd485f92df789c312c4114487e6a7"></a>
<a class="el" href="classcds_1_1container_1_1_michael_list.html#ae73c8ebe0317fe77c7726ee5bebe2cf7">stat</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#a19bcd485f92df789c312c4114487e6a7">statistics</a> () const</td></tr>
<tr class="memdesc:a19bcd485f92df789c312c4114487e6a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br /></td></tr>
<tr class="separator:a19bcd485f92df789c312c4114487e6a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a8619afa2c3563bad81c96af9c29ae0cf"><td class="memItemLeft" align="right" valign="top"><a id="a8619afa2c3563bad81c96af9c29ae0cf"></a>
static constexpr const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#a8619afa2c3563bad81c96af9c29ae0cf">c_nHazardPtrCount</a> = base_class::c_nHazardPtrCount</td></tr>
<tr class="memdesc:a8619afa2c3563bad81c96af9c29ae0cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of hazard pointer required for the algorithm. <br /></td></tr>
<tr class="separator:a8619afa2c3563bad81c96af9c29ae0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Forward iterators (only for debugging purpose)</h2></td></tr>
<tr class="memitem:aa63572607847e190c1d527197c22fefd"><td class="memItemLeft" align="right" valign="top">typedef iterator_type&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#aa63572607847e190c1d527197c22fefd">iterator</a></td></tr>
<tr class="memdesc:aa63572607847e190c1d527197c22fefd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward iterator.  <a href="#aa63572607847e190c1d527197c22fefd">More...</a><br /></td></tr>
<tr class="separator:aa63572607847e190c1d527197c22fefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43b0d77014fa5dc4c5acf3c104d66c0"><td class="memItemLeft" align="right" valign="top">typedef iterator_type&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#aa43b0d77014fa5dc4c5acf3c104d66c0">const_iterator</a></td></tr>
<tr class="memdesc:aa43b0d77014fa5dc4c5acf3c104d66c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const forward iterator.  <a href="#aa43b0d77014fa5dc4c5acf3c104d66c0">More...</a><br /></td></tr>
<tr class="separator:aa43b0d77014fa5dc4c5acf3c104d66c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65481a1e6c6e9130a4afee5d63941c81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_michael_list.html#aa63572607847e190c1d527197c22fefd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#a65481a1e6c6e9130a4afee5d63941c81">begin</a> ()</td></tr>
<tr class="memdesc:a65481a1e6c6e9130a4afee5d63941c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator addressing the first element in a list.  <a href="#a65481a1e6c6e9130a4afee5d63941c81">More...</a><br /></td></tr>
<tr class="separator:a65481a1e6c6e9130a4afee5d63941c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba494bca7c32a67f2e90993daf807f8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_michael_list.html#aa63572607847e190c1d527197c22fefd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#aba494bca7c32a67f2e90993daf807f8a">end</a> ()</td></tr>
<tr class="memdesc:aba494bca7c32a67f2e90993daf807f8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator that addresses the location succeeding the last element in a list.  <a href="#aba494bca7c32a67f2e90993daf807f8a">More...</a><br /></td></tr>
<tr class="separator:aba494bca7c32a67f2e90993daf807f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13095c80b006a7919e66554a01b5a895"><td class="memItemLeft" align="right" valign="top"><a id="a13095c80b006a7919e66554a01b5a895"></a>
<a class="el" href="classcds_1_1container_1_1_michael_list.html#aa43b0d77014fa5dc4c5acf3c104d66c0">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#a13095c80b006a7919e66554a01b5a895">begin</a> () const</td></tr>
<tr class="memdesc:a13095c80b006a7919e66554a01b5a895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a list. <br /></td></tr>
<tr class="separator:a13095c80b006a7919e66554a01b5a895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae039499a1af9448572421cd2b9fc8eb6"><td class="memItemLeft" align="right" valign="top"><a id="ae039499a1af9448572421cd2b9fc8eb6"></a>
<a class="el" href="classcds_1_1container_1_1_michael_list.html#aa43b0d77014fa5dc4c5acf3c104d66c0">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#ae039499a1af9448572421cd2b9fc8eb6">cbegin</a> () const</td></tr>
<tr class="memdesc:ae039499a1af9448572421cd2b9fc8eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a list. <br /></td></tr>
<tr class="separator:ae039499a1af9448572421cd2b9fc8eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31831ecf2f41f265d0262466a3d2cfb6"><td class="memItemLeft" align="right" valign="top"><a id="a31831ecf2f41f265d0262466a3d2cfb6"></a>
<a class="el" href="classcds_1_1container_1_1_michael_list.html#aa43b0d77014fa5dc4c5acf3c104d66c0">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#a31831ecf2f41f265d0262466a3d2cfb6">end</a> () const</td></tr>
<tr class="memdesc:a31831ecf2f41f265d0262466a3d2cfb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator that addresses the location succeeding the last element in a list. <br /></td></tr>
<tr class="separator:a31831ecf2f41f265d0262466a3d2cfb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b25f9ffdb81a8870746c5c9f95307eb"><td class="memItemLeft" align="right" valign="top"><a id="a6b25f9ffdb81a8870746c5c9f95307eb"></a>
<a class="el" href="classcds_1_1container_1_1_michael_list.html#aa43b0d77014fa5dc4c5acf3c104d66c0">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_list.html#a6b25f9ffdb81a8870746c5c9f95307eb">cend</a> () const</td></tr>
<tr class="memdesc:a6b25f9ffdb81a8870746c5c9f95307eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator that addresses the location succeeding the last element in a list. <br /></td></tr>
<tr class="separator:a6b25f9ffdb81a8870746c5c9f95307eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_types_classcds_1_1intrusive_1_1_michael_list"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classcds_1_1intrusive_1_1_michael_list')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classcds_1_1intrusive_1_1_michael_list.html">cds::intrusive::MichaelList&lt; GC, T, Traits &gt;</a></td></tr>
<tr class="memitem:abbd55320f1307ba51a8d39fcdf49ddca inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top"><a id="abbd55320f1307ba51a8d39fcdf49ddca"></a>
typedef node_type::atomic_marked_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#abbd55320f1307ba51a8d39fcdf49ddca">atomic_node_ptr</a></td></tr>
<tr class="memdesc:abbd55320f1307ba51a8d39fcdf49ddca inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic node pointer. <br /></td></tr>
<tr class="separator:abbd55320f1307ba51a8d39fcdf49ddca inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a928ecdc8eb5f4a40e56e36c37295f inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top"><a id="a25a928ecdc8eb5f4a40e56e36c37295f"></a>
typedef node_type::marked_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a25a928ecdc8eb5f4a40e56e36c37295f">marked_node_ptr</a></td></tr>
<tr class="memdesc:a25a928ecdc8eb5f4a40e56e36c37295f inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node marked pointer. <br /></td></tr>
<tr class="separator:a25a928ecdc8eb5f4a40e56e36c37295f inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6191f195334bb39867cbc0bbf1f5ad7 inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top"><a id="af6191f195334bb39867cbc0bbf1f5ad7"></a>
typedef <a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#abbd55320f1307ba51a8d39fcdf49ddca">atomic_node_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#af6191f195334bb39867cbc0bbf1f5ad7">auxiliary_head</a></td></tr>
<tr class="memdesc:af6191f195334bb39867cbc0bbf1f5ad7 inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary head type (for split-list support) <br /></td></tr>
<tr class="separator:af6191f195334bb39867cbc0bbf1f5ad7 inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92cd424c848b79df8ebd4aa1dc9a6a1 inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top"><a id="ac92cd424c848b79df8ebd4aa1dc9a6a1"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#ac92cd424c848b79df8ebd4aa1dc9a6a1">value_type</a></td></tr>
<tr class="memdesc:ac92cd424c848b79df8ebd4aa1dc9a6a1 inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the list <br /></td></tr>
<tr class="separator:ac92cd424c848b79df8ebd4aa1dc9a6a1 inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2658c603a1f758f556c4eeb7594f5dcd inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top"><a id="a2658c603a1f758f556c4eeb7594f5dcd"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a2658c603a1f758f556c4eeb7594f5dcd">traits</a></td></tr>
<tr class="memdesc:a2658c603a1f758f556c4eeb7594f5dcd inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits template parameter. <br /></td></tr>
<tr class="separator:a2658c603a1f758f556c4eeb7594f5dcd inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25d786e8c8f2c4d8b4162bd4617c51c inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top"><a id="ad25d786e8c8f2c4d8b4162bd4617c51c"></a>
typedef traits::hook&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#ad25d786e8c8f2c4d8b4162bd4617c51c">hook</a></td></tr>
<tr class="memdesc:ad25d786e8c8f2c4d8b4162bd4617c51c inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">hook type <br /></td></tr>
<tr class="separator:ad25d786e8c8f2c4d8b4162bd4617c51c inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92ea390b599d84e5142839aa4b50652 inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top"><a id="aa92ea390b599d84e5142839aa4b50652"></a>
typedef hook::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#aa92ea390b599d84e5142839aa4b50652">node_type</a></td></tr>
<tr class="memdesc:aa92ea390b599d84e5142839aa4b50652 inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">node type <br /></td></tr>
<tr class="separator:aa92ea390b599d84e5142839aa4b50652 inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6a25c5321e35d8c6235dd30a88b35b inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top"><a id="a9e6a25c5321e35d8c6235dd30a88b35b"></a>
typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a9e6a25c5321e35d8c6235dd30a88b35b">key_comparator</a></td></tr>
<tr class="memdesc:a9e6a25c5321e35d8c6235dd30a88b35b inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparison functor based on <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">opt::compare</a> and <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">opt::less</a> option setter. <br /></td></tr>
<tr class="separator:a9e6a25c5321e35d8c6235dd30a88b35b inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4e055f21648601a11d4ef49b7a6ae4 inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top"><a id="aaf4e055f21648601a11d4ef49b7a6ae4"></a>
typedef traits::disposer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#aaf4e055f21648601a11d4ef49b7a6ae4">disposer</a></td></tr>
<tr class="memdesc:aaf4e055f21648601a11d4ef49b7a6ae4 inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">disposer used <br /></td></tr>
<tr class="separator:aaf4e055f21648601a11d4ef49b7a6ae4 inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cda8107f72ce232114b4922f8d75e39 inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top"><a id="a1cda8107f72ce232114b4922f8d75e39"></a>
typedef traits::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a1cda8107f72ce232114b4922f8d75e39">stat</a></td></tr>
<tr class="memdesc:a1cda8107f72ce232114b4922f8d75e39 inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics. <br /></td></tr>
<tr class="separator:a1cda8107f72ce232114b4922f8d75e39 inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3539bdc625203d9f246abd2475d348 inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top"><a id="a7c3539bdc625203d9f246abd2475d348"></a>
typedef <a class="el" href="structcds_1_1intrusive_1_1get__node__traits.html">get_node_traits</a>&lt; <a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#ac92cd424c848b79df8ebd4aa1dc9a6a1">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#aa92ea390b599d84e5142839aa4b50652">node_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#ad25d786e8c8f2c4d8b4162bd4617c51c">hook</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a7c3539bdc625203d9f246abd2475d348">node_traits</a></td></tr>
<tr class="memdesc:a7c3539bdc625203d9f246abd2475d348 inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">node traits <br /></td></tr>
<tr class="separator:a7c3539bdc625203d9f246abd2475d348 inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d488ae8431a2a0bfcb8510748788220 inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top"><a id="a1d488ae8431a2a0bfcb8510748788220"></a>
typedef <a class="el" href="structcds_1_1intrusive_1_1michael__list_1_1get__link__checker.html">michael_list::get_link_checker</a>&lt; <a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#aa92ea390b599d84e5142839aa4b50652">node_type</a>, traits::link_checker &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a1d488ae8431a2a0bfcb8510748788220">link_checker</a></td></tr>
<tr class="memdesc:a1d488ae8431a2a0bfcb8510748788220 inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">link checker <br /></td></tr>
<tr class="separator:a1d488ae8431a2a0bfcb8510748788220 inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49f82e65f6254d01023bb1cb05fb80c inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top"><a id="ad49f82e65f6254d01023bb1cb05fb80c"></a>
typedef GC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#ad49f82e65f6254d01023bb1cb05fb80c">gc</a></td></tr>
<tr class="memdesc:ad49f82e65f6254d01023bb1cb05fb80c inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br /></td></tr>
<tr class="separator:ad49f82e65f6254d01023bb1cb05fb80c inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2347ecffe13e5ad754216a693811b7 inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top"><a id="aad2347ecffe13e5ad754216a693811b7"></a>
typedef traits::back_off&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#aad2347ecffe13e5ad754216a693811b7">back_off</a></td></tr>
<tr class="memdesc:aad2347ecffe13e5ad754216a693811b7 inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">back-off strategy <br /></td></tr>
<tr class="separator:aad2347ecffe13e5ad754216a693811b7 inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4810866f9924cdc718cc8e6c88c9443d inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top"><a id="a4810866f9924cdc718cc8e6c88c9443d"></a>
typedef traits::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a4810866f9924cdc718cc8e6c88c9443d">item_counter</a></td></tr>
<tr class="memdesc:a4810866f9924cdc718cc8e6c88c9443d inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy used. <br /></td></tr>
<tr class="separator:a4810866f9924cdc718cc8e6c88c9443d inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af487c986e5bb4850cdb4529692451134 inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top"><a id="af487c986e5bb4850cdb4529692451134"></a>
typedef traits::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#af487c986e5bb4850cdb4529692451134">memory_model</a></td></tr>
<tr class="memdesc:af487c986e5bb4850cdb4529692451134 inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering. See <a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">cds::opt::memory_model</a> option. <br /></td></tr>
<tr class="separator:af487c986e5bb4850cdb4529692451134 inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29215283ae0a9fdd0bd2e1dfb7a40def inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top"><a id="a29215283ae0a9fdd0bd2e1dfb7a40def"></a>
typedef gc::template <a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a29215283ae0a9fdd0bd2e1dfb7a40def">guarded_ptr</a>&lt; <a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#ac92cd424c848b79df8ebd4aa1dc9a6a1">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a29215283ae0a9fdd0bd2e1dfb7a40def">guarded_ptr</a></td></tr>
<tr class="memdesc:a29215283ae0a9fdd0bd2e1dfb7a40def inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded pointer. <br /></td></tr>
<tr class="separator:a29215283ae0a9fdd0bd2e1dfb7a40def inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438d709cb86f056de765cd20b6d16fb2 inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top">typedef iterator_type&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a438d709cb86f056de765cd20b6d16fb2">iterator</a></td></tr>
<tr class="memdesc:a438d709cb86f056de765cd20b6d16fb2 inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward iterator.  <a href="classcds_1_1intrusive_1_1_michael_list.html#a438d709cb86f056de765cd20b6d16fb2">More...</a><br /></td></tr>
<tr class="separator:a438d709cb86f056de765cd20b6d16fb2 inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d404b860f7cf0883013dc7b6de9732b inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top">typedef iterator_type&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a5d404b860f7cf0883013dc7b6de9732b">const_iterator</a></td></tr>
<tr class="memdesc:a5d404b860f7cf0883013dc7b6de9732b inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const forward iterator.  <a href="classcds_1_1intrusive_1_1_michael_list.html#a5d404b860f7cf0883013dc7b6de9732b">More...</a><br /></td></tr>
<tr class="separator:a5d404b860f7cf0883013dc7b6de9732b inherit pro_types_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classcds_1_1intrusive_1_1_michael_list"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classcds_1_1intrusive_1_1_michael_list')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcds_1_1intrusive_1_1_michael_list.html">cds::intrusive::MichaelList&lt; GC, T, Traits &gt;</a></td></tr>
<tr class="memitem:ae5e59b001dd4c75ee4b01bc8ef10eda7 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top"><a id="ae5e59b001dd4c75ee4b01bc8ef10eda7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#ae5e59b001dd4c75ee4b01bc8ef10eda7">MichaelList</a> ()</td></tr>
<tr class="memdesc:ae5e59b001dd4c75ee4b01bc8ef10eda7 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor initializes empty list. <br /></td></tr>
<tr class="separator:ae5e59b001dd4c75ee4b01bc8ef10eda7 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6111ce1da1481f6399a65139efc5d1 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top"><a id="a9c6111ce1da1481f6399a65139efc5d1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a9c6111ce1da1481f6399a65139efc5d1">~MichaelList</a> ()</td></tr>
<tr class="memdesc:a9c6111ce1da1481f6399a65139efc5d1 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the list object. <br /></td></tr>
<tr class="separator:a9c6111ce1da1481f6399a65139efc5d1 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272011bc98e96b3ea372c12e28147f26 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a272011bc98e96b3ea372c12e28147f26">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#ac92cd424c848b79df8ebd4aa1dc9a6a1">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a272011bc98e96b3ea372c12e28147f26 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="classcds_1_1intrusive_1_1_michael_list.html#a272011bc98e96b3ea372c12e28147f26">More...</a><br /></td></tr>
<tr class="separator:a272011bc98e96b3ea372c12e28147f26 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af607e26bd35e38999b66d7786e305e1c inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:af607e26bd35e38999b66d7786e305e1c inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#af607e26bd35e38999b66d7786e305e1c">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#ac92cd424c848b79df8ebd4aa1dc9a6a1">value_type</a> &amp;val, Func f)</td></tr>
<tr class="memdesc:af607e26bd35e38999b66d7786e305e1c inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="classcds_1_1intrusive_1_1_michael_list.html#af607e26bd35e38999b66d7786e305e1c">More...</a><br /></td></tr>
<tr class="separator:af607e26bd35e38999b66d7786e305e1c inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ba187cbe05ec91c955b91486ed83d3 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:ad4ba187cbe05ec91c955b91486ed83d3 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#ad4ba187cbe05ec91c955b91486ed83d3">update</a> (<a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#ac92cd424c848b79df8ebd4aa1dc9a6a1">value_type</a> &amp;val, Func func, bool bInsert=true)</td></tr>
<tr class="memdesc:ad4ba187cbe05ec91c955b91486ed83d3 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the node.  <a href="classcds_1_1intrusive_1_1_michael_list.html#ad4ba187cbe05ec91c955b91486ed83d3">More...</a><br /></td></tr>
<tr class="separator:ad4ba187cbe05ec91c955b91486ed83d3 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e33214594355484bb5a7b0051a7b1c inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#af9e33214594355484bb5a7b0051a7b1c">unlink</a> (<a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#ac92cd424c848b79df8ebd4aa1dc9a6a1">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:af9e33214594355484bb5a7b0051a7b1c inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlinks the item <code>val</code> from the list.  <a href="classcds_1_1intrusive_1_1_michael_list.html#af9e33214594355484bb5a7b0051a7b1c">More...</a><br /></td></tr>
<tr class="separator:af9e33214594355484bb5a7b0051a7b1c inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c403767f6f4c862724da2d7445cc517 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a5c403767f6f4c862724da2d7445cc517 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a5c403767f6f4c862724da2d7445cc517">erase</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a5c403767f6f4c862724da2d7445cc517 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the list.  <a href="classcds_1_1intrusive_1_1_michael_list.html#a5c403767f6f4c862724da2d7445cc517">More...</a><br /></td></tr>
<tr class="separator:a5c403767f6f4c862724da2d7445cc517 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0346b37037e540fd06803edc9137158d inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a0346b37037e540fd06803edc9137158d inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a0346b37037e540fd06803edc9137158d">erase_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a0346b37037e540fd06803edc9137158d inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the list using <code>pred</code> predicate for searching.  <a href="classcds_1_1intrusive_1_1_michael_list.html#a0346b37037e540fd06803edc9137158d">More...</a><br /></td></tr>
<tr class="separator:a0346b37037e540fd06803edc9137158d inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69068e4efbafb30996ed73330dc6ddcd inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a69068e4efbafb30996ed73330dc6ddcd inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a69068e4efbafb30996ed73330dc6ddcd">erase</a> (Q const &amp;key, Func func)</td></tr>
<tr class="memdesc:a69068e4efbafb30996ed73330dc6ddcd inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the list.  <a href="classcds_1_1intrusive_1_1_michael_list.html#a69068e4efbafb30996ed73330dc6ddcd">More...</a><br /></td></tr>
<tr class="separator:a69068e4efbafb30996ed73330dc6ddcd inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5cef5b6e2e85986281a728ec8381ddf inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:af5cef5b6e2e85986281a728ec8381ddf inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#af5cef5b6e2e85986281a728ec8381ddf">erase_with</a> (Q const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:af5cef5b6e2e85986281a728ec8381ddf inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the list using <code>pred</code> predicate for searching.  <a href="classcds_1_1intrusive_1_1_michael_list.html#af5cef5b6e2e85986281a728ec8381ddf">More...</a><br /></td></tr>
<tr class="separator:af5cef5b6e2e85986281a728ec8381ddf inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733aaf552ec7e0ea8312993ab5015100 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a733aaf552ec7e0ea8312993ab5015100 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a29215283ae0a9fdd0bd2e1dfb7a40def">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a733aaf552ec7e0ea8312993ab5015100">extract</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a733aaf552ec7e0ea8312993ab5015100 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item from the list with specified <code>key</code>.  <a href="classcds_1_1intrusive_1_1_michael_list.html#a733aaf552ec7e0ea8312993ab5015100">More...</a><br /></td></tr>
<tr class="separator:a733aaf552ec7e0ea8312993ab5015100 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f72d5d4912dcbbf47cc4d8a1b79be88 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a1f72d5d4912dcbbf47cc4d8a1b79be88 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a29215283ae0a9fdd0bd2e1dfb7a40def">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a1f72d5d4912dcbbf47cc4d8a1b79be88">extract_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a1f72d5d4912dcbbf47cc4d8a1b79be88 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item using compare functor <code>pred</code>.  <a href="classcds_1_1intrusive_1_1_michael_list.html#a1f72d5d4912dcbbf47cc4d8a1b79be88">More...</a><br /></td></tr>
<tr class="separator:a1f72d5d4912dcbbf47cc4d8a1b79be88 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a9121f2eb5e73ccd40a56a0ccfe17a inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:ac3a9121f2eb5e73ccd40a56a0ccfe17a inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#ac3a9121f2eb5e73ccd40a56a0ccfe17a">find</a> (Q &amp;key, Func f)</td></tr>
<tr class="memdesc:ac3a9121f2eb5e73ccd40a56a0ccfe17a inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> in the list.  <a href="classcds_1_1intrusive_1_1_michael_list.html#ac3a9121f2eb5e73ccd40a56a0ccfe17a">More...</a><br /></td></tr>
<tr class="separator:ac3a9121f2eb5e73ccd40a56a0ccfe17a inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bccb221a9f725aea597a381d7ba069f inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a8bccb221a9f725aea597a381d7ba069f inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a8bccb221a9f725aea597a381d7ba069f">find_with</a> (Q &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:a8bccb221a9f725aea597a381d7ba069f inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the <code>key</code> using <code>pred</code> predicate for searching.  <a href="classcds_1_1intrusive_1_1_michael_list.html#a8bccb221a9f725aea597a381d7ba069f">More...</a><br /></td></tr>
<tr class="separator:a8bccb221a9f725aea597a381d7ba069f inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a48e1d0babbe36193006363c0a1639 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:ae7a48e1d0babbe36193006363c0a1639 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#ae7a48e1d0babbe36193006363c0a1639">contains</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:ae7a48e1d0babbe36193006363c0a1639 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the list contains <code>key</code>.  <a href="classcds_1_1intrusive_1_1_michael_list.html#ae7a48e1d0babbe36193006363c0a1639">More...</a><br /></td></tr>
<tr class="separator:ae7a48e1d0babbe36193006363c0a1639 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d262501026dbdd5223bc4397060c46a inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a0d262501026dbdd5223bc4397060c46a inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a0d262501026dbdd5223bc4397060c46a">contains</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a0d262501026dbdd5223bc4397060c46a inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the list contains <code>key</code> using <code>pred</code> predicate for searching.  <a href="classcds_1_1intrusive_1_1_michael_list.html#a0d262501026dbdd5223bc4397060c46a">More...</a><br /></td></tr>
<tr class="separator:a0d262501026dbdd5223bc4397060c46a inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84a4c0a9d561fcea211833e9ca30794 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:ab84a4c0a9d561fcea211833e9ca30794 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a29215283ae0a9fdd0bd2e1dfb7a40def">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#ab84a4c0a9d561fcea211833e9ca30794">get</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:ab84a4c0a9d561fcea211833e9ca30794 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the <code>key</code> and return the item found.  <a href="classcds_1_1intrusive_1_1_michael_list.html#ab84a4c0a9d561fcea211833e9ca30794">More...</a><br /></td></tr>
<tr class="separator:ab84a4c0a9d561fcea211833e9ca30794 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3300d19ae0e5c427265da83658e2bcbf inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a3300d19ae0e5c427265da83658e2bcbf inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a29215283ae0a9fdd0bd2e1dfb7a40def">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a3300d19ae0e5c427265da83658e2bcbf">get_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a3300d19ae0e5c427265da83658e2bcbf inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the <code>key</code> and return the item found.  <a href="classcds_1_1intrusive_1_1_michael_list.html#a3300d19ae0e5c427265da83658e2bcbf">More...</a><br /></td></tr>
<tr class="separator:a3300d19ae0e5c427265da83658e2bcbf inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a576d78ab6506464c5ffba8a3a595b inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a82a576d78ab6506464c5ffba8a3a595b">clear</a> ()</td></tr>
<tr class="memdesc:a82a576d78ab6506464c5ffba8a3a595b inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the list.  <a href="classcds_1_1intrusive_1_1_michael_list.html#a82a576d78ab6506464c5ffba8a3a595b">More...</a><br /></td></tr>
<tr class="separator:a82a576d78ab6506464c5ffba8a3a595b inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc1b15b719f58caa9ad9a5ac5b7dab6 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top"><a id="a8bc1b15b719f58caa9ad9a5ac5b7dab6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a8bc1b15b719f58caa9ad9a5ac5b7dab6">empty</a> () const</td></tr>
<tr class="memdesc:a8bc1b15b719f58caa9ad9a5ac5b7dab6 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the list is empty. <br /></td></tr>
<tr class="separator:a8bc1b15b719f58caa9ad9a5ac5b7dab6 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39729fb78118fe742bd930bb37ae334 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#af39729fb78118fe742bd930bb37ae334">size</a> () const</td></tr>
<tr class="memdesc:af39729fb78118fe742bd930bb37ae334 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns list's item count.  <a href="classcds_1_1intrusive_1_1_michael_list.html#af39729fb78118fe742bd930bb37ae334">More...</a><br /></td></tr>
<tr class="separator:af39729fb78118fe742bd930bb37ae334 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377edfa9429b4d7efa73420a48739aa3 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top"><a id="a377edfa9429b4d7efa73420a48739aa3"></a>
<a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a1cda8107f72ce232114b4922f8d75e39">stat</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a377edfa9429b4d7efa73420a48739aa3">statistics</a> () const</td></tr>
<tr class="memdesc:a377edfa9429b4d7efa73420a48739aa3 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br /></td></tr>
<tr class="separator:a377edfa9429b4d7efa73420a48739aa3 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c8ebd6e398a5009ed82cb8d856e8ea inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a438d709cb86f056de765cd20b6d16fb2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#af3c8ebd6e398a5009ed82cb8d856e8ea">begin</a> ()</td></tr>
<tr class="memdesc:af3c8ebd6e398a5009ed82cb8d856e8ea inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator addressing the first element in a list.  <a href="classcds_1_1intrusive_1_1_michael_list.html#af3c8ebd6e398a5009ed82cb8d856e8ea">More...</a><br /></td></tr>
<tr class="separator:af3c8ebd6e398a5009ed82cb8d856e8ea inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4bffb0105b84ed924b25a0c91b82793 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a438d709cb86f056de765cd20b6d16fb2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#aa4bffb0105b84ed924b25a0c91b82793">end</a> ()</td></tr>
<tr class="memdesc:aa4bffb0105b84ed924b25a0c91b82793 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator that addresses the location succeeding the last element in a list.  <a href="classcds_1_1intrusive_1_1_michael_list.html#aa4bffb0105b84ed924b25a0c91b82793">More...</a><br /></td></tr>
<tr class="separator:aa4bffb0105b84ed924b25a0c91b82793 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b911ad65d18b83a71bd777cafc6dce6 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top"><a id="a4b911ad65d18b83a71bd777cafc6dce6"></a>
<a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a5d404b860f7cf0883013dc7b6de9732b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a4b911ad65d18b83a71bd777cafc6dce6">cbegin</a> () const</td></tr>
<tr class="memdesc:a4b911ad65d18b83a71bd777cafc6dce6 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a list. <br /></td></tr>
<tr class="separator:a4b911ad65d18b83a71bd777cafc6dce6 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b71c83a9a5c6f64d3f99fe569ebdac inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top"><a id="ad2b71c83a9a5c6f64d3f99fe569ebdac"></a>
<a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a5d404b860f7cf0883013dc7b6de9732b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#ad2b71c83a9a5c6f64d3f99fe569ebdac">begin</a> () const</td></tr>
<tr class="memdesc:ad2b71c83a9a5c6f64d3f99fe569ebdac inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a list. <br /></td></tr>
<tr class="separator:ad2b71c83a9a5c6f64d3f99fe569ebdac inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a362e428614bfab2bdc5aab0356101 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top"><a id="aa8a362e428614bfab2bdc5aab0356101"></a>
<a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a5d404b860f7cf0883013dc7b6de9732b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#aa8a362e428614bfab2bdc5aab0356101">end</a> () const</td></tr>
<tr class="memdesc:aa8a362e428614bfab2bdc5aab0356101 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator that addresses the location succeeding the last element in a list. <br /></td></tr>
<tr class="separator:aa8a362e428614bfab2bdc5aab0356101 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5148561e7d470fc00c972644886142 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top"><a id="acf5148561e7d470fc00c972644886142"></a>
<a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a5d404b860f7cf0883013dc7b6de9732b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#acf5148561e7d470fc00c972644886142">cend</a> () const</td></tr>
<tr class="memdesc:acf5148561e7d470fc00c972644886142 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator that addresses the location succeeding the last element in a list. <br /></td></tr>
<tr class="separator:acf5148561e7d470fc00c972644886142 inherit pro_methods_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classcds_1_1intrusive_1_1_michael_list"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classcds_1_1intrusive_1_1_michael_list')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classcds_1_1intrusive_1_1_michael_list.html">cds::intrusive::MichaelList&lt; GC, T, Traits &gt;</a></td></tr>
<tr class="memitem:a45e74af9ef77ec2ab155163c2d2c9b58 inherit pro_attribs_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top"><a id="a45e74af9ef77ec2ab155163c2d2c9b58"></a>
<a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#abbd55320f1307ba51a8d39fcdf49ddca">atomic_node_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a45e74af9ef77ec2ab155163c2d2c9b58">m_pHead</a></td></tr>
<tr class="memdesc:a45e74af9ef77ec2ab155163c2d2c9b58 inherit pro_attribs_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Head pointer. <br /></td></tr>
<tr class="separator:a45e74af9ef77ec2ab155163c2d2c9b58 inherit pro_attribs_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78cd5a7a16cbc344ff676274efd92b26 inherit pro_attribs_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top"><a id="a78cd5a7a16cbc344ff676274efd92b26"></a>
<a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a4810866f9924cdc718cc8e6c88c9443d">item_counter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a78cd5a7a16cbc344ff676274efd92b26">m_ItemCounter</a></td></tr>
<tr class="memdesc:a78cd5a7a16cbc344ff676274efd92b26 inherit pro_attribs_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter. <br /></td></tr>
<tr class="separator:a78cd5a7a16cbc344ff676274efd92b26 inherit pro_attribs_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11dff05876129a724704a67abba3fd43 inherit pro_attribs_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top"><a id="a11dff05876129a724704a67abba3fd43"></a>
<a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a1cda8107f72ce232114b4922f8d75e39">stat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a11dff05876129a724704a67abba3fd43">m_Stat</a></td></tr>
<tr class="memdesc:a11dff05876129a724704a67abba3fd43 inherit pro_attribs_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics. <br /></td></tr>
<tr class="separator:a11dff05876129a724704a67abba3fd43 inherit pro_attribs_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classcds_1_1intrusive_1_1_michael_list"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classcds_1_1intrusive_1_1_michael_list')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classcds_1_1intrusive_1_1_michael_list.html">cds::intrusive::MichaelList&lt; GC, T, Traits &gt;</a></td></tr>
<tr class="memitem:a6970ae0e95902e341f8ebdf7643cdbcb inherit pro_static_attribs_classcds_1_1intrusive_1_1_michael_list"><td class="memItemLeft" align="right" valign="top"><a id="a6970ae0e95902e341f8ebdf7643cdbcb"></a>
static constexpr const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html#a6970ae0e95902e341f8ebdf7643cdbcb">c_nHazardPtrCount</a> = 4</td></tr>
<tr class="memdesc:a6970ae0e95902e341f8ebdf7643cdbcb inherit pro_static_attribs_classcds_1_1intrusive_1_1_michael_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of hazard pointer required for the algorithm. <br /></td></tr>
<tr class="separator:a6970ae0e95902e341f8ebdf7643cdbcb inherit pro_static_attribs_classcds_1_1intrusive_1_1_michael_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename GC, typename T, typename Traits = michael_list::traits&gt;<br />
class cds::container::MichaelList&lt; GC, T, Traits &gt;</h3>

<p>Michael's ordered list. </p>
<p><a class="anchor" id="cds_nonintrusive_MichaelList_gc"></a> Usually, ordered single-linked list is used as a building block for the hash table implementation. The complexity of searching is <code>O(N)</code>, where <code>N</code> is the item count in the list, not in the hash table.</p>
<p>Source:</p><ul>
<li>[2002] Maged Michael "High performance dynamic lock-free hash tables and list-based sets"</li>
</ul>
<p>This class is non-intrusive version of <a class="el" href="classcds_1_1intrusive_1_1_michael_list.html" title="Michael&#39;s lock-free ordered single-linked list. ">cds::intrusive::MichaelList</a> class</p>
<p>Template arguments:</p><ul>
<li><code>GC</code> - garbage collector used</li>
<li><code>T</code> - type stored in the list. The type must be default- and copy-constructible.</li>
<li><code>Traits</code> - type traits, default is <code>michael_list::traits</code> </li>
</ul>
<p>Unlike standard container, this implementation does not divide type <code>T</code> into key and value part and may be used as a main building block for hash set algorithms. The key is a function (or a part) of type <code>T</code>, and this function is specified by <code>Traits::compare</code> functor or <code>Traits::less</code> predicate</p>
<p><a class="el" href="classcds_1_1container_1_1_michael_k_v_list.html" title="Michael&#39;s ordered list for key-value pair. ">MichaelKVList</a> is a key-value version of Michael's non-intrusive list that is closer to the C++ std library approach.</p>
<p>It is possible to declare option-based list with <a class="el" href="structcds_1_1container_1_1michael__list_1_1make__traits.html">cds::container::michael_list::make_traits</a> metafunction istead of <code>Traits</code> template argument. For example, the following traits-based declaration of <a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector. ">gc::HP</a> Michael's list </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/michael_list_hp.h&gt;</span></div><div class="line"><span class="comment">// Declare comparator for the item</span></div><div class="line"><span class="keyword">struct </span>my_compare {</div><div class="line">    <span class="keywordtype">int</span> operator ()( <span class="keywordtype">int</span> i1, <span class="keywordtype">int</span> i2 )</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> i1 - i2;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Declare traits</span></div><div class="line"><span class="keyword">struct </span>my_traits: <span class="keyword">public</span> cds::container::michael_list::traits</div><div class="line">{</div><div class="line">    <span class="keyword">typedef</span> my_compare compare;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Declare traits-based list</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_michael_list.html">cds::container::MichaelList&lt; cds::gc::HP, int, my_traits &gt;</a>     traits_based_list;</div></div><!-- fragment --><p>is equivalent for the following option-based list </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/michael_list_hp.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// my_compare is the same</span></div><div class="line"></div><div class="line"><span class="comment">// Declare option-based list</span></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_michael_list.html">cds::container::MichaelList</a>&lt; cds::gc::HP, int,</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="structcds_1_1container_1_1michael__list_1_1make__traits.html">cds::container::michael_list::make_traits</a>&lt;</div><div class="line">        <a class="code" href="structcds_1_1opt_1_1compare.html">cds::container::opt::compare&lt; my_compare &gt;</a>     <span class="comment">// item comparator option</span></div><div class="line">    &gt;::type</div><div class="line">&gt;     option_based_list;</div></div><!-- fragment --><dl class="section user"><dt>Usage</dt><dd>There are different specializations of this template for each garbage collecting schema used. You should include appropriate .h-file depending on GC you are using:<ul>
<li>for <a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector. ">gc::HP</a>:<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/michael_list_hp.h&gt;</span> </div></div><!-- fragment --></li>
<li>for <a class="el" href="classcds_1_1gc_1_1_d_h_p.html" title="Dynamic Hazard Pointer garbage collector. ">gc::DHP</a>:<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/michael_list_dhp.h&gt;</span> </div></div><!-- fragment --></li>
<li>for <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_desc">RCU</a>:<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/michael_list_rcu.h&gt;</span> </div></div><!-- fragment --></li>
<li>for <a class="el" href="classcds_1_1gc_1_1nogc.html" title="No garbage collecting. ">gc::nogc</a>:<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/michael_list_nogc.h&gt;</span> </div></div><!-- fragment --> </li>
</ul>
</dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aa43b0d77014fa5dc4c5acf3c104d66c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43b0d77014fa5dc4c5acf3c104d66c0">&sect;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename T , typename Traits  = michael_list::traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef iterator_type&lt;true&gt; <a class="el" href="classcds_1_1container_1_1_michael_list.html">cds::container::MichaelList</a>&lt; GC, T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_michael_list.html#aa43b0d77014fa5dc4c5acf3c104d66c0">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const forward iterator. </p>
<p>For iterator's features and requirements see <a class="el" href="classcds_1_1container_1_1_michael_list.html#aa63572607847e190c1d527197c22fefd">iterator</a> </p>

</div>
</div>
<a id="aa63572607847e190c1d527197c22fefd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa63572607847e190c1d527197c22fefd">&sect;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename T , typename Traits  = michael_list::traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef iterator_type&lt;false&gt; <a class="el" href="classcds_1_1container_1_1_michael_list.html">cds::container::MichaelList</a>&lt; GC, T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_michael_list.html#aa63572607847e190c1d527197c22fefd">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forward iterator. </p>
<p>The forward iterator for Michael's list has some features:</p><ul>
<li>it has no post-increment operator</li>
<li>to protect the value, the iterator contains a GC-specific guard + another guard is required locally for increment operator. For some GC (<code><a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector. ">gc::HP</a></code>), a guard is limited resource per thread, so an exception (or assertion) "no free guard" may be thrown if a limit of guard count per thread is exceeded.</li>
<li>The iterator cannot be moved across thread boundary since it contains GC's guard that is thread-private GC data.</li>
<li>Iterator ensures thread-safety even if you delete the item that iterator points to. However, in case of concurrent deleting operations it is no guarantee that you iterate all item in the list. Moreover, a crash is possible when you try to iterate the next element that has been deleted by concurrent thread.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>Use this iterator on the concurrent container for debugging purpose only. </dd></dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a676f5c9655fa8a7c8b3c2abaac723bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676f5c9655fa8a7c8b3c2abaac723bd7">&sect;&nbsp;</a></span>MichaelList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename T , typename Traits  = michael_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_michael_list.html">cds::container::MichaelList</a>&lt; GC, T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_michael_list.html">MichaelList</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Initialize empty list </p>

</div>
</div>
<a id="a95c61670fe6e25a02be68ec0de6f4ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95c61670fe6e25a02be68ec0de6f4ef7">&sect;&nbsp;</a></span>~MichaelList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename T , typename Traits  = michael_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_michael_list.html">cds::container::MichaelList</a>&lt; GC, T, Traits &gt;::~<a class="el" href="classcds_1_1container_1_1_michael_list.html">MichaelList</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List destructor. </p>
<p>Clears the list </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a65481a1e6c6e9130a4afee5d63941c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65481a1e6c6e9130a4afee5d63941c81">&sect;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename T , typename Traits  = michael_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_michael_list.html#aa63572607847e190c1d527197c22fefd">iterator</a> <a class="el" href="classcds_1_1container_1_1_michael_list.html">cds::container::MichaelList</a>&lt; GC, T, Traits &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a forward iterator addressing the first element in a list. </p>
<p>For empty list</p><div class="fragment"><div class="line"><a class="code" href="classcds_1_1container_1_1_michael_list.html#a65481a1e6c6e9130a4afee5d63941c81">begin</a>() == <a class="code" href="classcds_1_1container_1_1_michael_list.html#aba494bca7c32a67f2e90993daf807f8a">end</a>() </div></div><!-- fragment --> 
</div>
</div>
<a id="a0d3b5601248b66f1eac1c2df1cf88ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d3b5601248b66f1eac1c2df1cf88ef0">&sect;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename T , typename Traits  = michael_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_list.html">cds::container::MichaelList</a>&lt; GC, T, Traits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the list contains <code>key</code>. </p>
<p>The function searches the item with key equal to <code>key</code> and returns <code>true</code> if it is found, and <code>false</code> otherwise. </p>

</div>
</div>
<a id="aeae7acf3adbd0657ad3a0aab7f39abaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae7acf3adbd0657ad3a0aab7f39abaf">&sect;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename T , typename Traits  = michael_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_list.html">cds::container::MichaelList</a>&lt; GC, T, Traits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the list contains <code>key</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <code>contains( key )</code> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the list. </p>

</div>
</div>
<a id="a877c6f957db11c64d373a5823e27e9b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877c6f957db11c64d373a5823e27e9b4">&sect;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename T , typename Traits  = michael_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_list.html">cds::container::MichaelList</a>&lt; GC, T, Traits &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts data of type <code>value_type</code> constructed with <code>std::forward&lt;Args&gt;(args)...</code> </p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise. </p>

</div>
</div>
<a id="aba494bca7c32a67f2e90993daf807f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba494bca7c32a67f2e90993daf807f8a">&sect;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename T , typename Traits  = michael_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_michael_list.html#aa63572607847e190c1d527197c22fefd">iterator</a> <a class="el" href="classcds_1_1container_1_1_michael_list.html">cds::container::MichaelList</a>&lt; GC, T, Traits &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator that addresses the location succeeding the last element in a list. </p>
<p>Do not use the value returned by <code>end</code> function to access any item. Internally, <code>end</code> returning value equals to <code>nullptr</code>.</p>
<p>The returned value can be used only to control reaching the end of the list. For empty list</p><div class="fragment"><div class="line"><a class="code" href="classcds_1_1container_1_1_michael_list.html#a65481a1e6c6e9130a4afee5d63941c81">begin</a>() == <a class="code" href="classcds_1_1container_1_1_michael_list.html#aba494bca7c32a67f2e90993daf807f8a">end</a>() </div></div><!-- fragment --> 
</div>
</div>
<a id="a7d09caf072bbe7fbfb73e96e193153c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d09caf072bbe7fbfb73e96e193153c2">&sect;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename T , typename Traits  = michael_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_list.html">cds::container::MichaelList</a>&lt; GC, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the list. </p>
<p><a class="anchor" id="cds_nonintrusive_MichealList_hp_erase_val"></a>Since the key of <a class="el" href="classcds_1_1container_1_1_michael_list.html" title="Michael&#39;s ordered list. ">MichaelList</a>'s item type <code>value_type</code> is not explicitly specified, template parameter <code>Q</code> sould contain the complete key to search in the list. The list item comparator should be able to compare the type <code>value_type</code> and the type <code>Q</code>.</p>
<p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a id="a2b5db2856cd2f52ea1db33f247dc3bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b5db2856cd2f52ea1db33f247dc3bf7">&sect;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename T , typename Traits  = michael_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_list.html">cds::container::MichaelList</a>&lt; GC, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes <code>key</code> from the list. </p>
<p><a class="anchor" id="cds_nonintrusive_MichaelList_hp_erase_func"></a>The function searches an item with key <code>key</code>, calls <code>f</code> functor with item found and deletes it. If <code>key</code> is not found, the functor is not called.</p>
<p>The functor <code>Func</code> interface: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>extractor {</div><div class="line">    <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classcds_1_1container_1_1_michael_list.html#a90906981ca9a1cbcb3240d2018816672">value_type</a>&amp; val) { ... }</div><div class="line">};</div></div><!-- fragment --><p>Since the key of <a class="el" href="classcds_1_1container_1_1_michael_list.html" title="Michael&#39;s ordered list. ">MichaelList</a>'s item type <code>value_type</code> is not explicitly specified, template parameter <code>Q</code> should contain the complete key to search in the list. The list item comparator should be able to compare the type <code>value_type</code> of list item and the type <code>Q</code>.</p>
<p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a id="afff3bedb4c832bbaab88e6cc5a501124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff3bedb4c832bbaab88e6cc5a501124">&sect;&nbsp;</a></span>erase_with() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename T , typename Traits  = michael_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_list.html">cds::container::MichaelList</a>&lt; GC, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the list using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_michael_list.html#cds_nonintrusive_MichealList_hp_erase_val">erase(Q const&amp;)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the list. </p>

</div>
</div>
<a id="a05de5b48fba190c5732fc6a49328eeb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05de5b48fba190c5732fc6a49328eeb5">&sect;&nbsp;</a></span>erase_with() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename T , typename Traits  = michael_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_list.html">cds::container::MichaelList</a>&lt; GC, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the list using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_michael_list.html#cds_nonintrusive_MichaelList_hp_erase_func">erase(Q const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the list. </p>

</div>
</div>
<a id="a4f881391b70725d2f3a40e16c7e7489b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f881391b70725d2f3a40e16c7e7489b">&sect;&nbsp;</a></span>extract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename T , typename Traits  = michael_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_michael_list.html#aed12d6f534bb7a919201c9d6f4890ff3">guarded_ptr</a> <a class="el" href="classcds_1_1container_1_1_michael_list.html">cds::container::MichaelList</a>&lt; GC, T, Traits &gt;::extract </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the item from the list with specified <code>key</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_MichaelList_hp_extract"></a>The function searches an item with key equal to <code>key</code>, unlinks it from the list, and returns it as <code>guarded_ptr</code>. If <code>key</code> is not found the function returns an empty guarded pointer.</p>
<p>Note the compare functor should accept a parameter of type <code>Q</code> that can be not the same as <code>value_type</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Each <code>guarded_ptr</code> object uses the GC's guard that can be limited resource.</dd></dl>
<p>Usage: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_michael_list.html">cds::container::MichaelList&lt; cds::gc::HP, foo, my_traits &gt;</a>  ord_list;</div><div class="line">ord_list theList;</div><div class="line"><span class="comment">// ...</span></div><div class="line">{</div><div class="line">    ord_list::guarded_ptr gp(theList.extract( 5 ));</div><div class="line">    <span class="keywordflow">if</span> ( gp ) {</div><div class="line">        <span class="comment">// Deal with gp</span></div><div class="line">        <span class="comment">// ...</span></div><div class="line">    }</div><div class="line">    <span class="comment">// Destructor of gp releases internal HP guard and frees the item</span></div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="a06774f490d9d410433d4243052cc8e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06774f490d9d410433d4243052cc8e37">&sect;&nbsp;</a></span>extract_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename T , typename Traits  = michael_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_michael_list.html#aed12d6f534bb7a919201c9d6f4890ff3">guarded_ptr</a> <a class="el" href="classcds_1_1container_1_1_michael_list.html">cds::container::MichaelList</a>&lt; GC, T, Traits &gt;::extract_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the item from the list with comparing functor <code>pred</code>. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_michael_list.html#cds_nonintrusive_MichaelList_hp_extract">extract(Q const&amp;)</a> but <code>pred</code> predicate is used for key comparing.</p>
<p><code>Less</code> functor has the semantics like <code>std::less</code> but it should accept arguments of type <code>value_type</code> and <code>Q</code> in any order. <code>pred</code> must imply the same element order as the comparator used for building the list. </p>

</div>
</div>
<a id="a2d7b45c8c43229285fc2e112acb217c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7b45c8c43229285fc2e112acb217c1">&sect;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename T , typename Traits  = michael_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_list.html">cds::container::MichaelList</a>&lt; GC, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds <code>key</code> and perform an action with it. </p>
<p><a class="anchor" id="cds_nonintrusive_MichaelList_hp_find_func"></a>The function searches an item with key equal to <code>key</code> and calls the functor <code>f</code> for the item found. The interface of <code>Func</code> functor is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div><div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_michael_list.html#a90906981ca9a1cbcb3240d2018816672">value_type</a>&amp; item, Q&amp; key );</div><div class="line">};</div></div><!-- fragment --><p> where <code>item</code> is the item found, <code>key</code> is the <code>find</code> function argument.</p>
<p>The functor may change non-key fields of <code>item</code>. Note that the function is only guarantee that <code>item</code> cannot be deleted during functor is executing. The function does not serialize simultaneous access to the list <code>item</code>. If such access is possible you must provide your own synchronization schema to exclude unsafe item modifications.</p>
<p>The function returns <code>true</code> if <code>key</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a id="a266a925919118ed4111afacc517a5fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266a925919118ed4111afacc517a5fa5">&sect;&nbsp;</a></span>find_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename T , typename Traits  = michael_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_list.html">cds::container::MichaelList</a>&lt; GC, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds <code>key</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_michael_list.html#cds_nonintrusive_MichaelList_hp_find_func">find(Q&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the list. </p>

</div>
</div>
<a id="a10d9187204435cd200a127a4358f696c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d9187204435cd200a127a4358f696c">&sect;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename T , typename Traits  = michael_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_michael_list.html#aed12d6f534bb7a919201c9d6f4890ff3">guarded_ptr</a> <a class="el" href="classcds_1_1container_1_1_michael_list.html">cds::container::MichaelList</a>&lt; GC, T, Traits &gt;::get </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds <code>key</code> and return the item found. </p>
<p>The function searches the item with key equal to <code>key</code> and returns it as <code>guarded_ptr</code>. If <code>key</code> is not found the function returns an empty guarded pointer.</p>
<dl class="section note"><dt>Note</dt><dd>Each <code>guarded_ptr</code> object uses one GC's guard which can be limited resource.</dd></dl>
<p>Usage: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_michael_list.html">cds::container::MichaelList&lt; cds::gc::HP, foo, my_traits &gt;</a>  ord_list;</div><div class="line">ord_list theList;</div><div class="line"><span class="comment">// ...</span></div><div class="line">{</div><div class="line">    ord_list::guarded_ptr gp(theList.get( 5 ));</div><div class="line">    <span class="keywordflow">if</span> ( gp ) {</div><div class="line">        <span class="comment">// Deal with gp</span></div><div class="line">        <span class="comment">//...</span></div><div class="line">    }</div><div class="line">    <span class="comment">// Destructor of guarded_ptr releases internal HP guard and frees the item</span></div><div class="line">}</div></div><!-- fragment --><p>Note the compare functor specified for class <code>Traits</code> template parameter should accept a parameter of type <code>Q</code> that can be not the same as <code>value_type</code>. </p>

</div>
</div>
<a id="a781473491ffb18b08637c7d7a2172f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781473491ffb18b08637c7d7a2172f4c">&sect;&nbsp;</a></span>get_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename T , typename Traits  = michael_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_michael_list.html#aed12d6f534bb7a919201c9d6f4890ff3">guarded_ptr</a> <a class="el" href="classcds_1_1container_1_1_michael_list.html">cds::container::MichaelList</a>&lt; GC, T, Traits &gt;::get_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds <code>key</code> and return the item found. </p>
<p>The function is an analog of <code><a class="el" href="classcds_1_1container_1_1_michael_list.html#a10d9187204435cd200a127a4358f696c" title="Finds key and return the item found. ">get( Q const&amp;)</a></code> but <code>pred</code> is used for comparing the keys.</p>
<p><code>Less</code> functor has the semantics like <code>std::less</code> but should accept arguments of type <code>value_type</code> and <code>Q</code> in any order. <code>pred</code> must imply the same element order as the comparator used for building the list. </p>

</div>
</div>
<a id="a5d5c9ee1e8160f907c8ca81cb6543566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d5c9ee1e8160f907c8ca81cb6543566">&sect;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename T , typename Traits  = michael_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_list.html">cds::container::MichaelList</a>&lt; GC, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function creates a node with copy of <code>val</code> value and then inserts the node created into the list.</p>
<p>The type <code>Q</code> should contain least the complete key of the node. The object of <a class="el" href="classcds_1_1container_1_1_michael_list.html#a90906981ca9a1cbcb3240d2018816672">value_type</a> should be constructible from <code>val</code> of type <code>Q</code>. In trivial case, <code>Q</code> is equal to <a class="el" href="classcds_1_1container_1_1_michael_list.html#a90906981ca9a1cbcb3240d2018816672">value_type</a>.</p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise. </p>

</div>
</div>
<a id="a890764c4e82bc23e350da0ddc50436ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a890764c4e82bc23e350da0ddc50436ca">&sect;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename T , typename Traits  = michael_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_list.html">cds::container::MichaelList</a>&lt; GC, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>This function inserts new node with default-constructed value and then it calls <code>func</code> functor with signature </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <a class="code" href="classcds_1_1container_1_1_michael_list.html#a90906981ca9a1cbcb3240d2018816672">value_type</a>&amp; itemValue ) ;</div></div><!-- fragment --><p>The argument <code>itemValue</code> of user-defined functor <code>func</code> is the reference to the list's item inserted. User-defined functor <code>func</code> should guarantee that during changing item's value no any other changes could be made on this list's item by concurrent threads. The user-defined functor is called only if inserting is success.</p>
<p>The type <code>Q</code> should contain the complete key of the node. The object of <code>value_type</code> should be constructible from <code>key</code> of type <code>Q</code>.</p>
<p>The function allows to split creating of new item into two part:</p><ul>
<li>create item from <code>key</code> with initializing key-fields only;</li>
<li>insert new item into the list;</li>
<li>if inserting is successful, initialize non-key fields of item by calling <code>func</code> functor</li>
</ul>
<p>The method can be useful if complete initialization of object of <code>value_type</code> is heavyweight and it is preferable that the initialization should be completed only if inserting is successful.</p>
<dl class="section warning"><dt>Warning</dt><dd>See <a class="el" href="namespacecds_1_1intrusive.html#cds_intrusive_item_creating">insert item troubleshooting</a> </dd></dl>

</div>
</div>
<a id="a8db3b519185a393c30e34c8fec1e453c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db3b519185a393c30e34c8fec1e453c">&sect;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename T , typename Traits  = michael_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1container_1_1_michael_list.html">cds::container::MichaelList</a>&lt; GC, T, Traits &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns list's item count. </p>
<p>The value returned depends on item counter provided by <code>Traits</code>. For <code><a class="el" href="classcds_1_1atomicity_1_1empty__item__counter.html" title="Empty item counter. ">atomicity::empty_item_counter</a></code>, this function always returns 0.</p>
<dl class="section note"><dt>Note</dt><dd>Even if you use real item counter and it returns 0, this fact is not mean that the list is empty. To check list emptyness use <code><a class="el" href="classcds_1_1container_1_1_michael_list.html#a76610c34928312059dd6dc6870e901e7" title="Check if the list is empty. ">empty()</a></code> method. </dd></dl>

</div>
</div>
<a id="a7a043623ccf8aef7fe0008d8da56752d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a043623ccf8aef7fe0008d8da56752d">&sect;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename T , typename Traits  = michael_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1container_1_1_michael_list.html">cds::container::MichaelList</a>&lt; GC, T, Traits &gt;::update </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowInsert</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates data by <code>key</code>. </p>
<p>The operation performs inserting or replacing the element with lock-free manner.</p>
<p>If the <code>key</code> not found in the list, then the new item created from <code>key</code> will be inserted iff <code>bAllowInsert</code> is <code>true</code>. Otherwise, if <code>key</code> is found, the functor <code>func</code> is called with item found.</p>
<p>The functor <code>Func</code> signature is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>my_functor {</div><div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_michael_list.html#a90906981ca9a1cbcb3240d2018816672">value_type</a>&amp; item, Q <span class="keyword">const</span>&amp; key );</div><div class="line">};</div></div><!-- fragment --><p>with arguments:</p><ul>
<li><code>bNew</code> - <code>true</code> if the item has been inserted, <code>false</code> otherwise</li>
<li><code>item</code> - item of the list</li>
<li><code>key</code> - argument <code>key</code> passed into the <code>update</code>() function</li>
</ul>
<p>The functor may change non-key fields of the <code>item</code>; however, <code>func</code> must guarantee that during changing no any other modifications could be made on this item by concurrent threads.</p>
<p>Returns <code> std::pair&lt;bool, bool&gt; </code> where <code>first</code> is true if operation is successful, <code>second</code> is true if new item has been added or <code>false</code> if the item with <code>key</code> already exists.</p>
<dl class="section warning"><dt>Warning</dt><dd>See <a class="el" href="namespacecds_1_1intrusive.html#cds_intrusive_item_creating">insert item troubleshooting</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>cds/container/details/michael_list_base.h</li>
<li>cds/container/impl/michael_list.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.2.0</b> 
  Developed by <i>Maxim Khizhinsky aka khizmax</i> 2007 - 2017
  <br/>
  <i>Autogenerated Wed Jan 4 2017 08:49:39 by Doxygen 1.8.12</i>
</div>
</body>
</html>
