<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cds: cds::container::SkipListMap&lt; GC, Key, T, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcds_1_1container_1_1_skip_list_map.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::SkipListMap&lt; GC, Key, T, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__nonintrusive__containers.html">Non-intrusive containers</a> &raquo; <a class="el" href="group__cds__nonintrusive__map.html">Map</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Lock-free skip-list map.  
 <a href="classcds_1_1container_1_1_skip_list_map.html#details">More...</a></p>

<p><code>#include &lt;cds/container/impl/skip_list_map.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::container::SkipListMap&lt; GC, Key, T, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1container_1_1_skip_list_map.png" usemap="#cds::container::SkipListMap_3C_20GC_2C_20Key_2C_20T_2C_20Traits_20_3E_map" alt=""/>
  <map id="cds::container::SkipListMap_3C_20GC_2C_20Key_2C_20T_2C_20Traits_20_3E_map" name="cds::container::SkipListMap&lt; GC, Key, T, Traits &gt;_map">
<area href="classcds_1_1intrusive_1_1_skip_list_set.html" alt="cds::intrusive::SkipListSet&lt; GC, std::pair&lt; Key const, T &gt;, Traits &gt;" shape="rect" coords="0,0,385,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a607e6f9399217c2abb1e7d172b756b1e"><td class="memItemLeft" align="right" valign="top"><a id="a607e6f9399217c2abb1e7d172b756b1e"></a>
typedef GC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a607e6f9399217c2abb1e7d172b756b1e">gc</a></td></tr>
<tr class="memdesc:a607e6f9399217c2abb1e7d172b756b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br /></td></tr>
<tr class="separator:a607e6f9399217c2abb1e7d172b756b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcff161d75ab8f150a8973c098d5bf3b"><td class="memItemLeft" align="right" valign="top"><a id="adcff161d75ab8f150a8973c098d5bf3b"></a>
typedef Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#adcff161d75ab8f150a8973c098d5bf3b">key_type</a></td></tr>
<tr class="memdesc:adcff161d75ab8f150a8973c098d5bf3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key type. <br /></td></tr>
<tr class="separator:adcff161d75ab8f150a8973c098d5bf3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd7823b0b38e7cb88809a59e20ae0e7"><td class="memItemLeft" align="right" valign="top"><a id="a4cd7823b0b38e7cb88809a59e20ae0e7"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a4cd7823b0b38e7cb88809a59e20ae0e7">mapped_type</a></td></tr>
<tr class="memdesc:a4cd7823b0b38e7cb88809a59e20ae0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapped type. <br /></td></tr>
<tr class="separator:a4cd7823b0b38e7cb88809a59e20ae0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaad915000783c7f66585af6888d4b38"><td class="memItemLeft" align="right" valign="top"><a id="aaaad915000783c7f66585af6888d4b38"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#aaaad915000783c7f66585af6888d4b38">traits</a></td></tr>
<tr class="memdesc:aaaad915000783c7f66585af6888d4b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map traits. <br /></td></tr>
<tr class="separator:aaaad915000783c7f66585af6888d4b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71e523091dcd181e35c363f862be3df"><td class="memItemLeft" align="right" valign="top"><a id="af71e523091dcd181e35c363f862be3df"></a>
typedef std::pair&lt; Key const, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#af71e523091dcd181e35c363f862be3df">value_type</a></td></tr>
<tr class="memdesc:af71e523091dcd181e35c363f862be3df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key-value pair to be stored in the map. <br /></td></tr>
<tr class="separator:af71e523091dcd181e35c363f862be3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab927aca6d5661b623adc37f0b7913c0f"><td class="memItemLeft" align="right" valign="top"><a id="ab927aca6d5661b623adc37f0b7913c0f"></a>
typedef base_class::back_off&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#ab927aca6d5661b623adc37f0b7913c0f">back_off</a></td></tr>
<tr class="memdesc:ab927aca6d5661b623adc37f0b7913c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Back-off strategy. <br /></td></tr>
<tr class="separator:ab927aca6d5661b623adc37f0b7913c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123bffa0084432caf56e298008977296"><td class="memItemLeft" align="right" valign="top"><a id="a123bffa0084432caf56e298008977296"></a>
typedef traits::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a123bffa0084432caf56e298008977296">allocator_type</a></td></tr>
<tr class="memdesc:a123bffa0084432caf56e298008977296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator type used for allocate/deallocate the skip-list nodes. <br /></td></tr>
<tr class="separator:a123bffa0084432caf56e298008977296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46c8ab210ed6697ff4d424d01b18c14"><td class="memItemLeft" align="right" valign="top"><a id="aa46c8ab210ed6697ff4d424d01b18c14"></a>
typedef base_class::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#aa46c8ab210ed6697ff4d424d01b18c14">item_counter</a></td></tr>
<tr class="memdesc:aa46c8ab210ed6697ff4d424d01b18c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy used. <br /></td></tr>
<tr class="separator:aa46c8ab210ed6697ff4d424d01b18c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dbded437267b9bcf6d49660d240a956"><td class="memItemLeft" align="right" valign="top"><a id="a8dbded437267b9bcf6d49660d240a956"></a>
typedef maker::key_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a8dbded437267b9bcf6d49660d240a956">key_comparator</a></td></tr>
<tr class="memdesc:a8dbded437267b9bcf6d49660d240a956"><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparison functor <br /></td></tr>
<tr class="separator:a8dbded437267b9bcf6d49660d240a956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dadda25b420a831c860063b2841251b"><td class="memItemLeft" align="right" valign="top"><a id="a8dadda25b420a831c860063b2841251b"></a>
typedef base_class::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a8dadda25b420a831c860063b2841251b">memory_model</a></td></tr>
<tr class="memdesc:a8dadda25b420a831c860063b2841251b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering, see <code><a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">cds::opt::memory_model</a></code>. <br /></td></tr>
<tr class="separator:a8dadda25b420a831c860063b2841251b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce58c7cd2307f04c9320587702aebf3"><td class="memItemLeft" align="right" valign="top"><a id="a6ce58c7cd2307f04c9320587702aebf3"></a>
typedef traits::random_level_generator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a6ce58c7cd2307f04c9320587702aebf3">random_level_generator</a></td></tr>
<tr class="memdesc:a6ce58c7cd2307f04c9320587702aebf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">random level generator <br /></td></tr>
<tr class="separator:a6ce58c7cd2307f04c9320587702aebf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d247585a9c64680fa7f1dee01132175"><td class="memItemLeft" align="right" valign="top"><a id="a9d247585a9c64680fa7f1dee01132175"></a>
typedef traits::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a9d247585a9c64680fa7f1dee01132175">stat</a></td></tr>
<tr class="memdesc:a9d247585a9c64680fa7f1dee01132175"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics type <br /></td></tr>
<tr class="separator:a9d247585a9c64680fa7f1dee01132175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad354cc5fb06255b8d60c87c2a20ebedc"><td class="memItemLeft" align="right" valign="top"><a id="ad354cc5fb06255b8d60c87c2a20ebedc"></a>
typedef gc::template <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#ad354cc5fb06255b8d60c87c2a20ebedc">guarded_ptr</a>&lt; <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aeb1c111410605d85dee2daf622820e34">node_type</a>, <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#af71e523091dcd181e35c363f862be3df">value_type</a>, details::guarded_ptr_cast_set&lt; <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aeb1c111410605d85dee2daf622820e34">node_type</a>, <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#af71e523091dcd181e35c363f862be3df">value_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#ad354cc5fb06255b8d60c87c2a20ebedc">guarded_ptr</a></td></tr>
<tr class="memdesc:ad354cc5fb06255b8d60c87c2a20ebedc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded pointer. <br /></td></tr>
<tr class="separator:ad354cc5fb06255b8d60c87c2a20ebedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2f4fc6605f9d7ea0de43258d63351efe"><td class="memItemLeft" align="right" valign="top"><a id="a2f4fc6605f9d7ea0de43258d63351efe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a2f4fc6605f9d7ea0de43258d63351efe">SkipListMap</a> ()</td></tr>
<tr class="memdesc:a2f4fc6605f9d7ea0de43258d63351efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default ctor. <br /></td></tr>
<tr class="separator:a2f4fc6605f9d7ea0de43258d63351efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06c1bca1a241ac2d40190717f203103"><td class="memItemLeft" align="right" valign="top"><a id="ac06c1bca1a241ac2d40190717f203103"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#ac06c1bca1a241ac2d40190717f203103">~SkipListMap</a> ()</td></tr>
<tr class="memdesc:ac06c1bca1a241ac2d40190717f203103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor destroys the set object. <br /></td></tr>
<tr class="separator:ac06c1bca1a241ac2d40190717f203103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09105b5b70939bf5570889c117b19797"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a09105b5b70939bf5570889c117b19797"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a09105b5b70939bf5570889c117b19797">insert</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a09105b5b70939bf5570889c117b19797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node with key and default value.  <a href="#a09105b5b70939bf5570889c117b19797">More...</a><br /></td></tr>
<tr class="separator:a09105b5b70939bf5570889c117b19797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c6e0c78b65912ae3ed96aeae35fe56"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a81c6e0c78b65912ae3ed96aeae35fe56"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a81c6e0c78b65912ae3ed96aeae35fe56">insert</a> (K const &amp;key, V const &amp;val)</td></tr>
<tr class="memdesc:a81c6e0c78b65912ae3ed96aeae35fe56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a81c6e0c78b65912ae3ed96aeae35fe56">More...</a><br /></td></tr>
<tr class="separator:a81c6e0c78b65912ae3ed96aeae35fe56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1d51549a3942e8d75f8361adf6ce9e"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a3c1d51549a3942e8d75f8361adf6ce9e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a3c1d51549a3942e8d75f8361adf6ce9e">insert_with</a> (K const &amp;key, Func func)</td></tr>
<tr class="memdesc:a3c1d51549a3942e8d75f8361adf6ce9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node and initialize it by a functor.  <a href="#a3c1d51549a3942e8d75f8361adf6ce9e">More...</a><br /></td></tr>
<tr class="separator:a3c1d51549a3942e8d75f8361adf6ce9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6231f69856b735d69ad8dc82cf4b9181"><td class="memTemplParams" colspan="2">template&lt;typename K , typename... Args&gt; </td></tr>
<tr class="memitem:a6231f69856b735d69ad8dc82cf4b9181"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a6231f69856b735d69ad8dc82cf4b9181">emplace</a> (K &amp;&amp;key, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a6231f69856b735d69ad8dc82cf4b9181"><td class="mdescLeft">&#160;</td><td class="mdescRight">For key <code>key</code> inserts data of type <code>value_type</code> created in-place from <code>std::forward&lt;Args&gt;(args)...</code>  <a href="#a6231f69856b735d69ad8dc82cf4b9181">More...</a><br /></td></tr>
<tr class="separator:a6231f69856b735d69ad8dc82cf4b9181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27ba310bb08606dfda94bb58395a15c"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:ad27ba310bb08606dfda94bb58395a15c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#ad27ba310bb08606dfda94bb58395a15c">update</a> (K const &amp;key, Func func, bool bInsert=true)</td></tr>
<tr class="memdesc:ad27ba310bb08606dfda94bb58395a15c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates data by <code>key</code>.  <a href="#ad27ba310bb08606dfda94bb58395a15c">More...</a><br /></td></tr>
<tr class="separator:ad27ba310bb08606dfda94bb58395a15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed4be1892ca09e1431ad186428c6a43"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:afed4be1892ca09e1431ad186428c6a43"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#afed4be1892ca09e1431ad186428c6a43">erase</a> (K const &amp;key)</td></tr>
<tr class="memdesc:afed4be1892ca09e1431ad186428c6a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the map.  <a href="#afed4be1892ca09e1431ad186428c6a43">More...</a><br /></td></tr>
<tr class="separator:afed4be1892ca09e1431ad186428c6a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72868aa43ed97cfa0e61d27f7bf6c227"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a72868aa43ed97cfa0e61d27f7bf6c227"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a72868aa43ed97cfa0e61d27f7bf6c227">erase_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a72868aa43ed97cfa0e61d27f7bf6c227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the map using <code>pred</code> predicate for searching.  <a href="#a72868aa43ed97cfa0e61d27f7bf6c227">More...</a><br /></td></tr>
<tr class="separator:a72868aa43ed97cfa0e61d27f7bf6c227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34fd17f046af33c72bea66fba4795c8a"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a34fd17f046af33c72bea66fba4795c8a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a34fd17f046af33c72bea66fba4795c8a">erase</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:a34fd17f046af33c72bea66fba4795c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the map.  <a href="#a34fd17f046af33c72bea66fba4795c8a">More...</a><br /></td></tr>
<tr class="separator:a34fd17f046af33c72bea66fba4795c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13609ab5691e882619a6bbf43f4d9619"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a13609ab5691e882619a6bbf43f4d9619"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a13609ab5691e882619a6bbf43f4d9619">erase_with</a> (K const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:a13609ab5691e882619a6bbf43f4d9619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the map using <code>pred</code> predicate for searching.  <a href="#a13609ab5691e882619a6bbf43f4d9619">More...</a><br /></td></tr>
<tr class="separator:a13609ab5691e882619a6bbf43f4d9619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7784b99ef7041b7083ed978b854f002d"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a7784b99ef7041b7083ed978b854f002d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#ad354cc5fb06255b8d60c87c2a20ebedc">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a7784b99ef7041b7083ed978b854f002d">extract</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a7784b99ef7041b7083ed978b854f002d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item from the map with specified <code>key</code>.  <a href="#a7784b99ef7041b7083ed978b854f002d">More...</a><br /></td></tr>
<tr class="separator:a7784b99ef7041b7083ed978b854f002d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497e3d92841382816e09b48a243a4e85"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a497e3d92841382816e09b48a243a4e85"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#ad354cc5fb06255b8d60c87c2a20ebedc">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a497e3d92841382816e09b48a243a4e85">extract_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a497e3d92841382816e09b48a243a4e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item from the map with comparing functor <code>pred</code>.  <a href="#a497e3d92841382816e09b48a243a4e85">More...</a><br /></td></tr>
<tr class="separator:a497e3d92841382816e09b48a243a4e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c2f86a5ac435b83b99d39805790332"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#ad354cc5fb06255b8d60c87c2a20ebedc">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a21c2f86a5ac435b83b99d39805790332">extract_min</a> ()</td></tr>
<tr class="memdesc:a21c2f86a5ac435b83b99d39805790332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with minimal key from the map.  <a href="#a21c2f86a5ac435b83b99d39805790332">More...</a><br /></td></tr>
<tr class="separator:a21c2f86a5ac435b83b99d39805790332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7dee701d905f4f39facecc4d476720d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#ad354cc5fb06255b8d60c87c2a20ebedc">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#af7dee701d905f4f39facecc4d476720d">extract_max</a> ()</td></tr>
<tr class="memdesc:af7dee701d905f4f39facecc4d476720d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with maximal key from the map.  <a href="#af7dee701d905f4f39facecc4d476720d">More...</a><br /></td></tr>
<tr class="separator:af7dee701d905f4f39facecc4d476720d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04df5f693d7581836b929d89290dee6"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:ad04df5f693d7581836b929d89290dee6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#ad04df5f693d7581836b929d89290dee6">find</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:ad04df5f693d7581836b929d89290dee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>key</code>.  <a href="#ad04df5f693d7581836b929d89290dee6">More...</a><br /></td></tr>
<tr class="separator:ad04df5f693d7581836b929d89290dee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304f9f72e43eda4ca8d16d22273bd72f"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a304f9f72e43eda4ca8d16d22273bd72f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a304f9f72e43eda4ca8d16d22273bd72f">find_with</a> (K const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:a304f9f72e43eda4ca8d16d22273bd72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for searching.  <a href="#a304f9f72e43eda4ca8d16d22273bd72f">More...</a><br /></td></tr>
<tr class="separator:a304f9f72e43eda4ca8d16d22273bd72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff10327229c0f2d801d080ff515d6f5"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a2ff10327229c0f2d801d080ff515d6f5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a2ff10327229c0f2d801d080ff515d6f5">contains</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a2ff10327229c0f2d801d080ff515d6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the map contains <code>key</code>.  <a href="#a2ff10327229c0f2d801d080ff515d6f5">More...</a><br /></td></tr>
<tr class="separator:a2ff10327229c0f2d801d080ff515d6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa622f6e89c9d7fc507c6958fe1c38764"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:aa622f6e89c9d7fc507c6958fe1c38764"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#aa622f6e89c9d7fc507c6958fe1c38764">contains</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:aa622f6e89c9d7fc507c6958fe1c38764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>key</code> using <code>pred</code> predicate for searching.  <a href="#aa622f6e89c9d7fc507c6958fe1c38764">More...</a><br /></td></tr>
<tr class="separator:aa622f6e89c9d7fc507c6958fe1c38764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123229b5e06a28eff5eb29b2609594ec"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a123229b5e06a28eff5eb29b2609594ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#ad354cc5fb06255b8d60c87c2a20ebedc">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a123229b5e06a28eff5eb29b2609594ec">get</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a123229b5e06a28eff5eb29b2609594ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code> and return the item found.  <a href="#a123229b5e06a28eff5eb29b2609594ec">More...</a><br /></td></tr>
<tr class="separator:a123229b5e06a28eff5eb29b2609594ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02677c1a928b5d44cf3064bfa75a97c"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:ac02677c1a928b5d44cf3064bfa75a97c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#ad354cc5fb06255b8d60c87c2a20ebedc">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#ac02677c1a928b5d44cf3064bfa75a97c">get_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:ac02677c1a928b5d44cf3064bfa75a97c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code> and return the item found.  <a href="#ac02677c1a928b5d44cf3064bfa75a97c">More...</a><br /></td></tr>
<tr class="separator:ac02677c1a928b5d44cf3064bfa75a97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b96f19ec650683d4f3dd7bd480db49b"><td class="memItemLeft" align="right" valign="top"><a id="a9b96f19ec650683d4f3dd7bd480db49b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a9b96f19ec650683d4f3dd7bd480db49b">clear</a> ()</td></tr>
<tr class="memdesc:a9b96f19ec650683d4f3dd7bd480db49b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the map. <br /></td></tr>
<tr class="separator:a9b96f19ec650683d4f3dd7bd480db49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14efaca408d51d60c664ae6232985ea"><td class="memItemLeft" align="right" valign="top"><a id="aa14efaca408d51d60c664ae6232985ea"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#aa14efaca408d51d60c664ae6232985ea">empty</a> () const</td></tr>
<tr class="memdesc:aa14efaca408d51d60c664ae6232985ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the map is empty. <br /></td></tr>
<tr class="separator:aa14efaca408d51d60c664ae6232985ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080ce921e5052681a84e29114a72dd15"><td class="memItemLeft" align="right" valign="top"><a id="a080ce921e5052681a84e29114a72dd15"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a080ce921e5052681a84e29114a72dd15">size</a> () const</td></tr>
<tr class="memdesc:a080ce921e5052681a84e29114a72dd15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the map. <br /></td></tr>
<tr class="separator:a080ce921e5052681a84e29114a72dd15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac613b6f06fa1e61cbf8a9fa8bdc13729"><td class="memItemLeft" align="right" valign="top"><a id="ac613b6f06fa1e61cbf8a9fa8bdc13729"></a>
<a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a9d247585a9c64680fa7f1dee01132175">stat</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#ac613b6f06fa1e61cbf8a9fa8bdc13729">statistics</a> () const</td></tr>
<tr class="memdesc:ac613b6f06fa1e61cbf8a9fa8bdc13729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br /></td></tr>
<tr class="separator:ac613b6f06fa1e61cbf8a9fa8bdc13729"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a392fa0ab1a6a567647a680e2fc829918"><td class="memItemLeft" align="right" valign="top"><a id="a392fa0ab1a6a567647a680e2fc829918"></a>
static size_t const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a392fa0ab1a6a567647a680e2fc829918">c_nHazardPtrCount</a> = base_class::c_nHazardPtrCount</td></tr>
<tr class="memdesc:a392fa0ab1a6a567647a680e2fc829918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of hazard pointer required for the skip-list. <br /></td></tr>
<tr class="separator:a392fa0ab1a6a567647a680e2fc829918"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Forward iterators (only for debugging purpose)</h2></td></tr>
<tr class="memitem:a457e4cc42df8bd25208a4a2e0dc80b2e"><td class="memItemLeft" align="right" valign="top">typedef skip_list::details::iterator&lt; typename base_class::iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a457e4cc42df8bd25208a4a2e0dc80b2e">iterator</a></td></tr>
<tr class="memdesc:a457e4cc42df8bd25208a4a2e0dc80b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type.  <a href="#a457e4cc42df8bd25208a4a2e0dc80b2e">More...</a><br /></td></tr>
<tr class="separator:a457e4cc42df8bd25208a4a2e0dc80b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1c537d2bc2ed720066ea2198e5edad"><td class="memItemLeft" align="right" valign="top"><a id="acc1c537d2bc2ed720066ea2198e5edad"></a>
typedef skip_list::details::iterator&lt; typename base_class::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#acc1c537d2bc2ed720066ea2198e5edad">const_iterator</a></td></tr>
<tr class="memdesc:acc1c537d2bc2ed720066ea2198e5edad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const forward iterator type. <br /></td></tr>
<tr class="separator:acc1c537d2bc2ed720066ea2198e5edad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422b90c383b458fe52b746234055f4ab"><td class="memItemLeft" align="right" valign="top"><a id="a422b90c383b458fe52b746234055f4ab"></a>
<a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a457e4cc42df8bd25208a4a2e0dc80b2e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a422b90c383b458fe52b746234055f4ab">begin</a> ()</td></tr>
<tr class="memdesc:a422b90c383b458fe52b746234055f4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator addressing the first element in a map. <br /></td></tr>
<tr class="separator:a422b90c383b458fe52b746234055f4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9051dfd83820586eb39f6b255ded7b"><td class="memItemLeft" align="right" valign="top"><a id="a4e9051dfd83820586eb39f6b255ded7b"></a>
<a class="el" href="classcds_1_1container_1_1_skip_list_map.html#acc1c537d2bc2ed720066ea2198e5edad">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a4e9051dfd83820586eb39f6b255ded7b">begin</a> () const</td></tr>
<tr class="memdesc:a4e9051dfd83820586eb39f6b255ded7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a map. <br /></td></tr>
<tr class="separator:a4e9051dfd83820586eb39f6b255ded7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d317feead31a1ded0fcb5ff4228833"><td class="memItemLeft" align="right" valign="top"><a id="aa2d317feead31a1ded0fcb5ff4228833"></a>
<a class="el" href="classcds_1_1container_1_1_skip_list_map.html#acc1c537d2bc2ed720066ea2198e5edad">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#aa2d317feead31a1ded0fcb5ff4228833">cbegin</a> () const</td></tr>
<tr class="memdesc:aa2d317feead31a1ded0fcb5ff4228833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a map. <br /></td></tr>
<tr class="separator:aa2d317feead31a1ded0fcb5ff4228833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6337286cf3466305cec0a3bf973928"><td class="memItemLeft" align="right" valign="top"><a id="ace6337286cf3466305cec0a3bf973928"></a>
<a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a457e4cc42df8bd25208a4a2e0dc80b2e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#ace6337286cf3466305cec0a3bf973928">end</a> ()</td></tr>
<tr class="memdesc:ace6337286cf3466305cec0a3bf973928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator that addresses the location succeeding the last element in a map. <br /></td></tr>
<tr class="separator:ace6337286cf3466305cec0a3bf973928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97962c2d91acab497294af138539139"><td class="memItemLeft" align="right" valign="top"><a id="af97962c2d91acab497294af138539139"></a>
<a class="el" href="classcds_1_1container_1_1_skip_list_map.html#acc1c537d2bc2ed720066ea2198e5edad">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#af97962c2d91acab497294af138539139">end</a> () const</td></tr>
<tr class="memdesc:af97962c2d91acab497294af138539139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator that addresses the location succeeding the last element in a map. <br /></td></tr>
<tr class="separator:af97962c2d91acab497294af138539139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83881c99c9195c9a79dd432cdc0ac456"><td class="memItemLeft" align="right" valign="top"><a id="a83881c99c9195c9a79dd432cdc0ac456"></a>
<a class="el" href="classcds_1_1container_1_1_skip_list_map.html#acc1c537d2bc2ed720066ea2198e5edad">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a83881c99c9195c9a79dd432cdc0ac456">cend</a> () const</td></tr>
<tr class="memdesc:a83881c99c9195c9a79dd432cdc0ac456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator that addresses the location succeeding the last element in a map. <br /></td></tr>
<tr class="separator:a83881c99c9195c9a79dd432cdc0ac456"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classcds_1_1intrusive_1_1_skip_list_set')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet&lt; GC, std::pair&lt; Key const, T &gt;, Traits &gt;</a></td></tr>
<tr class="memitem:ab687ac3a8e557334e59f7b0373b70f0d inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="ab687ac3a8e557334e59f7b0373b70f0d"></a>
typedef node_type::atomic_marked_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ab687ac3a8e557334e59f7b0373b70f0d">atomic_node_ptr</a></td></tr>
<tr class="memdesc:ab687ac3a8e557334e59f7b0373b70f0d inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic marked node pointer. <br /></td></tr>
<tr class="separator:ab687ac3a8e557334e59f7b0373b70f0d inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c805bcce3eb95b1fc81ed212a90b3c5 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a8c805bcce3eb95b1fc81ed212a90b3c5"></a>
typedef node_type::marked_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a8c805bcce3eb95b1fc81ed212a90b3c5">marked_node_ptr</a></td></tr>
<tr class="memdesc:a8c805bcce3eb95b1fc81ed212a90b3c5 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node marked pointer. <br /></td></tr>
<tr class="separator:a8c805bcce3eb95b1fc81ed212a90b3c5 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121ea0b7fdd8c0e6796409fce834305e inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a121ea0b7fdd8c0e6796409fce834305e"></a>
typedef GC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a121ea0b7fdd8c0e6796409fce834305e">gc</a></td></tr>
<tr class="memdesc:a121ea0b7fdd8c0e6796409fce834305e inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br /></td></tr>
<tr class="separator:a121ea0b7fdd8c0e6796409fce834305e inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e97287193c265e405565645f3f3809 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a56e97287193c265e405565645f3f3809"></a>
typedef std::pair&lt; Key const, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a56e97287193c265e405565645f3f3809">value_type</a></td></tr>
<tr class="memdesc:a56e97287193c265e405565645f3f3809 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the skip-list <br /></td></tr>
<tr class="separator:a56e97287193c265e405565645f3f3809 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd2004e9bb6cf6a6df8cf39f9b00c27 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a0dd2004e9bb6cf6a6df8cf39f9b00c27"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a0dd2004e9bb6cf6a6df8cf39f9b00c27">traits</a></td></tr>
<tr class="memdesc:a0dd2004e9bb6cf6a6df8cf39f9b00c27 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits template parameter. <br /></td></tr>
<tr class="separator:a0dd2004e9bb6cf6a6df8cf39f9b00c27 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9abd070c6551d3fc3c46f0f70126c5 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a7c9abd070c6551d3fc3c46f0f70126c5"></a>
typedef traits::hook&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a7c9abd070c6551d3fc3c46f0f70126c5">hook</a></td></tr>
<tr class="memdesc:a7c9abd070c6551d3fc3c46f0f70126c5 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">hook type <br /></td></tr>
<tr class="separator:a7c9abd070c6551d3fc3c46f0f70126c5 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1c111410605d85dee2daf622820e34 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="aeb1c111410605d85dee2daf622820e34"></a>
typedef hook::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aeb1c111410605d85dee2daf622820e34">node_type</a></td></tr>
<tr class="memdesc:aeb1c111410605d85dee2daf622820e34 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">node type <br /></td></tr>
<tr class="separator:aeb1c111410605d85dee2daf622820e34 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4549fb15869b93cf05194c65fed873 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a3f4549fb15869b93cf05194c65fed873"></a>
typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a3f4549fb15869b93cf05194c65fed873">key_comparator</a></td></tr>
<tr class="memdesc:a3f4549fb15869b93cf05194c65fed873 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparison functor based on opt::compare and opt::less option setter. <br /></td></tr>
<tr class="separator:a3f4549fb15869b93cf05194c65fed873 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b394b2f922a1400b2eb2c3e6b2bacc inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="ae9b394b2f922a1400b2eb2c3e6b2bacc"></a>
typedef traits::disposer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ae9b394b2f922a1400b2eb2c3e6b2bacc">disposer</a></td></tr>
<tr class="memdesc:ae9b394b2f922a1400b2eb2c3e6b2bacc inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">item disposer <br /></td></tr>
<tr class="separator:ae9b394b2f922a1400b2eb2c3e6b2bacc inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7c65a30daf01ebe2e7c365f01d1129 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="ada7c65a30daf01ebe2e7c365f01d1129"></a>
typedef <a class="el" href="structcds_1_1intrusive_1_1get__node__traits.html">get_node_traits</a>&lt; <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a56e97287193c265e405565645f3f3809">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aeb1c111410605d85dee2daf622820e34">node_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a7c9abd070c6551d3fc3c46f0f70126c5">hook</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ada7c65a30daf01ebe2e7c365f01d1129">node_traits</a></td></tr>
<tr class="memdesc:ada7c65a30daf01ebe2e7c365f01d1129 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">node traits <br /></td></tr>
<tr class="separator:ada7c65a30daf01ebe2e7c365f01d1129 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ba2cd482243590355f3e07f31d5410 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="ad5ba2cd482243590355f3e07f31d5410"></a>
typedef traits::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ad5ba2cd482243590355f3e07f31d5410">item_counter</a></td></tr>
<tr class="memdesc:ad5ba2cd482243590355f3e07f31d5410 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy. <br /></td></tr>
<tr class="separator:ad5ba2cd482243590355f3e07f31d5410 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d335de0dc676276ffb41c842da0f0e inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="ac8d335de0dc676276ffb41c842da0f0e"></a>
typedef traits::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ac8d335de0dc676276ffb41c842da0f0e">memory_model</a></td></tr>
<tr class="memdesc:ac8d335de0dc676276ffb41c842da0f0e inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering, see <code><a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">cds::opt::memory_model</a></code> option. <br /></td></tr>
<tr class="separator:ac8d335de0dc676276ffb41c842da0f0e inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af8cf6e792b254e40124b677f946913 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a1af8cf6e792b254e40124b677f946913"></a>
typedef traits::random_level_generator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a1af8cf6e792b254e40124b677f946913">random_level_generator</a></td></tr>
<tr class="memdesc:a1af8cf6e792b254e40124b677f946913 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">random level generator <br /></td></tr>
<tr class="separator:a1af8cf6e792b254e40124b677f946913 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574d4a097c85e8f016b02775084d8188 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a574d4a097c85e8f016b02775084d8188"></a>
typedef traits::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a574d4a097c85e8f016b02775084d8188">allocator_type</a></td></tr>
<tr class="memdesc:a574d4a097c85e8f016b02775084d8188 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator for maintaining array of next pointers of the node <br /></td></tr>
<tr class="separator:a574d4a097c85e8f016b02775084d8188 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d807ce1c14954306ea2e1c51cb302b7 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a8d807ce1c14954306ea2e1c51cb302b7"></a>
typedef traits::back_off&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a8d807ce1c14954306ea2e1c51cb302b7">back_off</a></td></tr>
<tr class="memdesc:a8d807ce1c14954306ea2e1c51cb302b7 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Back-off strategy. <br /></td></tr>
<tr class="separator:a8d807ce1c14954306ea2e1c51cb302b7 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a61dadcef3d9667a679d57f7443a42 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="ae2a61dadcef3d9667a679d57f7443a42"></a>
typedef traits::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ae2a61dadcef3d9667a679d57f7443a42">stat</a></td></tr>
<tr class="memdesc:ae2a61dadcef3d9667a679d57f7443a42 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics type <br /></td></tr>
<tr class="separator:ae2a61dadcef3d9667a679d57f7443a42 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758da15b68e18ac7bd73c0f4aeae67f8 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a758da15b68e18ac7bd73c0f4aeae67f8"></a>
typedef gc::template <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a758da15b68e18ac7bd73c0f4aeae67f8">guarded_ptr</a>&lt; <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a56e97287193c265e405565645f3f3809">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a758da15b68e18ac7bd73c0f4aeae67f8">guarded_ptr</a></td></tr>
<tr class="memdesc:a758da15b68e18ac7bd73c0f4aeae67f8 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded pointer. <br /></td></tr>
<tr class="separator:a758da15b68e18ac7bd73c0f4aeae67f8 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5837aaa0b5d7e47b3df0b13c66ed4f inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">typedef skip_list::details::iterator&lt; <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a121ea0b7fdd8c0e6796409fce834305e">gc</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ada7c65a30daf01ebe2e7c365f01d1129">node_traits</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a8d807ce1c14954306ea2e1c51cb302b7">back_off</a>, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aef5837aaa0b5d7e47b3df0b13c66ed4f">iterator</a></td></tr>
<tr class="memdesc:aef5837aaa0b5d7e47b3df0b13c66ed4f inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#aef5837aaa0b5d7e47b3df0b13c66ed4f">More...</a><br /></td></tr>
<tr class="separator:aef5837aaa0b5d7e47b3df0b13c66ed4f inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf8dabaa6f1f1bacee706f8c71e0896 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="aadf8dabaa6f1f1bacee706f8c71e0896"></a>
typedef skip_list::details::iterator&lt; <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a121ea0b7fdd8c0e6796409fce834305e">gc</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ada7c65a30daf01ebe2e7c365f01d1129">node_traits</a>, <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a8d807ce1c14954306ea2e1c51cb302b7">back_off</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aadf8dabaa6f1f1bacee706f8c71e0896">const_iterator</a></td></tr>
<tr class="memdesc:aadf8dabaa6f1f1bacee706f8c71e0896 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator type. <br /></td></tr>
<tr class="separator:aadf8dabaa6f1f1bacee706f8c71e0896 inherit pro_types_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classcds_1_1intrusive_1_1_skip_list_set')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet&lt; GC, std::pair&lt; Key const, T &gt;, Traits &gt;</a></td></tr>
<tr class="memitem:ae919ad1a045a397fda269e2c2924b818 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ae919ad1a045a397fda269e2c2924b818">SkipListSet</a> ()</td></tr>
<tr class="memdesc:ae919ad1a045a397fda269e2c2924b818 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#ae919ad1a045a397fda269e2c2924b818">More...</a><br /></td></tr>
<tr class="separator:ae919ad1a045a397fda269e2c2924b818 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71bc587ae2e26e0fb5aae6fbc155e3f inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="aa71bc587ae2e26e0fb5aae6fbc155e3f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aa71bc587ae2e26e0fb5aae6fbc155e3f">~SkipListSet</a> ()</td></tr>
<tr class="memdesc:aa71bc587ae2e26e0fb5aae6fbc155e3f inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears and destructs the skip-list. <br /></td></tr>
<tr class="separator:aa71bc587ae2e26e0fb5aae6fbc155e3f inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51afff99d91ece7435020b6715697b91 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a51afff99d91ece7435020b6715697b91">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a56e97287193c265e405565645f3f3809">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a51afff99d91ece7435020b6715697b91 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a51afff99d91ece7435020b6715697b91">More...</a><br /></td></tr>
<tr class="separator:a51afff99d91ece7435020b6715697b91 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cce1422756e1f63a84f67c5a78d9553 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a8cce1422756e1f63a84f67c5a78d9553">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a56e97287193c265e405565645f3f3809">value_type</a> &amp;val, Func f)</td></tr>
<tr class="memdesc:a8cce1422756e1f63a84f67c5a78d9553 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a8cce1422756e1f63a84f67c5a78d9553">More...</a><br /></td></tr>
<tr class="separator:a8cce1422756e1f63a84f67c5a78d9553 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae105856d6ea412dc3283d01cfed5e1 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#acae105856d6ea412dc3283d01cfed5e1">update</a> (<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a56e97287193c265e405565645f3f3809">value_type</a> &amp;val, Func func, bool bInsert=true)</td></tr>
<tr class="memdesc:acae105856d6ea412dc3283d01cfed5e1 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the node.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#acae105856d6ea412dc3283d01cfed5e1">More...</a><br /></td></tr>
<tr class="separator:acae105856d6ea412dc3283d01cfed5e1 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0561887682f47f5358170b6a87ca18 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a6c0561887682f47f5358170b6a87ca18">unlink</a> (<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a56e97287193c265e405565645f3f3809">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a6c0561887682f47f5358170b6a87ca18 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlinks the item <code>val</code> from the set.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a6c0561887682f47f5358170b6a87ca18">More...</a><br /></td></tr>
<tr class="separator:a6c0561887682f47f5358170b6a87ca18 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b615614b9ee394bd38a60d71bb4156 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a758da15b68e18ac7bd73c0f4aeae67f8">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a90b615614b9ee394bd38a60d71bb4156">extract</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a90b615614b9ee394bd38a60d71bb4156 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item from the set with specified <code>key</code>.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a90b615614b9ee394bd38a60d71bb4156">More...</a><br /></td></tr>
<tr class="separator:a90b615614b9ee394bd38a60d71bb4156 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e441df6f9fc2627e95d320ee6375871 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a758da15b68e18ac7bd73c0f4aeae67f8">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a7e441df6f9fc2627e95d320ee6375871">extract_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a7e441df6f9fc2627e95d320ee6375871 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item from the set with comparing functor <code>pred</code>.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a7e441df6f9fc2627e95d320ee6375871">More...</a><br /></td></tr>
<tr class="separator:a7e441df6f9fc2627e95d320ee6375871 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ba518ea3321e4d0434b62ebeb6e19c inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a758da15b68e18ac7bd73c0f4aeae67f8">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a95ba518ea3321e4d0434b62ebeb6e19c">extract_min</a> ()</td></tr>
<tr class="memdesc:a95ba518ea3321e4d0434b62ebeb6e19c inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with minimal key from the list.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a95ba518ea3321e4d0434b62ebeb6e19c">More...</a><br /></td></tr>
<tr class="separator:a95ba518ea3321e4d0434b62ebeb6e19c inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e17af7064fa115bb4ef40789beac714 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a758da15b68e18ac7bd73c0f4aeae67f8">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a5e17af7064fa115bb4ef40789beac714">extract_max</a> ()</td></tr>
<tr class="memdesc:a5e17af7064fa115bb4ef40789beac714 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with maximal key from the list.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a5e17af7064fa115bb4ef40789beac714">More...</a><br /></td></tr>
<tr class="separator:a5e17af7064fa115bb4ef40789beac714 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442cc388b70130898a6a40e53e5286b6 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a442cc388b70130898a6a40e53e5286b6">erase</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a442cc388b70130898a6a40e53e5286b6 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a442cc388b70130898a6a40e53e5286b6">More...</a><br /></td></tr>
<tr class="separator:a442cc388b70130898a6a40e53e5286b6 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1831116fe2eaea39643d3fcb65371d5b inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a1831116fe2eaea39643d3fcb65371d5b">erase</a> (Q const &amp;key, Func f)</td></tr>
<tr class="memdesc:a1831116fe2eaea39643d3fcb65371d5b inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a1831116fe2eaea39643d3fcb65371d5b">More...</a><br /></td></tr>
<tr class="separator:a1831116fe2eaea39643d3fcb65371d5b inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e1caa5f872abb2fd071c6b6d43f016 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ad7e1caa5f872abb2fd071c6b6d43f016">erase_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:ad7e1caa5f872abb2fd071c6b6d43f016 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set with comparing functor <code>pred</code>.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#ad7e1caa5f872abb2fd071c6b6d43f016">More...</a><br /></td></tr>
<tr class="separator:ad7e1caa5f872abb2fd071c6b6d43f016 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b7ec55a6a3f0005cbf03a3829a67c7 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a06b7ec55a6a3f0005cbf03a3829a67c7">erase_with</a> (Q const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:a06b7ec55a6a3f0005cbf03a3829a67c7 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set with comparing functor <code>pred</code>.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a06b7ec55a6a3f0005cbf03a3829a67c7">More...</a><br /></td></tr>
<tr class="separator:a06b7ec55a6a3f0005cbf03a3829a67c7 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc70165841bf8871caed0a1f8c0dece inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a3dc70165841bf8871caed0a1f8c0dece">find</a> (Q &amp;key, Func f)</td></tr>
<tr class="memdesc:a3dc70165841bf8871caed0a1f8c0dece inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code>.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a3dc70165841bf8871caed0a1f8c0dece">More...</a><br /></td></tr>
<tr class="separator:a3dc70165841bf8871caed0a1f8c0dece inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90bce91b752b0998e66fc3e7ed403b6 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aa90bce91b752b0998e66fc3e7ed403b6">find_with</a> (Q &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:aa90bce91b752b0998e66fc3e7ed403b6 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code> with <code>pred</code> predicate for comparing.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#aa90bce91b752b0998e66fc3e7ed403b6">More...</a><br /></td></tr>
<tr class="separator:aa90bce91b752b0998e66fc3e7ed403b6 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36002a45fe274785c75df1ec1fb45f7b inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a36002a45fe274785c75df1ec1fb45f7b">contains</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a36002a45fe274785c75df1ec1fb45f7b inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>key</code>.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a36002a45fe274785c75df1ec1fb45f7b">More...</a><br /></td></tr>
<tr class="separator:a36002a45fe274785c75df1ec1fb45f7b inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9144433fb4828db74b8066ea785e775f inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a9144433fb4828db74b8066ea785e775f">contains</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a9144433fb4828db74b8066ea785e775f inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>key</code> using <code>pred</code> predicate for searching.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a9144433fb4828db74b8066ea785e775f">More...</a><br /></td></tr>
<tr class="separator:a9144433fb4828db74b8066ea785e775f inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba7de0d4e7a8f1097c481f46b7a1ca0 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a758da15b68e18ac7bd73c0f4aeae67f8">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a6ba7de0d4e7a8f1097c481f46b7a1ca0">get</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a6ba7de0d4e7a8f1097c481f46b7a1ca0 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> and return the item found.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a6ba7de0d4e7a8f1097c481f46b7a1ca0">More...</a><br /></td></tr>
<tr class="separator:a6ba7de0d4e7a8f1097c481f46b7a1ca0 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516aac70e4451b8b1df59510e0bdd6bc inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a758da15b68e18ac7bd73c0f4aeae67f8">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a516aac70e4451b8b1df59510e0bdd6bc">get_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a516aac70e4451b8b1df59510e0bdd6bc inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> and return the item found.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a516aac70e4451b8b1df59510e0bdd6bc">More...</a><br /></td></tr>
<tr class="separator:a516aac70e4451b8b1df59510e0bdd6bc inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b03c24311d1d458d3e4c2d508b2b12e inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a3b03c24311d1d458d3e4c2d508b2b12e">size</a> () const</td></tr>
<tr class="memdesc:a3b03c24311d1d458d3e4c2d508b2b12e inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a3b03c24311d1d458d3e4c2d508b2b12e">More...</a><br /></td></tr>
<tr class="separator:a3b03c24311d1d458d3e4c2d508b2b12e inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c86bda8d2579181ba1bda3f2ae32419 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a2c86bda8d2579181ba1bda3f2ae32419"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a2c86bda8d2579181ba1bda3f2ae32419">empty</a> () const</td></tr>
<tr class="memdesc:a2c86bda8d2579181ba1bda3f2ae32419 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty. <br /></td></tr>
<tr class="separator:a2c86bda8d2579181ba1bda3f2ae32419 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28947a855f1e0e702da233287eb3c59f inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a28947a855f1e0e702da233287eb3c59f">clear</a> ()</td></tr>
<tr class="memdesc:a28947a855f1e0e702da233287eb3c59f inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set (not atomic)  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a28947a855f1e0e702da233287eb3c59f">More...</a><br /></td></tr>
<tr class="separator:a28947a855f1e0e702da233287eb3c59f inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50eceb105e53ffdab01e8f5bb65fa62f inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a50eceb105e53ffdab01e8f5bb65fa62f"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ae2a61dadcef3d9667a679d57f7443a42">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a50eceb105e53ffdab01e8f5bb65fa62f">statistics</a> () const</td></tr>
<tr class="memdesc:a50eceb105e53ffdab01e8f5bb65fa62f inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br /></td></tr>
<tr class="separator:a50eceb105e53ffdab01e8f5bb65fa62f inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b00185809fb7842667287ed4a2ee0c2 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a4b00185809fb7842667287ed4a2ee0c2"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aef5837aaa0b5d7e47b3df0b13c66ed4f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a4b00185809fb7842667287ed4a2ee0c2">begin</a> ()</td></tr>
<tr class="memdesc:a4b00185809fb7842667287ed4a2ee0c2 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator addressing the first element in a set. <br /></td></tr>
<tr class="separator:a4b00185809fb7842667287ed4a2ee0c2 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae452d327ab88ee1bcc97592bdf91d2cc inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="ae452d327ab88ee1bcc97592bdf91d2cc"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aadf8dabaa6f1f1bacee706f8c71e0896">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#ae452d327ab88ee1bcc97592bdf91d2cc">begin</a> () const</td></tr>
<tr class="memdesc:ae452d327ab88ee1bcc97592bdf91d2cc inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a set. <br /></td></tr>
<tr class="separator:ae452d327ab88ee1bcc97592bdf91d2cc inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c0269e4f5f6f1f2da64afb977b1dd3 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a67c0269e4f5f6f1f2da64afb977b1dd3"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aadf8dabaa6f1f1bacee706f8c71e0896">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a67c0269e4f5f6f1f2da64afb977b1dd3">cbegin</a> () const</td></tr>
<tr class="memdesc:a67c0269e4f5f6f1f2da64afb977b1dd3 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a set. <br /></td></tr>
<tr class="separator:a67c0269e4f5f6f1f2da64afb977b1dd3 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af350224256d13022cc13025597668139 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="af350224256d13022cc13025597668139"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aef5837aaa0b5d7e47b3df0b13c66ed4f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#af350224256d13022cc13025597668139">end</a> ()</td></tr>
<tr class="memdesc:af350224256d13022cc13025597668139 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator that addresses the location succeeding the last element in a set. <br /></td></tr>
<tr class="separator:af350224256d13022cc13025597668139 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d11738d37b967d2ae0be5bf3c883536 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a8d11738d37b967d2ae0be5bf3c883536"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aadf8dabaa6f1f1bacee706f8c71e0896">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a8d11738d37b967d2ae0be5bf3c883536">end</a> () const</td></tr>
<tr class="memdesc:a8d11738d37b967d2ae0be5bf3c883536 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator that addresses the location succeeding the last element in a set. <br /></td></tr>
<tr class="separator:a8d11738d37b967d2ae0be5bf3c883536 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e4f545922f036c2363f3f1eb0c9aa4 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="aa4e4f545922f036c2363f3f1eb0c9aa4"></a>
<a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aadf8dabaa6f1f1bacee706f8c71e0896">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aa4e4f545922f036c2363f3f1eb0c9aa4">cend</a> () const</td></tr>
<tr class="memdesc:aa4e4f545922f036c2363f3f1eb0c9aa4 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator that addresses the location succeeding the last element in a set. <br /></td></tr>
<tr class="separator:aa4e4f545922f036c2363f3f1eb0c9aa4 inherit pro_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classcds_1_1intrusive_1_1_skip_list_set"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classcds_1_1intrusive_1_1_skip_list_set')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet&lt; GC, std::pair&lt; Key const, T &gt;, Traits &gt;</a></td></tr>
<tr class="memitem:a891742e136dd2a31a2bdc80ecfdf73f4 inherit pro_static_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="a891742e136dd2a31a2bdc80ecfdf73f4"></a>
static constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a891742e136dd2a31a2bdc80ecfdf73f4">max_height</a> () noexcept()</td></tr>
<tr class="memdesc:a891742e136dd2a31a2bdc80ecfdf73f4 inherit pro_static_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns maximum height of skip-list. The max height is a constant for each object and does not exceed 32. <br /></td></tr>
<tr class="separator:a891742e136dd2a31a2bdc80ecfdf73f4 inherit pro_static_methods_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classcds_1_1intrusive_1_1_skip_list_set"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classcds_1_1intrusive_1_1_skip_list_set')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html">cds::intrusive::SkipListSet&lt; GC, std::pair&lt; Key const, T &gt;, Traits &gt;</a></td></tr>
<tr class="memitem:a92a0f389d6be4dd2dc2ea005aa49e79e inherit pro_static_attribs_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top">static unsigned int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#a92a0f389d6be4dd2dc2ea005aa49e79e">c_nMaxHeight</a></td></tr>
<tr class="memdesc:a92a0f389d6be4dd2dc2ea005aa49e79e inherit pro_static_attribs_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max node height. The actual node height should be in range <code>[0 .. c_nMaxHeight)</code>  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#a92a0f389d6be4dd2dc2ea005aa49e79e">More...</a><br /></td></tr>
<tr class="separator:a92a0f389d6be4dd2dc2ea005aa49e79e inherit pro_static_attribs_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad011a35dde50fa4b515466dadcf27a2 inherit pro_static_attribs_classcds_1_1intrusive_1_1_skip_list_set"><td class="memItemLeft" align="right" valign="top"><a id="aad011a35dde50fa4b515466dadcf27a2"></a>
static size_t const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html#aad011a35dde50fa4b515466dadcf27a2">c_nHazardPtrCount</a></td></tr>
<tr class="memdesc:aad011a35dde50fa4b515466dadcf27a2 inherit pro_static_attribs_classcds_1_1intrusive_1_1_skip_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of hazard pointer required for the skip-list. <br /></td></tr>
<tr class="separator:aad011a35dde50fa4b515466dadcf27a2 inherit pro_static_attribs_classcds_1_1intrusive_1_1_skip_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename GC, typename Key, typename T, typename Traits = skip_list::traits&gt;<br />
class cds::container::SkipListMap&lt; GC, Key, T, Traits &gt;</h3>

<p>Lock-free skip-list map. </p>
<p><a class="anchor" id="cds_nonintrusive_SkipListMap_hp"></a> The implementation of well-known probabilistic data structure called skip-list invented by W.Pugh in his papers:</p><ul>
<li>[1989] W.Pugh Skip Lists: A Probabilistic Alternative to Balanced Trees</li>
<li>[1990] W.Pugh A Skip List Cookbook</li>
</ul>
<p>A skip-list is a probabilistic data structure that provides expected logarithmic time search without the need of rebalance. The skip-list is a collection of sorted linked list. Nodes are ordered by key. Each node is linked into a subset of the lists. Each list has a level, ranging from 0 to 32. The bottom-level list contains all the nodes, and each higher-level list is a sublist of the lower-level lists. Each node is created with a random top level (with a random height), and belongs to all lists up to that level. The probability that a node has the height 1 is 1/2. The probability that a node has the height N is 1/2 ** N (more precisely, the distribution depends on an random generator provided, but our generators have this property).</p>
<p>The lock-free variant of skip-list is implemented according to book</p><ul>
<li>[2008] M.Herlihy, N.Shavit "The Art of Multiprocessor Programming", chapter 14.4 "A Lock-Free Concurrent Skiplist"</li>
</ul>
<p>Template arguments:</p><ul>
<li><code>GC</code> - Garbage collector used.</li>
<li><code>K</code> - type of a key to be stored in the list.</li>
<li><code>T</code> - type of a value to be stored in the list.</li>
<li><code>Traits</code> - map traits, default is <code><a class="el" href="structcds_1_1container_1_1skip__list_1_1traits.html" title="SkipListSet traits. ">skip_list::traits</a></code> It is possible to declare option-based list with <code><a class="el" href="structcds_1_1container_1_1skip__list_1_1make__traits.html" title="Metafunction converting option list to SkipListSet traits. ">cds::container::skip_list::make_traits</a></code> metafunction istead of <code>Traits</code> template argument.</li>
</ul>
<p>Like STL map class, <code>SkipListMap</code> stores the key-value pair as <code>std:pair&lt; K const, T&gt;</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The skip-list requires up to 67 hazard pointers that may be critical for some GCs for which the guard count is limited (like <code><a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector. ">gc::HP</a></code>). Those GCs should be explicitly initialized with hazard pointer enough:<div class="fragment"><div class="line">cds::gc::HP myhp( 67 ) </div></div><!-- fragment -->. Otherwise an run-time exception may be raised when you try to create skip-list object.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>There are several specializations of <code>SkipListMap</code> for each <code>GC</code>. You should include:<ul>
<li><code>&lt;cds/container/skip_list_map_hp.h&gt;</code> for <code><a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector. ">gc::HP</a></code> garbage collector</li>
<li><code>&lt;cds/container/skip_list_map_dhp.h&gt;</code> for <code><a class="el" href="classcds_1_1gc_1_1_d_h_p.html" title="Dynamic Hazard Pointer garbage collector. ">gc::DHP</a></code> garbage collector</li>
<li><code>&lt;cds/container/skip_list_map_rcu.h&gt;</code> for <a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#cds_nonintrusive_SkipListMap_rcu">RCU type</a></li>
<li><code>&lt;cds/container/skip_list_map_nogc.h&gt;</code> for <a class="el" href="classcds_1_1container_1_1_skip_list_map_3_01cds_1_1gc_1_1nogc_00_01_key_00_01_t_00_01_traits_01_4.html#cds_nonintrusive_SkipListMap_nogc">non-deletable SkipListMap</a> </li>
</ul>
</dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a457e4cc42df8bd25208a4a2e0dc80b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457e4cc42df8bd25208a4a2e0dc80b2e">&sect;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef skip_list::details::iterator&lt; typename base_class::iterator &gt; <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; GC, Key, T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a457e4cc42df8bd25208a4a2e0dc80b2e">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator type. </p>
<p>The forward iterator has some features:</p><ul>
<li>it is ordered</li>
<li>it has no post-increment operator</li>
<li>to protect the value, the iterator contains a GC-specific guard + another guard is required locally for increment operator. For some GC (like as <code><a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector. ">gc::HP</a></code>), a guard is a limited resource per thread, so an exception (or assertion) "no free guard" may be thrown if the limit of guard count per thread is exceeded.</li>
<li>The iterator cannot be moved across thread boundary because it contains thread-private GC's guard.</li>
<li>Iterator ensures thread-safety even if you delete the item the iterator points to. However, in case of concurrent deleting operations there is no guarantee that you iterate all item in the list. Moreover, a crash is possible when you try to iterate the next element that has been deleted by concurrent thread.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>Use this iterator on the concurrent container for debugging purpose only.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><code><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#ace6337286cf3466305cec0a3bf973928" title="Returns a forward iterator that addresses the location succeeding the last element in a map...">end()</a></code> and <code><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#a83881c99c9195c9a79dd432cdc0ac456" title="Returns a forward const iterator that addresses the location succeeding the last element in a map...">cend()</a></code> are not dereferenceable.</dd></dl>
<p>The iterator interface: </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="classcds_1_1container_1_1_skip_list_map.html#a457e4cc42df8bd25208a4a2e0dc80b2e">iterator</a> {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Default constructor</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_skip_list_map.html#a457e4cc42df8bd25208a4a2e0dc80b2e">iterator</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Copy construtor</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_skip_list_map.html#a457e4cc42df8bd25208a4a2e0dc80b2e">iterator</a>( <a class="code" href="classcds_1_1container_1_1_skip_list_map.html#a457e4cc42df8bd25208a4a2e0dc80b2e">iterator</a> <span class="keyword">const</span>&amp; src );</div><div class="line"></div><div class="line">    <span class="comment">// Dereference operator</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_skip_list_map.html#af71e523091dcd181e35c363f862be3df">value_type</a> * operator -&gt;() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Dereference operator</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_skip_list_map.html#af71e523091dcd181e35c363f862be3df">value_type</a>&amp; operator *() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Preincrement operator</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_skip_list_map.html#a457e4cc42df8bd25208a4a2e0dc80b2e">iterator</a>&amp; operator ++();</div><div class="line"></div><div class="line">    <span class="comment">// Assignment operator</span></div><div class="line">    <a class="code" href="classcds_1_1container_1_1_skip_list_map.html#a457e4cc42df8bd25208a4a2e0dc80b2e">iterator</a>&amp; operator = (<a class="code" href="classcds_1_1container_1_1_skip_list_map.html#a457e4cc42df8bd25208a4a2e0dc80b2e">iterator</a> <span class="keyword">const</span>&amp; src);</div><div class="line"></div><div class="line">    <span class="comment">// Equality operators</span></div><div class="line">    <span class="keywordtype">bool</span> operator ==(<a class="code" href="classcds_1_1container_1_1_skip_list_map.html#a457e4cc42df8bd25208a4a2e0dc80b2e">iterator</a> <span class="keyword">const</span>&amp; i ) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">bool</span> operator !=(<a class="code" href="classcds_1_1container_1_1_skip_list_map.html#a457e4cc42df8bd25208a4a2e0dc80b2e">iterator</a> <span class="keyword">const</span>&amp; i ) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2ff10327229c0f2d801d080ff515d6f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ff10327229c0f2d801d080ff515d6f5">&sect;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; GC, Key, T, Traits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the map contains <code>key</code>. </p>
<p>The function searches the item with key equal to <code>key</code> and returns <code>true</code> if it is found, and <code>false</code> otherwise. </p>

</div>
</div>
<a id="aa622f6e89c9d7fc507c6958fe1c38764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa622f6e89c9d7fc507c6958fe1c38764">&sect;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; GC, Key, T, Traits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the set contains <code>key</code> using <code>pred</code> predicate for searching. </p>
<p>The function is similar to <code>contains( key )</code> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a id="a6231f69856b735d69ad8dc82cf4b9181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6231f69856b735d69ad8dc82cf4b9181">&sect;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; GC, Key, T, Traits &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For key <code>key</code> inserts data of type <code>value_type</code> created in-place from <code>std::forward&lt;Args&gt;(args)...</code> </p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise. </p>

</div>
</div>
<a id="afed4be1892ca09e1431ad186428c6a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afed4be1892ca09e1431ad186428c6a43">&sect;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; GC, Key, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the map. </p>
<p><a class="anchor" id="cds_nonintrusive_SkipListMap_erase_val"></a> Return <code>true</code> if <code>key</code> is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a id="a34fd17f046af33c72bea66fba4795c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34fd17f046af33c72bea66fba4795c8a">&sect;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; GC, Key, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the map. </p>
<p><a class="anchor" id="cds_nonintrusive_SkipListMap_erase_func"></a> The function searches an item with key <code>key</code>, calls <code>f</code> functor and deletes the item. If <code>key</code> is not found, the functor is not called.</p>
<p>The functor <code>Func</code> interface: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>extractor {</div><div class="line">    <span class="keywordtype">void</span> operator()(<a class="code" href="classcds_1_1container_1_1_skip_list_map.html#af71e523091dcd181e35c363f862be3df">value_type</a>&amp; item) { ... }</div><div class="line">};</div></div><!-- fragment --><p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a id="a72868aa43ed97cfa0e61d27f7bf6c227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72868aa43ed97cfa0e61d27f7bf6c227">&sect;&nbsp;</a></span>erase_with() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; GC, Key, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the map using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#cds_nonintrusive_SkipListMap_erase_val">erase(K const&amp;)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a id="a13609ab5691e882619a6bbf43f4d9619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13609ab5691e882619a6bbf43f4d9619">&sect;&nbsp;</a></span>erase_with() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; GC, Key, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the map using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#cds_nonintrusive_SkipListMap_erase_func">erase(K const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a id="a7784b99ef7041b7083ed978b854f002d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7784b99ef7041b7083ed978b854f002d">&sect;&nbsp;</a></span>extract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#ad354cc5fb06255b8d60c87c2a20ebedc">guarded_ptr</a> <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; GC, Key, T, Traits &gt;::extract </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the item from the map with specified <code>key</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_SkipListMap_hp_extract"></a>The function searches an item with key equal to <code>key</code> in the map, unlinks it from the map, and returns a guarded pointer to the item found. If <code>key</code> is not found the function returns an empty guarded pointer.</p>
<p>Note the compare functor should accept a parameter of type <code>K</code> that can be not the same as <code>key_type</code>.</p>
<p>The item extracted is freed automatically by garbage collector <code>GC</code> when returned <code>guarded_ptr</code> object will be destroyed or released. </p><dl class="section note"><dt>Note</dt><dd>Each <code>guarded_ptr</code> object uses the GC's guard that can be limited resource.</dd></dl>
<p>Usage: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap&lt; cds::gc::HP, int, foo, my_traits &gt;</a>  skip_list;</div><div class="line">skip_list theList;</div><div class="line"><span class="comment">// ...</span></div><div class="line">{</div><div class="line">    skip_list::guarded_ptr gp( theList.extract( 5 ));</div><div class="line">    <span class="keywordflow">if</span> ( gp ) {</div><div class="line">        <span class="comment">// Deal with gp</span></div><div class="line">        <span class="comment">// ...</span></div><div class="line">    }</div><div class="line">    <span class="comment">// Destructor of gp releases internal HP guard and frees the pointer</span></div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="af7dee701d905f4f39facecc4d476720d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7dee701d905f4f39facecc4d476720d">&sect;&nbsp;</a></span>extract_max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#ad354cc5fb06255b8d60c87c2a20ebedc">guarded_ptr</a> <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; GC, Key, T, Traits &gt;::extract_max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item with maximal key from the map. </p>
<p>The function searches an item with maximal key, unlinks it, and returns a guarded pointer to item found. If the skip-list is empty the function returns an empty <code>guarded_ptr</code>.</p>
<p>The item found is freed by garbage collector <code>GC</code> automatically when returned <code>guarded_ptr</code> object will be destroyed or released. </p><dl class="section note"><dt>Note</dt><dd>Each <code>guarded_ptr</code> object uses the GC's guard that can be limited resource.</dd></dl>
<p>Usage: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap&lt; cds::gc::HP, int, foo, my_traits &gt;</a>  skip_list;</div><div class="line">skip_list theList;</div><div class="line"><span class="comment">// ...</span></div><div class="line">{</div><div class="line">    skip_list::guarded_ptr gp( theList.extract_max());</div><div class="line">    <span class="keywordflow">if</span> ( gp ) {</div><div class="line">        <span class="comment">// Deal with gp</span></div><div class="line">        <span class="comment">//...</span></div><div class="line">    }</div><div class="line">    <span class="comment">// Destructor of gp releases internal HP guard and then frees the pointer</span></div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="a21c2f86a5ac435b83b99d39805790332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c2f86a5ac435b83b99d39805790332">&sect;&nbsp;</a></span>extract_min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#ad354cc5fb06255b8d60c87c2a20ebedc">guarded_ptr</a> <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; GC, Key, T, Traits &gt;::extract_min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item with minimal key from the map. </p>
<p>The function searches an item with minimal key, unlinks it, and returns an guarded pointer to the item found. If the skip-list is empty the function returns an empty guarded pointer.</p>
<p>The item extracted is freed automatically by garbage collector <code>GC</code> when returned <code>guarded_ptr</code> object will be destroyed or released. </p><dl class="section note"><dt>Note</dt><dd>Each <code>guarded_ptr</code> object uses the GC's guard that can be limited resource.</dd></dl>
<p>Usage: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> cds::continer::SkipListMap&lt; cds::gc::HP, int, foo, my_traits &gt;  skip_list;</div><div class="line">skip_list theList;</div><div class="line"><span class="comment">// ...</span></div><div class="line">{</div><div class="line">    skip_list::guarded_ptr gp( theList.extract_min());</div><div class="line">    <span class="keywordflow">if</span> ( gp ) {</div><div class="line">        <span class="comment">// Deal with gp</span></div><div class="line">        <span class="comment">//...</span></div><div class="line">    }</div><div class="line">    <span class="comment">// Destructor of gp releases internal HP guard and then frees the pointer</span></div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="a497e3d92841382816e09b48a243a4e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a497e3d92841382816e09b48a243a4e85">&sect;&nbsp;</a></span>extract_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#ad354cc5fb06255b8d60c87c2a20ebedc">guarded_ptr</a> <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; GC, Key, T, Traits &gt;::extract_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the item from the map with comparing functor <code>pred</code>. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#cds_nonintrusive_SkipListMap_hp_extract">extract(K const&amp;)</a> but <code>pred</code> predicate is used for key comparing.</p>
<p><code>Less</code> functor has the semantics like <code>std::less</code> but should take arguments of type <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#adcff161d75ab8f150a8973c098d5bf3b">key_type</a> and <code>K</code> in any order. <code>pred</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a id="ad04df5f693d7581836b929d89290dee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04df5f693d7581836b929d89290dee6">&sect;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; GC, Key, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>key</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_SkipListMap_find_cfunc"></a> The function searches the item with key equal to <code>key</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div><div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_skip_list_map.html#af71e523091dcd181e35c363f862be3df">value_type</a>&amp; item );</div><div class="line">};</div></div><!-- fragment --><p> where <code>item</code> is the item found.</p>
<p>The functor may change <code>item.second</code>.</p>
<p>The function returns <code>true</code> if <code>key</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a id="a304f9f72e43eda4ca8d16d22273bd72f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a304f9f72e43eda4ca8d16d22273bd72f">&sect;&nbsp;</a></span>find_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; GC, Key, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#cds_nonintrusive_SkipListMap_find_cfunc">find(K const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a id="a123229b5e06a28eff5eb29b2609594ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123229b5e06a28eff5eb29b2609594ec">&sect;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#ad354cc5fb06255b8d60c87c2a20ebedc">guarded_ptr</a> <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; GC, Key, T, Traits &gt;::get </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>key</code> and return the item found. </p>
<p><a class="anchor" id="cds_nonintrusive_SkipListMap_hp_get"></a>The function searches the item with key equal to <code>key</code> and returns a guarded pointer to the item found. If <code>key</code> is not found the function returns an empty guarded pointer.</p>
<p>It is safe when a concurrent thread erases the item returned as <code>guarded_ptr</code>. In this case the item will be freed later by garbage collector <code>GC</code> automatically when <code>guarded_ptr</code> object will be destroyed or released. </p><dl class="section note"><dt>Note</dt><dd>Each <code>guarded_ptr</code> object uses one GC's guard which can be limited resource.</dd></dl>
<p>Usage: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap&lt; cds::gc::HP, int, foo, my_traits &gt;</a>  skip_list;</div><div class="line">skip_list theList;</div><div class="line"><span class="comment">// ...</span></div><div class="line">{</div><div class="line">    skip_list::guarded_ptr gp( theList.get( 5 ));</div><div class="line">    <span class="keywordflow">if</span> ( gp ) {</div><div class="line">        <span class="comment">// Deal with gp</span></div><div class="line">        <span class="comment">//...</span></div><div class="line">    }</div><div class="line">    <span class="comment">// Destructor of guarded_ptr releases internal HP guard</span></div><div class="line">}</div></div><!-- fragment --><p>Note the compare functor specified for class <code>Traits</code> template parameter should accept a parameter of type <code>K</code> that can be not the same as <code>value_type</code>. </p>

</div>
</div>
<a id="ac02677c1a928b5d44cf3064bfa75a97c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02677c1a928b5d44cf3064bfa75a97c">&sect;&nbsp;</a></span>get_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_skip_list_map.html#ad354cc5fb06255b8d60c87c2a20ebedc">guarded_ptr</a> <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; GC, Key, T, Traits &gt;::get_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>key</code> and return the item found. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#cds_nonintrusive_SkipListMap_hp_get">get( K const&amp;)</a> but <code>pred</code> is used for comparing the keys.</p>
<p><code>Less</code> functor has the semantics like <code>std::less</code> but should take arguments of type <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#adcff161d75ab8f150a8973c098d5bf3b">key_type</a> and <code>K</code> in any order. <code>pred</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a id="a09105b5b70939bf5570889c117b19797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09105b5b70939bf5570889c117b19797">&sect;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; GC, Key, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node with key and default value. </p>
<p>The function creates a node with <code>key</code> and default value, and then inserts the node created into the map.</p>
<p>Preconditions:</p><ul>
<li>The <code>key_type</code> should be constructible from a value of type <code>K</code>. In trivial case, <code>K</code> is equal to <code>key_type</code>.</li>
<li>The <code>mapped_type</code> should be default-constructible.</li>
</ul>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise. </p>

</div>
</div>
<a id="a81c6e0c78b65912ae3ed96aeae35fe56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81c6e0c78b65912ae3ed96aeae35fe56">&sect;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; GC, Key, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function creates a node with copy of <code>val</code> value and then inserts the node created into the map.</p>
<p>Preconditions:</p><ul>
<li>The <code>key_type</code> should be constructible from <code>key</code> of type <code>K</code>.</li>
<li>The <code>value_type</code> should be constructible from <code>val</code> of type <code>V</code>.</li>
</ul>
<p>Returns <code>true</code> if <code>val</code> is inserted into the set, <code>false</code> otherwise. </p>

</div>
</div>
<a id="a3c1d51549a3942e8d75f8361adf6ce9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1d51549a3942e8d75f8361adf6ce9e">&sect;&nbsp;</a></span>insert_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; GC, Key, T, Traits &gt;::insert_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node and initialize it by a functor. </p>
<p>This function inserts new node with key <code>key</code> and if inserting is successful then it calls <code>func</code> functor with signature </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div><div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_skip_list_map.html#af71e523091dcd181e35c363f862be3df">value_type</a>&amp; item );</div><div class="line">};</div></div><!-- fragment --><p>The argument <code>item</code> of user-defined functor <code>func</code> is the reference to the map's item inserted:</p><ul>
<li><code>item.first</code> is a const reference to item's key that cannot be changed.</li>
<li><code>item.second</code> is a reference to item's value that may be changed.</li>
</ul>
<p><code>key_type</code> should be constructible from value of type <code>K</code>.</p>
<p>The function allows to split creating of new item into two part:</p><ul>
<li>create item from <code>key</code>;</li>
<li>insert new item into the map;</li>
<li>if inserting is successful, initialize the value of item by calling <code>func</code> functor</li>
</ul>
<p>This can be useful if complete initialization of object of <code>value_type</code> is heavyweight and it is preferable that the initialization should be completed only if inserting is successful. </p>

</div>
</div>
<a id="ad27ba310bb08606dfda94bb58395a15c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27ba310bb08606dfda94bb58395a15c">&sect;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC , typename Key , typename T , typename Traits  = skip_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1container_1_1_skip_list_map.html">cds::container::SkipListMap</a>&lt; GC, Key, T, Traits &gt;::update </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bInsert</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates data by <code>key</code>. </p>
<p>The operation performs inserting or changing data with lock-free manner.</p>
<p>If the <code>key</code> not found in the map, then the new item created from <code>key</code> will be inserted into the map iff <code>bInsert</code> is <code>true</code> (note that in this case the <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#adcff161d75ab8f150a8973c098d5bf3b">key_type</a> should be constructible from type <code>K</code>). Otherwise, if <code>key</code> is found, the functor <code>func</code> is called with item found. The functor <code>Func</code> signature: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>my_functor {</div><div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_skip_list_map.html#af71e523091dcd181e35c363f862be3df">value_type</a>&amp; item );</div><div class="line">};</div></div><!-- fragment --><p> where:</p><ul>
<li><code>bNew</code> - <code>true</code> if the item has been inserted, <code>false</code> otherwise</li>
<li><code>item</code> - item of the map</li>
</ul>
<p>The functor may change any fields of the <code>item.second</code> that is <a class="el" href="classcds_1_1container_1_1_skip_list_map.html#af71e523091dcd181e35c363f862be3df">value_type</a>.</p>
<p>Returns <code> std::pair&lt;bool, bool&gt; </code> where <code>first</code> is <code>true</code> if operation is successful, <code>second</code> is <code>true</code> if new item has been added or <code>false</code> if <code>key</code> already exists.</p>
<dl class="section warning"><dt>Warning</dt><dd>See <a class="el" href="namespacecds_1_1intrusive.html#cds_intrusive_item_creating">insert item troubleshooting</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>cds/container/details/skip_list_base.h</li>
<li>cds/container/impl/skip_list_map.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.2.0</b> 
  Developed by <i>Maxim Khizhinsky aka khizmax</i> 2007 - 2017
  <br/>
  <i>Autogenerated Wed Jan 4 2017 08:49:40 by Doxygen 1.8.12</i>
</div>
</body>
</html>
